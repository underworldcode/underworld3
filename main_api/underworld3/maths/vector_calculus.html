<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>underworld3.maths.vector_calculus API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.maths.vector_calculus</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus"><code class="flex name class">
<span>class <span class="ident">mesh_vector_calculus</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh_vector_calculus:
    &#34;&#34;&#34;Vector calculus on uw row matrices
    - this class is designed to augment the functionality of a mesh&#34;&#34;&#34;

    def __init__(self, mesh):
        self.mesh = mesh
        self.dim = self.mesh.dim

    def cross(self, vector1, vector2):
        a = self.to_vector(vector1)
        b = self.to_vector(vector2)

        a_cross_b_vec = sympy.vector.cross(a, b)
        a_cross_b = self.to_matrix(a_cross_b_vec)

        return a_cross_b

    def curl(self, matrix):
        r&#34;&#34;&#34;
        $ \nabla \times \mathbf{v} $

        Returns the curl of a 3D vector field or the out-of-plane
        component of a 2D vector field
        &#34;&#34;&#34;

        vector = self.to_vector(matrix)
        vector_curl = sympy.vector.curl(vector)

        if self.dim == 3:
            return self.to_matrix(vector_curl)
        else:
            # if 2d, the out-of-plane vector is not defined in the basis so a scalar is returned (cf. vorticity)
            return vector_curl.dot(self.mesh.N.k)

    def divergence(self, matrix):
        r&#34;&#34;&#34;
        $ \nabla \cdot \mathbf{v} $
        &#34;&#34;&#34;
        vector = self.to_vector(matrix)
        scalar_div = sympy.vector.divergence(vector)
        return scalar_div

    def gradient(self, scalar):
        r&#34;&#34;&#34;
        $\nabla \phi$
        &#34;&#34;&#34;

        if isinstance(scalar, sympy.Matrix) and scalar.shape == (1, 1):
            scalar = scalar[0, 0]

        vector_gradient = sympy.vector.gradient(scalar)
        return self.to_matrix(vector_gradient)

    def strain_tensor(self, vector):
        &#34;&#34;&#34;
        Components of the infinitessimal strain or strain-rate tensor where the
        vector that is provided is displacement or velocity respectively
        &#34;&#34;&#34;

        # Coerce vector to sympy.Matrix form
        matrix = self.to_matrix(vector)

        L = matrix.jacobian(self.mesh.CoordinateSystem.N)
        E = (L + L.transpose()) / 2

        return E

    def to_vector(self, matrix):
        if isinstance(matrix, sympy.vector.Vector):
            return matrix  # No need to convert

        # Note, the mesh vector basis is always 3D so out-of-plane
        # vectors are allowed.

        if matrix.shape == (1, 2) or matrix.shape == (1, 3):
            vector = sympy.vector.matrix_to_vector(matrix, self.mesh.N)
        elif matrix.shape == (2, 1) or matrix.shape == (3, 1):
            vector = sympy.vector.matrix_to_vector(matrix.T, self.mesh.N)
        elif matrix.shape == (1, 1):
            vector = matrix[0, 0]
        else:
            print(f&#34;Unable to convert matrix of size {matrix.shape} to sympy.vector&#34;)
            vector = None

        return vector

    def to_matrix(self, vector):
        # Almost there ...

        if isinstance(vector, sympy.Matrix) and vector.shape == (1, self.dim):
            return vector

        if isinstance(vector, sympy.Matrix) and vector.shape == (self.dim, 1):
            return vector.T

        if isinstance(vector, sympy.Matrix) and vector.shape == (1, 1):
            return vector

        matrix = sympy.Matrix.zeros(1, self.dim)
        base_vectors = self.mesh.N.base_vectors()

        for i in range(self.dim):
            matrix[0, i] = vector.dot(base_vectors[i])

        return matrix

    def jacobian(self, matrix):
        &#34;&#34;&#34;Jacobian of a quantity (scalar, vector, matrix) wrt the natural mesh coordinates&#34;&#34;&#34;

        if isinstance(matrix, sympy.vector.Vector):
            matrix_form = self.to_matrix(matrix)
        else:
            matrix_form = matrix

        jac = matrix_form.jacobian(self.mesh.CoordinateSystem.N)

        return jac</code></pre>
</details>
<div class="desc"><p>Vector calculus on uw row matrices
- this class is designed to augment the functionality of a mesh</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical">mesh_vector_calculus_cylindrical</a></li>
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical">mesh_vector_calculus_spherical</a></li>
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat">mesh_vector_calculus_spherical_surface2D_lonlat</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>self, vector1, vector2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(self, vector1, vector2):
    a = self.to_vector(vector1)
    b = self.to_vector(vector2)

    a_cross_b_vec = sympy.vector.cross(a, b)
    a_cross_b = self.to_matrix(a_cross_b_vec)

    return a_cross_b</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curl(self, matrix):
    r&#34;&#34;&#34;
    $ \nabla \times \mathbf{v} $

    Returns the curl of a 3D vector field or the out-of-plane
    component of a 2D vector field
    &#34;&#34;&#34;

    vector = self.to_vector(matrix)
    vector_curl = sympy.vector.curl(vector)

    if self.dim == 3:
        return self.to_matrix(vector_curl)
    else:
        # if 2d, the out-of-plane vector is not defined in the basis so a scalar is returned (cf. vorticity)
        return vector_curl.dot(self.mesh.N.k)</code></pre>
</details>
<div class="desc"><p>$ \nabla \times \mathbf{v} $</p>
<p>Returns the curl of a 3D vector field or the out-of-plane
component of a 2D vector field</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.divergence"><code class="name flex">
<span>def <span class="ident">divergence</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divergence(self, matrix):
    r&#34;&#34;&#34;
    $ \nabla \cdot \mathbf{v} $
    &#34;&#34;&#34;
    vector = self.to_vector(matrix)
    scalar_div = sympy.vector.divergence(vector)
    return scalar_div</code></pre>
</details>
<div class="desc"><p>$ \nabla \cdot \mathbf{v} $</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, scalar)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient(self, scalar):
    r&#34;&#34;&#34;
    $\nabla \phi$
    &#34;&#34;&#34;

    if isinstance(scalar, sympy.Matrix) and scalar.shape == (1, 1):
        scalar = scalar[0, 0]

    vector_gradient = sympy.vector.gradient(scalar)
    return self.to_matrix(vector_gradient)</code></pre>
</details>
<div class="desc"><p>$\nabla \phi$</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian"><code class="name flex">
<span>def <span class="ident">jacobian</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jacobian(self, matrix):
    &#34;&#34;&#34;Jacobian of a quantity (scalar, vector, matrix) wrt the natural mesh coordinates&#34;&#34;&#34;

    if isinstance(matrix, sympy.vector.Vector):
        matrix_form = self.to_matrix(matrix)
    else:
        matrix_form = matrix

    jac = matrix_form.jacobian(self.mesh.CoordinateSystem.N)

    return jac</code></pre>
</details>
<div class="desc"><p>Jacobian of a quantity (scalar, vector, matrix) wrt the natural mesh coordinates</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.strain_tensor"><code class="name flex">
<span>def <span class="ident">strain_tensor</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain_tensor(self, vector):
    &#34;&#34;&#34;
    Components of the infinitessimal strain or strain-rate tensor where the
    vector that is provided is displacement or velocity respectively
    &#34;&#34;&#34;

    # Coerce vector to sympy.Matrix form
    matrix = self.to_matrix(vector)

    L = matrix.jacobian(self.mesh.CoordinateSystem.N)
    E = (L + L.transpose()) / 2

    return E</code></pre>
</details>
<div class="desc"><p>Components of the infinitessimal strain or strain-rate tensor where the
vector that is provided is displacement or velocity respectively</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.to_matrix"><code class="name flex">
<span>def <span class="ident">to_matrix</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_matrix(self, vector):
    # Almost there ...

    if isinstance(vector, sympy.Matrix) and vector.shape == (1, self.dim):
        return vector

    if isinstance(vector, sympy.Matrix) and vector.shape == (self.dim, 1):
        return vector.T

    if isinstance(vector, sympy.Matrix) and vector.shape == (1, 1):
        return vector

    matrix = sympy.Matrix.zeros(1, self.dim)
    base_vectors = self.mesh.N.base_vectors()

    for i in range(self.dim):
        matrix[0, i] = vector.dot(base_vectors[i])

    return matrix</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus.to_vector"><code class="name flex">
<span>def <span class="ident">to_vector</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_vector(self, matrix):
    if isinstance(matrix, sympy.vector.Vector):
        return matrix  # No need to convert

    # Note, the mesh vector basis is always 3D so out-of-plane
    # vectors are allowed.

    if matrix.shape == (1, 2) or matrix.shape == (1, 3):
        vector = sympy.vector.matrix_to_vector(matrix, self.mesh.N)
    elif matrix.shape == (2, 1) or matrix.shape == (3, 1):
        vector = sympy.vector.matrix_to_vector(matrix.T, self.mesh.N)
    elif matrix.shape == (1, 1):
        vector = matrix[0, 0]
    else:
        print(f&#34;Unable to convert matrix of size {matrix.shape} to sympy.vector&#34;)
        vector = None

    return vector</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical"><code class="flex name class">
<span>class <span class="ident">mesh_vector_calculus_cylindrical</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh_vector_calculus_cylindrical(mesh_vector_calculus):
    &#34;&#34;&#34;
    mesh_vector_calculus module for div, grad, curl etc that apply in
    native cylindrical coordinates
    &#34;&#34;&#34;

    def __init__(self, mesh):
        coordinate_type = mesh.CoordinateSystem.coordinate_type

        # validation

        if not (
            coordinate_type == CoordinateSystemType.CYLINDRICAL2D_NATIVE
            or coordinate_type == CoordinateSystemType.CYLINDRICAL3D_NATIVE
        ):
            print(
                f&#34;Warning mesh type {mesh.CoordinateSystem.type} uses Cartesian coordinates not cylindrical&#34;
            )

        super().__init__(mesh)

    def divergence(self, matrix):
        r&#34;&#34;&#34;
        $ \nabla \cdot \mathbf{v} $
        &#34;&#34;&#34;

        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]

        V_r = matrix[0]
        V_t = matrix[1]

        div_V = V_r.diff(r) + V_r / r + V_t.diff(t) / r

        if self.mesh.dim == 3:  # Or is this cdim ?
            z = self.mesh.CoordinateSystem.N[2]
            V_z = matrix[2]
            div_V += V_z.diff(z)

        return div_V

    def gradient(self, scalar):
        r&#34;&#34;&#34;
        $\nabla \phi$
        &#34;&#34;&#34;

        if isinstance(scalar, sympy.Matrix) and scalar.shape == (1, 1):
            scalar = scalar[0, 0]

        grad_S = sympy.Matrix.zeros(1, self.mesh.dim)

        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]

        grad_S[0] = scalar.diff(r)
        grad_S[1] = scalar.diff(t) / r

        if self.mesh.dim == 3:  # Or is this cdim ?
            z = self.mesh.CoordinateSystem.N[2]

            grad_S[2] = scalar.diff(z)

        return grad_S

    def curl(self, matrix):
        r&#34;&#34;&#34;
        $\nabla \phi$
        &#34;&#34;&#34;

        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]

        matrix0 = self.to_matrix(matrix)
        V_r = matrix0[0]
        V_t = matrix0[1]

        # if 2D, return a scalar of the out-of-plane curl

        if self.mesh.dim == 2:
            curl_V = V_t / r + V_t.diff(r) - V_r.diff(t) / r

        else:
            z = self.mesh.CoordinateSystem.N[2]
            V_z = matrix0[2]
            curl_V = sympy.Matrix.zeros(1, 3)

            curl_V[0] = V_z.diff(t) / r - V_t.diff(z)
            curl_V[1] = V_r.diff(z) - V_z.diff(r)
            curl_V[2] = V_t / r + V_t.diff(r) - V_r.diff(t) / r

        return curl_V

    def strain_tensor(self, vector):
        &#34;&#34;&#34;
        Components of the infinitessimal strain or strain-rate tensor where the
        vector that is provided is displacement or velocity respectively.
        In cylindrical geometry, there are additional terms that include
        the location of each point
        &#34;&#34;&#34;

        # Coerce vector to sympy.Matrix form
        matrix = self.to_matrix(vector)

        L = matrix.jacobian(self.mesh.CoordinateSystem.N)
        r = self.mesh.CoordinateSystem.N[0]

        vr = matrix[0]
        vt = matrix[1]

        E = L.copy()
        # E_00, E_22 and E_02 are unchanged from Cartesian

        # E[0,0] = L[0,0]
        E[1, 1] = L[1, 1] / r + vr / r
        E[1, 0] = E[0, 1] = (L[0, 1] / r + L[1, 0] - vt / r) / 2

        if self.dim == 3:
            E[1, 2] = E[2, 1] = (L[2, 1] / r + L[1, 2]) / 2
            E[0, 2] = E[2, 0] = (L[2, 0] + L[0, 2]) / 2

        return E</code></pre>
</details>
<div class="desc"><p>mesh_vector_calculus module for div, grad, curl etc that apply in
native cylindrical coordinates</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curl(self, matrix):
    r&#34;&#34;&#34;
    $\nabla \phi$
    &#34;&#34;&#34;

    r = self.mesh.CoordinateSystem.N[0]
    t = self.mesh.CoordinateSystem.N[1]

    matrix0 = self.to_matrix(matrix)
    V_r = matrix0[0]
    V_t = matrix0[1]

    # if 2D, return a scalar of the out-of-plane curl

    if self.mesh.dim == 2:
        curl_V = V_t / r + V_t.diff(r) - V_r.diff(t) / r

    else:
        z = self.mesh.CoordinateSystem.N[2]
        V_z = matrix0[2]
        curl_V = sympy.Matrix.zeros(1, 3)

        curl_V[0] = V_z.diff(t) / r - V_t.diff(z)
        curl_V[1] = V_r.diff(z) - V_z.diff(r)
        curl_V[2] = V_t / r + V_t.diff(r) - V_r.diff(t) / r

    return curl_V</code></pre>
</details>
<div class="desc"><p>$\nabla \phi$</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.strain_tensor"><code class="name flex">
<span>def <span class="ident">strain_tensor</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain_tensor(self, vector):
    &#34;&#34;&#34;
    Components of the infinitessimal strain or strain-rate tensor where the
    vector that is provided is displacement or velocity respectively.
    In cylindrical geometry, there are additional terms that include
    the location of each point
    &#34;&#34;&#34;

    # Coerce vector to sympy.Matrix form
    matrix = self.to_matrix(vector)

    L = matrix.jacobian(self.mesh.CoordinateSystem.N)
    r = self.mesh.CoordinateSystem.N[0]

    vr = matrix[0]
    vt = matrix[1]

    E = L.copy()
    # E_00, E_22 and E_02 are unchanged from Cartesian

    # E[0,0] = L[0,0]
    E[1, 1] = L[1, 1] / r + vr / r
    E[1, 0] = E[0, 1] = (L[0, 1] / r + L[1, 0] - vt / r) / 2

    if self.dim == 3:
        E[1, 2] = E[2, 1] = (L[2, 1] / r + L[1, 2]) / 2
        E[0, 2] = E[2, 0] = (L[2, 0] + L[0, 2]) / 2

    return E</code></pre>
</details>
<div class="desc"><p>Components of the infinitessimal strain or strain-rate tensor where the
vector that is provided is displacement or velocity respectively.
In cylindrical geometry, there are additional terms that include
the location of each point</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.divergence" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.divergence">divergence</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.gradient" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.gradient">gradient</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian">jacobian</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical"><code class="flex name class">
<span>class <span class="ident">mesh_vector_calculus_spherical</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh_vector_calculus_spherical(mesh_vector_calculus):
    r&#34;&#34;&#34;
    mesh_vector_calculus module for div, grad, curl etc that apply in
    native spherical coordinates r, \theta, \phi in the standard definition
    (radius, colatitude, longitude)
    &#34;&#34;&#34;

    def __init__(self, mesh):
        coordinate_type = mesh.CoordinateSystem.coordinate_type

        # validation

        if not coordinate_type == CoordinateSystemType.SPHERICAL_NATIVE:
            print(
                f&#34;Warning mesh type {mesh.CoordinateSystem.type} uses Cartesian coordinates not spherical&#34;
            )

        super().__init__(mesh)

    def divergence(self, matrix):
        r&#34;&#34;&#34;
        $ \nabla \cdot \mathbf{v} $
        &#34;&#34;&#34;

        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]
        p = self.mesh.CoordinateSystem.N[2]

        V_r = matrix[0]
        V_t = matrix[1]
        V_p = matrix[2]

        # cosecant_th = sympy.Piecewise(
        #     (1000, sympy.Abs(t) &lt; 0.01 * sympy.pi), (1 / sympy.sin(t), True)
        # )

        cosec_t = 1 / (sympy.sin(t) + 1.0e-6)

        div_V = (
            V_r.diff(r)
            + 2 * V_r / r
            + cosec_t * (V_p.diff(p) + sympy.cos(t) * V_t) / r
            + V_t.diff(t) / r
        )

        return div_V

    def gradient(self, scalar):
        r&#34;&#34;&#34;
        $\nabla \phi$
        &#34;&#34;&#34;

        if isinstance(scalar, sympy.Matrix) and scalar.shape == (1, 1):
            scalar = scalar[0, 0]

        grad_S = sympy.Matrix.zeros(1, 3)

        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]
        p = self.mesh.CoordinateSystem.N[2]

        cosec_t = 1 / (sympy.sin(t) + 1.0e-6)

        grad_S[0] = +scalar.diff(r)
        grad_S[1] = +scalar.diff(t) / r
        # grad_S[2] = sympy.Piecewise(
        #     (1000, sympy.Abs(p) &lt; 0.01 * sympy.pi),
        #     (scalar.diff(p) / (r * sympy.sin(t)), True),
        # )
        grad_S[2] = cosec_t * scalar.diff(p) / r

        return grad_S

    def curl(self, matrix):
        r&#34;&#34;&#34;
        $\nabla \times \phi$ in spherical
        &#34;&#34;&#34;

        r = self.mesh.CoordinateSystem.N[0]
        l1 = self.mesh.CoordinateSystem.N[1]
        l2 = self.mesh.CoordinateSystem.N[2]

        matrix0 = self.to_matrix(matrix)
        V_r = matrix[0]
        V_l1 = matrix[1]
        V_l2 = matrix[2]

        curl_V = sympy.Matrix.zeros(1, 3)

        curl_V[0] = (
            V_l1.diff(l2) / r
            - sympy.tan(l2) * V_l1 / r
            - V_l2.diff(l1) / (r * sympy.cos(l2))
        )
        curl_V[1] = V_l2.diff(r) + V_l2 / r - V_r.diff(l2) / r
        curl_V[2] = V_r.diff(l1) / (r * sympy.cos(l2)) - V_l1.diff(r) - V_l1 / r

        return curl_V

    def strain_tensor(self, vector):
        &#34;&#34;&#34;
        Components of the infinitessimal strain or strain-rate tensor where the
        vector that is provided is displacement or velocity respectively.
        In cylindrical geometry, there are additional terms that include
        the location of each point
        &#34;&#34;&#34;

        # Coerce vector to sympy.Matrix form
        matrix = self.to_matrix(vector)

        L = matrix.jacobian(self.mesh.CoordinateSystem.N)
        r = self.mesh.CoordinateSystem.N[0]
        t = self.mesh.CoordinateSystem.N[1]
        p = self.mesh.CoordinateSystem.N[2]

        V_r = matrix[0]
        V_t = matrix[1]
        V_p = matrix[2]

        cosec_t = 1 / (sympy.sin(t) + 1.0e-6)

        E = L.copy()

        E[0, 0] = L[0, 0]
        E[1, 1] = (L[1, 1] + V_r) / r
        E[2, 2] = V_r / r + cosec_t * (L[2, 2] - V_t * sympy.cos(t)) / r

        E[1, 0] = E[0, 1] = (L[0, 1] / r + L[1, 0] - V_t / r) / 2
        E[1, 2] = E[2, 1] = (L[2, 1] + cosec_t * (L[1, 2] - V_t * sympy.cos(t))) / (
            2 * r
        )

        E[2, 0] = E[0, 2] = (cosec_t * L[0, 2] / r + L[2, 0] - V_p / r) / 2

        return E</code></pre>
</details>
<div class="desc"><p>mesh_vector_calculus module for div, grad, curl etc that apply in
native spherical coordinates r, \theta, \phi in the standard definition
(radius, colatitude, longitude)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curl(self, matrix):
    r&#34;&#34;&#34;
    $\nabla \times \phi$ in spherical
    &#34;&#34;&#34;

    r = self.mesh.CoordinateSystem.N[0]
    l1 = self.mesh.CoordinateSystem.N[1]
    l2 = self.mesh.CoordinateSystem.N[2]

    matrix0 = self.to_matrix(matrix)
    V_r = matrix[0]
    V_l1 = matrix[1]
    V_l2 = matrix[2]

    curl_V = sympy.Matrix.zeros(1, 3)

    curl_V[0] = (
        V_l1.diff(l2) / r
        - sympy.tan(l2) * V_l1 / r
        - V_l2.diff(l1) / (r * sympy.cos(l2))
    )
    curl_V[1] = V_l2.diff(r) + V_l2 / r - V_r.diff(l2) / r
    curl_V[2] = V_r.diff(l1) / (r * sympy.cos(l2)) - V_l1.diff(r) - V_l1 / r

    return curl_V</code></pre>
</details>
<div class="desc"><p>$\nabla \times \phi$ in spherical</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.strain_tensor"><code class="name flex">
<span>def <span class="ident">strain_tensor</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain_tensor(self, vector):
    &#34;&#34;&#34;
    Components of the infinitessimal strain or strain-rate tensor where the
    vector that is provided is displacement or velocity respectively.
    In cylindrical geometry, there are additional terms that include
    the location of each point
    &#34;&#34;&#34;

    # Coerce vector to sympy.Matrix form
    matrix = self.to_matrix(vector)

    L = matrix.jacobian(self.mesh.CoordinateSystem.N)
    r = self.mesh.CoordinateSystem.N[0]
    t = self.mesh.CoordinateSystem.N[1]
    p = self.mesh.CoordinateSystem.N[2]

    V_r = matrix[0]
    V_t = matrix[1]
    V_p = matrix[2]

    cosec_t = 1 / (sympy.sin(t) + 1.0e-6)

    E = L.copy()

    E[0, 0] = L[0, 0]
    E[1, 1] = (L[1, 1] + V_r) / r
    E[2, 2] = V_r / r + cosec_t * (L[2, 2] - V_t * sympy.cos(t)) / r

    E[1, 0] = E[0, 1] = (L[0, 1] / r + L[1, 0] - V_t / r) / 2
    E[1, 2] = E[2, 1] = (L[2, 1] + cosec_t * (L[1, 2] - V_t * sympy.cos(t))) / (
        2 * r
    )

    E[2, 0] = E[0, 2] = (cosec_t * L[0, 2] / r + L[2, 0] - V_p / r) / 2

    return E</code></pre>
</details>
<div class="desc"><p>Components of the infinitessimal strain or strain-rate tensor where the
vector that is provided is displacement or velocity respectively.
In cylindrical geometry, there are additional terms that include
the location of each point</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.divergence" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.divergence">divergence</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.gradient" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.gradient">gradient</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian">jacobian</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat"><code class="flex name class">
<span>class <span class="ident">mesh_vector_calculus_spherical_surface2D_lonlat</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh_vector_calculus_spherical_surface2D_lonlat(mesh_vector_calculus):
    &#34;&#34;&#34;
    mesh_vector_calculus module for div, grad, curl etc that apply in
    native spherical coordinates on the surface of a sphere (r=r_0).
    NOTE - our choice of coordinates
    is slightly unusual - (radius) plus longitude and latitude (in radians)
    for convenience when it comes to working with Earth-Science datasets
    &#34;&#34;&#34;

    def __init__(self, mesh):
        coordinate_type = mesh.CoordinateSystem.coordinate_type

        # validation

        if not coordinate_type == CoordinateSystemType.SPHERE_SURFACE_NATIVE:
            print(
                f&#34;Warning mesh type {mesh.CoordinateSystem.type} is not a 2D spherical surface mesh&#34;
            )

        super().__init__(mesh)

    def divergence(self, matrix):
        r&#34;&#34;&#34;
        $ \nabla \cdot \mathbf{v} $
        &#34;&#34;&#34;

        r = sympy.sympify(1)
        l1 = self.mesh.CoordinateSystem.N[0]
        l2 = self.mesh.CoordinateSystem.N[1]

        V_r = sympy.sympify(0)
        V_l1 = matrix[0]
        V_l2 = matrix[1]

        unstable_term = V_l1.diff(l1) / (r * sympy.cos(l2)) - sympy.tan(l2) * V_l2 / r
        div_V = (
            sympy.Piecewise(
                (0, sympy.Abs(l2) &gt; 0.90 * sympy.pi / 2),
                (unstable_term, True),
            )
            + V_l2.diff(l2) / r
        )

        return div_V

    def gradient(self, scalar):
        r&#34;&#34;&#34;
        $\nabla \phi$
        &#34;&#34;&#34;

        if isinstance(scalar, sympy.Matrix) and scalar.shape == (1, 1):
            scalar = scalar[0, 0]

        grad_S = sympy.Matrix.zeros(1, 2)

        r = sympy.sympify(1)
        l1 = self.mesh.CoordinateSystem.N[0]
        l2 = self.mesh.CoordinateSystem.N[1]

        grad_S[0] = sympy.Piecewise(
            (0, sympy.Abs(l2) &gt; 0.90 * sympy.pi / 2),
            (scalar.diff(l1) / (r * sympy.cos(l2)), True),
        )
        grad_S[1] = scalar.diff(l2) / r

        return grad_S

    ## WIP - no R component or derivatives ... what does this mean ?
    def curl(self, matrix):
        r&#34;&#34;&#34;
        $\nabla \times \phi$ in spherical
        &#34;&#34;&#34;

        r = sympy.sympify(1)
        l1 = self.mesh.CoordinateSystem.N[0]
        l2 = self.mesh.CoordinateSystem.N[1]

        matrix0 = self.to_matrix(matrix)
        V_l1 = matrix[0]
        V_l2 = matrix[1]

        curl_V = (
            V_l1.diff(l2) / r
            - sympy.tan(l2) * V_l1 / r
            - V_l2.diff(l1) / (r * (1.0e-5 + sympy.cos(l2)))
        )

        return curl_V

    ## WIP - no R component or derivatives
    def strain_tensor(self, vector):
        &#34;&#34;&#34;
        Components of the infinitessimal strain or strain-rate tensor where the
        vector that is provided is displacement or velocity respectively.
        In cylindrical geometry, there are additional terms that include
        the location of each point
        &#34;&#34;&#34;

        # Coerce vector to sympy.Matrix form
        matrix = self.to_matrix(vector)

        L = matrix.jacobian(self.mesh.CoordinateSystem.N)
        r = sympy.sympify(1)
        l1 = self.mesh.CoordinateSystem.N[0]
        l2 = self.mesh.CoordinateSystem.N[1]

        V_r = matrix[0]
        V_l1 = matrix[1]
        V_l2 = matrix[2]

        E = L.copy()
        # E_00, E_22 and E_02 are unchanged from Cartesian

        E[0, 0] = (L[0, 0] - V_l2 * sympy.sin(l2)) / (r * (1.0e-5 + sympy.cos(l2)))
        E[1, 1] = (L[1, 1]) / r

        E[0, 1] = E[1, 0] = (
            -L[0, 1]
            - L[1, 0] / (1.0e-5 + sympy.cos(l2))
            - V_l1 * sympy.Max(sympy.tan(l2), 100)
        ) / (2 * r)

        return E</code></pre>
</details>
<div class="desc"><p>mesh_vector_calculus module for div, grad, curl etc that apply in
native spherical coordinates on the surface of a sphere (r=r_0).
NOTE - our choice of coordinates
is slightly unusual - (radius) plus longitude and latitude (in radians)
for convenience when it comes to working with Earth-Science datasets</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.curl"><code class="name flex">
<span>def <span class="ident">curl</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def curl(self, matrix):
    r&#34;&#34;&#34;
    $\nabla \times \phi$ in spherical
    &#34;&#34;&#34;

    r = sympy.sympify(1)
    l1 = self.mesh.CoordinateSystem.N[0]
    l2 = self.mesh.CoordinateSystem.N[1]

    matrix0 = self.to_matrix(matrix)
    V_l1 = matrix[0]
    V_l2 = matrix[1]

    curl_V = (
        V_l1.diff(l2) / r
        - sympy.tan(l2) * V_l1 / r
        - V_l2.diff(l1) / (r * (1.0e-5 + sympy.cos(l2)))
    )

    return curl_V</code></pre>
</details>
<div class="desc"><p>$\nabla \times \phi$ in spherical</p></div>
</dd>
<dt id="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.strain_tensor"><code class="name flex">
<span>def <span class="ident">strain_tensor</span></span>(<span>self, vector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strain_tensor(self, vector):
    &#34;&#34;&#34;
    Components of the infinitessimal strain or strain-rate tensor where the
    vector that is provided is displacement or velocity respectively.
    In cylindrical geometry, there are additional terms that include
    the location of each point
    &#34;&#34;&#34;

    # Coerce vector to sympy.Matrix form
    matrix = self.to_matrix(vector)

    L = matrix.jacobian(self.mesh.CoordinateSystem.N)
    r = sympy.sympify(1)
    l1 = self.mesh.CoordinateSystem.N[0]
    l2 = self.mesh.CoordinateSystem.N[1]

    V_r = matrix[0]
    V_l1 = matrix[1]
    V_l2 = matrix[2]

    E = L.copy()
    # E_00, E_22 and E_02 are unchanged from Cartesian

    E[0, 0] = (L[0, 0] - V_l2 * sympy.sin(l2)) / (r * (1.0e-5 + sympy.cos(l2)))
    E[1, 1] = (L[1, 1]) / r

    E[0, 1] = E[1, 0] = (
        -L[0, 1]
        - L[1, 0] / (1.0e-5 + sympy.cos(l2))
        - V_l1 * sympy.Max(sympy.tan(l2), 100)
    ) / (2 * r)

    return E</code></pre>
</details>
<div class="desc"><p>Components of the infinitessimal strain or strain-rate tensor where the
vector that is provided is displacement or velocity respectively.
In cylindrical geometry, there are additional terms that include
the location of each point</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.divergence" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.divergence">divergence</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.gradient" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.gradient">gradient</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian">jacobian</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3.maths" href="index.html">underworld3.maths</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus" href="#underworld3.maths.vector_calculus.mesh_vector_calculus">mesh_vector_calculus</a></code></h4>
<ul class="two-column">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.cross" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.cross">cross</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.curl" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.curl">curl</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.divergence" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.divergence">divergence</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.gradient" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.gradient">gradient</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.jacobian">jacobian</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.strain_tensor" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.strain_tensor">strain_tensor</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.to_matrix" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.to_matrix">to_matrix</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus.to_vector" href="#underworld3.maths.vector_calculus.mesh_vector_calculus.to_vector">to_vector</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical">mesh_vector_calculus_cylindrical</a></code></h4>
<ul class="">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.curl" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.curl">curl</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.strain_tensor" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_cylindrical.strain_tensor">strain_tensor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical">mesh_vector_calculus_spherical</a></code></h4>
<ul class="">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.curl" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.curl">curl</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.strain_tensor" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical.strain_tensor">strain_tensor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat">mesh_vector_calculus_spherical_surface2D_lonlat</a></code></h4>
<ul class="">
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.curl" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.curl">curl</a></code></li>
<li><code><a title="underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.strain_tensor" href="#underworld3.maths.vector_calculus.mesh_vector_calculus_spherical_surface2D_lonlat.strain_tensor">strain_tensor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
