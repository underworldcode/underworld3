[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Underworld3 Quick Start Guide",
    "section": "",
    "text": "Installation Guide\nWelcome to Underworld3, a mathematically self-describing, finite-element code for geodynamic modelling. This quick-start guide has basic installation instructions and a brief introduction to some of the concepts in the Underworld3 code.\nAll Underworld3 source code is released under the LGPL-3 open source licence. This covers all files in underworld3 constituting the Underworld3 Python module. Notebooks, stand-alone documentation and Python scripts which show how the code is used and run are licensed under the Creative Commons Attribution 4.0 International License.\nThe quickest option is not to install anything but click on the rocket icon (top right) to launch our notebook examples on mybinder.org.\nIf do you want to install the code on your own machine, we recommend using miniconda and mamba. Create a separate virtual environment and install the code from source. More details on how to do that are in the Installation Instructions",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#sample-code",
    "href": "index.html#sample-code",
    "title": "Underworld3 Quick Start Guide",
    "section": "Sample Code",
    "text": "Sample Code\nUnderworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nIt’s a good first step after you install the code to look at the examples notebooks. When you are happy that things are working OK, you can move along to look at the full documentation or the benchmarking repository.\nThe notebooks introduce the concept of meshing to describe the domain and boundary conditions for a model and progress through Eulerian data containers, symbolic operators (functions, compositions, derivatives, evaluations). The examples move on to the template PDE solvers for scalar and vector problems (in this case the Poisson equation and the Stokes equation) and time dependent, coupled problems (a simple convection example in an annulus geometry). They cover constitutive models, boundary conditions and visualisation. The final examples deal with Lagrangian data containers (particle swarms), first transporting them in a velocity field, and second, accessing the symbolic forms of their data for use in underworld expressions.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#learn-more",
    "href": "index.html#learn-more",
    "title": "Underworld3 Quick Start Guide",
    "section": "Learn More",
    "text": "Learn More\nunderworld3 is a research code under continual development and the examples in the notebooks provided with the code only touch upon the extent of its capabilities. Read the Next Steps page to find out how to learn more about underworld3, how to get in touch with the development team, and how to become part of the underworld community.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Underworld3 Quick Start Guide",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe Underworld codes represent more than two decades of programming effort by many developers including a wide community of contributors from the open-source community.\nAs a community-driven development team, we first acknowledge many contributions made through pull-requests to our repositories and direct submission of codes and examples. The underworldcode organisation on GitHub records all such contributions to the software and the underworld community on GitHub tracks the exchange of information and models.\nDirect funding support has been provided by:\n\nAuScope provides direct support for the core development team behind the underworld codes and the underworld cloud suite of tools. AuScope is funded by the Australian Government through the National Collaborative Research Infrastructure Strategy, NCRIS.\nThe development and testing of our codes is also supported by computational resources provided by the Australian Government through the National Computing Infrastructure (NCI) under the National Computational Merit Allocation Scheme.\nThe Australian Research Council (ARC) supported the development of novel algorithms, computational methods and applications under the Discovery Project and Linkage Project programs. AuScope funding was used to make these methods widely and freely available in the underworld codes. Direct support for Underworld was provided by ARC Industrial Transformation Research Hub Program (The Basin Genesis Hub)\n\nIn-kind support has also come from the institution that host Underworld developers including: the Australian National University, Monash University, The University of Melbourne, The University of Sydney and the CSIRO.\nUnderworld3 relies extensively upon the PETSc, sympy, numpy and cython packages and the jupyter notebook system. We acknowledge the enormous development effort required to build and maintain essential community infrastructure of this calibre and we extend our thanks to include the building blocks of each of these components that are too numerous to acknowledge individually.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#licensing-and-re-use",
    "href": "index.html#licensing-and-re-use",
    "title": "Underworld3 Quick Start Guide",
    "section": "Licensing and re-use",
    "text": "Licensing and re-use\nAll of our software is released under open source licence and all documentation and worked examples are released with a creative commons licence. We are passionate about having our software used and code reuse is strongly encouraged in the interest of scientific reproducibility and replicability. The developers are active researchers and scientists whose livelihood depends on their creative talents and the acknowledgement of their work. Please respect the effort that goes into developing software and tutorials by citing our work and collaborating on publication with new applications of our software when you can.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "Underworld3 Quick Start Guide",
    "section": "Background",
    "text": "Background\n\n\nBalay, S., S. Abhyankar, M. Adams, S. Benson, J. Brown, P. Brune, K.\nBuschelman, et al. 2024. “PETSc/TAO Users\nManual V.3.21.” ANL–21/39-Rev-3.21, 2337606, 188499. https://doi.org/10.2172/2337606.\n\n\nBehnel, Stefan, Robert Bradshaw, Craig Citro, Lisandro Dalcin, Dag\nSverre Seljebotn, and Kurt Smith. 2011. “Cython: The\nBest of Both Worlds.” Computing in Science &\nEngineering 13 (2): 31–39. https://doi.org/10.1109/mcse.2010.118.\n\n\nBeucher, Romain, Louis Moresi, Julian Giordani, John Mansour, Dan\nSandiford, Rebecca Farrington, Luke Mondy, et al. 2019.\n“UWGeodynamics: A Teaching and Research\nTool for Numerical Geodynamic Modelling.” Journal of Open\nSource Software, April. https://doi.org/10.21105/joss.01136.\n\n\nDalcin, Lisandro D., Rodrigo R. Paz, Pablo A. Kler, and Alejandro\nCosimo. 2011. “Parallel Distributed Computing Using\nPython.” Advances in Water Resources 34\n(9): 1124–39. https://doi.org/10.1016/j.advwatres.2011.04.013.\n\n\nGranger, Brian E., and Fernando Perez. 2021. “Jupyter:\nThinking and Storytelling With Code and\nData.” Computing in Science &\nEngineering 23 (2): 7–14. https://doi.org/10.1109/MCSE.2021.3059263.\n\n\nKnepley, Matthew G., Jed Brown, Karl Rupp, and Barry F. Smith. 2013.\n“Achieving High Performance with Unified\nResidual Evaluation.” arXiv:1309.1204 [Cs],\nSeptember. https://arxiv.org/abs/1309.1204.\n\n\nMansour, John, Julian Giordani, Louis Moresi, Romain Beucher, Owen\nKaluza, Mirko Velic, Rebecca Farrington, Steve Quenette, and Adam Beall.\n2020. “Underworld2: Python Geodynamics Modelling for\nDesktop, HPC and Cloud.”\nJournal of Open Source Software 5 (47): 1797. https://doi.org/10.21105/joss.01797.\n\n\nMeurer, Aaron, Christopher P. Smith, Mateusz Paprocki, Ondřej Čertík,\nSergey B. Kirpichev, Matthew Rocklin, AmiT Kumar, et al. 2017.\n“SymPy: Symbolic Computing in\nPython.” PeerJ Computer Science 3\n(January): e103. https://doi.org/10.7717/peerj-cs.103.\n\n\nMoresi, L., F. Dufour, and H.-B. Mühlhaus. 2003. “A\nLagrangian Integration Point Finite Element Method for\nLarge Deformation Modeling of Viscoelastic Geomaterials.”\nJournal of Computational Physics 184 (2): 476–97. https://doi.org/10.1016/S0021-9991(02)00031-1.\n\n\nMoresi, L., S. Quenette, V. Lemiale, C. Mériaux, B. Appelbe, and H. -B.\nMühlhaus. 2007. “Computational Approaches to Studying Non-Linear\nDynamics of the Crust and Mantle.” Physics of the Earth and\nPlanetary Interiors, Computational Challenges in the\nEarth Sciences, 163 (1): 69–82. https://doi.org/10.1016/j.pepi.2007.06.009.\n\n\nZhong, S. J., D. A. Yuen, L. N. Moresi, and M. G. Knepley. 2015.\n“7.05 - Numerical Methods for Mantle\nConvection.” In Treatise on Geophysics\n(Second Edition), edited by Gerald Schubert, 197–222.\nOxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00130-5.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "NextSteps.html",
    "href": "NextSteps.html",
    "title": "Next Steps",
    "section": "",
    "text": "Underworld Documentation and Examples\nIn addition to the notebooks in this brief set of examples, there are a number of sources of information on using Underworld3 that you can access:\n\nThe Underworld Website / Blog\nThe API documentation (all the modules and functions and their full sets of arguments) is automatically generated from the source code and uses the same rich markdown content as the notebook help text.\nThe underworld3 GitHub repository is the most active development community for the code.\n\n\n\nBenchmarks\nThe Underworld3 Benchmarks Repository is a useful place to find community benchmarks coded in underworld3 along with accuracy and convergence analysis. This is an open repository where you can make a pull request with new benchmark submissions once you get the hang of things.\n\n\nThe Underworld Community\nThe Underworld Community organisation on Github is a collection of contributed repositories from the underworld user community for all versions of the code and now includes scripts for underworld3.\n\n\nParallel Execution\nUnderworld3 is inherently parallel and designed for high performance computing. The symbolic layer is a relatively thin veneer that sits on top of the PETSc machinery. A script that has been developed in jupyter should be transferrable to an HPC environment with no changes (except that inherently serial operations such as visualisation and model reduction are best left to postprocessing / co-processing).\nWe recommend installing jupytext which allows either a seamless two-way conversion (or pairing) between the ipynb format and an annotated python script, or the ability to work entirely with annoted python scripts and not use ipynb at all. The python form does not store the output of notebook cells but there are advantages to this when scripts are under version control.\nAlmost all of our notebook examples are annotated python for this reason.An exception is the collection of notebooks in this quick-start guide because we want to show you the rendered output in the static web pages.\n    mpirun -np 1024 python3 Modelling_Script.py -uw_resolution 96\nThe main difference between the notebook development environment and HPC is the lack of interactivity, particularly in sending parameters to the script at launch time. Typically, we expect the HPC version to be running at much higher resolution, or for many more timesteps than the development notebook. We use the PETSc command line parsing machinery to generate notebooks that also can ingest run-time parameters from a script (as above).\n\n\nAdvanced capabilities\nDigging a bit deeper into underworld3, there are many capabilities that require a clear understanding of the concepts that underlie the implementation. The following examples are not plug-and-play, but they do only require python coding using the underworld3 API and no detailed knowledge of petsc4py or PETSc. Get in touch with us if you want to try this sort of thing but can’t figure it out for yourself.\n\nDeforming meshes\nIn Example 8, we made small variations to the mesh to conform to basal topography. We did not remesh, so we had to be careful to apply a smooth, analytic displacement to every node. For more general free-surface models, we need to calculate a smooth function using the computed boundary motions (e.g, solving a poisson equation with known boundary displacements as boundary conditions). We need to step through time and it is common to stabilize the surface motions through a surface integral term that accounts for the interface displacement during the timestep. The example below shows an underworld3 forward model with internal loads timestepped close to isostatic equilibrium.\n\n\n\nStokes flow driven by buoyancy in an annulus defined by two embedded surfaces within an enveloping disk mesh. The surfaces deform in response to the flow. The embedding medium has a very low viscosity but still acts to damp rotational modes. The outer boundary of the disk can be set to a far-field gravitational potential for whole-Earth relaxation models\n\n\nIn a more general case, we need to account to horizontal motions. This is more complicated because the horizontal velocities can be large even when vertical equilibrium is achieved. So we need to solve for the advected component of vertical motion in addition to the local component. Hooray for symbolic algebra !\n\n\nWeak / penalty boundary conditions\nExample 8 introduced the idea of penalty-based boundary conditions where the constraint is weakly enforced by providing a large penalty for violation of the condition. This is very flexible as the penalizing conditions can be adjusted during the run, including changing which part of the boundary is subject to constraints based on the solution or a coupled problem. The channel flow model shown below has a boundary condition that depends on a externally sourced model for ponded material at the base that is derived from a simple topography filling algorithm.\n\n\n\n\nLive Image: Stokes flow in a channel with multiple obstructions. Flow is driven from the inlet (a velocity boundary condition). The geometry was contructed with gmsh. This is an example for education which demonstrates the emergence of an large-scale pressure gradient as a result of the presence of the obstructions, and also the dispersion of tracers through the complicated flow geometry\nThe penalty approach does allow the solution to deviate from the exact value of the boundary condition, in a similar way to the iterative solvers delivering a solution to within a specified tolerance. There are some cases, for example, enforcing plate motions at the surface, where there are uncertainties in the applied boundary conditions and that these uncertainties may vary in space and time.\n\n\nMesh Adaptation\nIt is also possible to use the PETSc mesh adaption capabilities, to refine the resolution of a model where it is most needed and coarsen elsewhere. Dynamically-adapting meshes are possible but the interface is very low level at present, particularly in parallel.\n\n\n\n\nLive Image: Static mesh adaptation to the slope of a field. The driving buoyancy term is three plume-like upwellings and the slope of this field is shown in colour (red high, blue low). The adapted mesh is shown in green.\n\n    # t is the driving \"temperature\". We form an isotropic refinement metric from its slope\n\n    refinement_fn = 1.0 + sympy.sqrt(\n          t.diff(x) ** 2\n        + t.diff(y) ** 2\n        + t.diff(z) ** 2\n    )\n\n    icoord, meshA = adaptivity.mesh_adapt_meshVar(mesh0, refinement_fn, Metric, redistribute=True)",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Next Steps</span>"
    ]
  },
  {
    "objectID": "Installation.html",
    "href": "Installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "Source code build using mamba\nWe recommend that you use a conda / mamba virtual environment to build underworld3 whenever you want to install on a personal workstation or laptop (linux or macOS).The mamba documentation will help you get started if you are not familiar with the philososphy and practice of this package management system.\nThe underworld3 build / run-time dependencies can be installed using",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#source-code-build-using-mamba",
    "href": "Installation.html#source-code-build-using-mamba",
    "title": "Installation Guide",
    "section": "",
    "text": "(base) % git clone -b development --single-branch https://github.com/underworldcode/underworld3 /path/to/underworld3\n    (base) % cd /path/to/underworld3\n    (base) % mamba env create -n uw3 -f environment.yml\n    (base) % mamba activate uw3\n\n    (uw3) % compile.sh",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#source-code-build-using-mamba-and-existing-petsc",
    "href": "Installation.html#source-code-build-using-mamba-and-existing-petsc",
    "title": "Installation Guide",
    "section": "Source code build using mamba and existing PETSc",
    "text": "Source code build using mamba and existing PETSc\nIf you have an exisiting build of PETSc that you need to use, the following instructions work well. We create the environment as before but remove the pre- installed PETSc and petsc4py.\n    (base) % git clone -b development --single-branch https://github.com/underworldcode/underworld3 /path/to/underworld3\n    (base) % cd /path/to/underworld3\n    (base) % mamba env create -n uw3p -f environment.yml\n    (base) % mamba activate uw3p\n\n    (uw3p) % mamba remove petsc4py\n    (uw3p) % mamba remove petsc\nNext set up PETSc as you like it and build it using the tools within the current mamba virtual environment. Set the PETSC_ARCH environment variable to the name of this virtual environment to keep things from becoming muddled. See PETSc Installation for details on how to configure and build what you need.\n\n    (uw3p) % export PETSC_DIR=/path/to/petsc\n    (uw3p) % export PETSC_ARCH=\"uw3p\"\n    (uw3p) % git clone -b release https://gitlab.com/petsc/petsc.git $PETSC_DIR\n    (uw3p) % cd $PETSC_DIR\n    (uw3p) % # Configure & Build step\nNext we pip install the petsc4py that we just built into the mamba virtual environment. This ensures that petsc4py is available and also that its internal configuration points to the PETSc installation we just created. This way we don’t need to manage environment variables to point to the build that corresponds to a given virtual environment.\n    (uw3p) % mamba install cmake\n    (uw3p) % cd $PETSC_DIR/src/binding/petsc4py\n    (uw3p) % pip install .\nBuilding underworld3 against this version of PETSc should be identical to the mamba version.\n    (uw3p) % cd /path/to/underworld3\n    (uw3p) % compile.sh\n\nDid it work ?\nFirst run the tests:\n    (uw3p) % cd /path/to/underworld3\n    (uw3p) % source test.sh\nIf you have problems, contact us via the underworl3 GitHub issue tracker\n\n\nTo uninstall underworld3\n  (uw3) % pip uninstall underworld3\nAnd to clean the source directory if applicable\n  (uw3) % cd /path/to/underworld3\n  (uw3) % ./clean.sh",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#docker-container",
    "href": "Installation.html#docker-container",
    "title": "Installation Guide",
    "section": "Docker container",
    "text": "Docker container\nWindows users, if you don’t want to create a linux partition, you can use our containers with docker or podman. As the code is still in active development, we are not always able to provide containers for each change to the development branch. We ask that you reach out to us on our GitHub issue tracker to ask for information (use the “question” label).",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#hpc-builds",
    "href": "Installation.html#hpc-builds",
    "title": "Installation Guide",
    "section": "HPC builds",
    "text": "HPC builds\nUnderworld3 is inherently parallel and designed for use in high performance computing environments. The symbolic layer is relatively lightweight and should not adversely affect launch time (drawing down libraries from disk) or execution time (very few calculations are done in python itself).\nIn the HPC environment you may find it difficult to control the software stack. You will need to ensure that you can build against PETSc 3.21 or higher, since important functionality that we need is only available from that release onwards. We are happy to provide assistance with builds on specific machines and ask that you contact us through the GitHub issue tracker so that other people are able to browse the issues and their fixes.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Notebooks/Notebook_Index.html",
    "href": "Notebooks/Notebook_Index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Underworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nYou will find it helpful for developing scripts and analysing results. If you use jupytext to write notebooks directly as python scripts, then the same notebook codes will run on a parallel machine with no performance penalty.\nThe notebooks are rendered as html pages in this guide. They are distributed with the source code on GitHub and can be run on binder.\n\n\nNotebook 1 - Meshes\nMeshes: Introduces the mesh discretisation that we use in Underworld3 and how you can build one of the pre-defined meshes. This notebook also show you how to use the pyvista visualisation tools for Underworld3 objects. The mesh holds information on the mesh geometry, boundaries and coordinate systems.\n\n\nNotebook 2 - Mesh Variables\nVariables: Introduces the concept of MeshVariables in Underworld3. These are both data containers and sympy symbolic objects. We show you how to inspect a meshVariable, set the data values in the MeshVariable and visualise them.\n\n\nNotebook 3 - Symbols and sympy\nSymbols: meshVariables are sympy objects that can be composed with other symbolic objects and evaluated numerically when required. They can also be differentiated. Most importantly, sympy can manipulate expressions, simplify them and cancel terms.\n\n\nNotebook 4 - Example: Diffusion Equation\nDiffusion Solver: Introduces the various solver templates that are available in Underworld, starting with a steady-state diffusion problem. The template requires you to set some constitutive properties and define the unknowns. These are handled through subsitution into symbolic forms and the template equation can be inspected before you need to supply concrete expressions.\n\n\nNotebook 5 - Example: Stokes Equation\nStokes Solver: Stokes equation is a more complicated system of equations to solve. This complexity is mostly hidden when you set the problem up. There are some interesting ways to constrain boundary values which are demonstrated using an annulus mesh (curved, free-slip boundaries) and a \\(\\delta\\) function buoyancy source.\n\n\nNotebook 6 - Example: Time Dependence\nTimestepping: Coupled Stokes flow plus thermal advection-diffusion gives a simple convection solver. The timestepping loop is written by hand because usually you will want to do some analysis or output some checkpoints.\n\n\nNotebook 7 - Example: Navier-Stokes Equation\nUnsteady flow Using a passive swarm to track the pattern of flow developing in a pipe after an impulsive application of a boundary condition at the inflow. Particles need to be added to the passive swarm close to the inflow at each timestep.\n\n\nNotebook 8 - Lagrangian Swarm Variables\nSwarm Variables - exploring how they work for specifying material properties with a swarm used to determine element viscosity. We learn how to use swarm variables in expressions generally and for boundary conditions.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "Notebooks/1-Meshes.html",
    "href": "Notebooks/1-Meshes.html",
    "title": "Notebook 1: Meshes",
    "section": "",
    "text": "Introducing meshes: how to build them, interrogate them and visualise them.\n\nmesh.view()\nMesh refinement options\nMesh coordinates\nMesh coordinate systems\nMesh deformation\n\nMesh adaptivity is a work-in-progress.\n\nimport underworld3 as uw\nimport numpy as np\nimport sympy\n\n\nUnderworld meshing module\nUnderworld can read mesh definition files from the gmsh package but there are some constraints on how to specify boundaries if those meshes are to be used to solve numerical problems.\nThe underworld.meshing module has a collection of gmsh (python) examples for common, simple meshes.\n\nmesh = uw.meshing.uw.meshing.CubedSphere(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    numElements=8,\n    refinement=0,\n    simplex=False,\n    verbose=False,\n)\n\n\n\nMesh coordinate arrays\nIf you need to check the physical coordinates of the mesh, there is a data array\n    mesh.data\nwhich is a read-only numpy view of the coordinates (on the local segment of the mesh when running in parallel)\n\nmesh.data\n\narray([[ 0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027, -0.57735027, -0.57735027],\n       ...,\n       [ 0.58691901, -0.41511058, -0.41511058],\n       [ 0.6269543 , -0.44342636, -0.44342636],\n       [ 0.66698958, -0.47174214, -0.47174214]])\n\n\nThere are other pre-built meshes you can try. This is a cuboid divided into regular tetrahedra:\nmesh_usb = uw.meshing.UnstructuredSimplexBox(\n    minCoords = (-1.0, -1.0, -1.0),\n    maxCoords = (+1.0, +1.0, +1.0),\n    cellSize = 0.2,\n    regular=True,\n    verbose=False,\n)\nand this is a two-dimensional annulus mesh\nmesh_ann = uw.meshing.Annulus(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    cellSize= 0.5,\n    cellSizeOuter=0.033,\n    cellSizeInner=0.05,\n    verbose=False,\n)\nThe meshing infrastructure for underworld3 is documented here: https://underworldcode.github.io/underworld3/main_api/underworld3/meshing.html\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\n# Try out each one !\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"z\"] = vis.scalar_fn_to_pv_points(pvmesh, mesh.CoordinateSystem.X[2])\n\nif mesh.dim==3:\n    pvmesh_c = pvmesh.clip( normal='z', crinkle=True, inplace=False, origin=(0.0,0.0,0.01))\n\npl = pv.Plotter(window_size=(750, 750))\npl.add_mesh(pvmesh_c, show_edges=True, show_scalar_bar=False, opacity=1.0)\npl.add_mesh(pvmesh, show_edges=True, show_scalar_bar=False, opacity=0.3)\n\n\n# Save and show the mesh\npl.export_html(\"html5/spherical_mesh_plot.html\") \n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/spherical_mesh_plot.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Spherical shell mesh cut in half and overlain with transparent view of the whole mesh. Cubed sphere discretisation using hexahedral elements\n\n\n\n\nCoordinate systems\nThe mesh has an associated “natural” coordinate system (usually Cartesian), but it may also have other, more convenient, coordinate systems.\nFor example, the spherical mesh above has a Cartesian coordinate system which is the one used to navigate the mesh and describe the location of each point. It also has a spherical \\((r, \\theta, \\phi)\\) system which is symbolic and can be expanded in terms of the Cartesian coordinates.\n\n## The coordinate system\n\nX = mesh.CoordinateSystem.X\nR = mesh.CoordinateSystem.R\n\ndisplay(X)\ndisplay(R)\ndisplay(uw.function.expression.unwrap(R))\n\n\\(\\displaystyle \\left[\\begin{matrix}\\mathrm{x} & \\mathrm{y} & \\mathrm{z}\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}{ r \\hspace{ 0.0pt } } & { \\theta \\hspace{ 0.01pt } } & { \\phi \\hspace{ 0.02pt } }\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}} & \\operatorname{acos}{\\left(\\frac{\\mathrm{z}}{\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}}} \\right)} & \\operatorname{atan}_{2}{\\left(\\mathrm{y},\\mathrm{x} \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nMesh information\nmesh.view() allows you to interrogate the mesh to identify the mesh data structures (which means you can find by name any variable that is automatically constructed by, for example, one of the numerical solvers).\nIt also identifies boundaries of the mesh and their sizes when distributed in parallel. There is a PETSc equivalent which is also called and this contains low-level information on the mesh topology.\n\nmesh.view()\n\n\n\nMesh # 0: .meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh\n\nNo variables are defined on the mesh\n\n| Boundary Name            | ID    | Min Size | Max Size |\n| ------------------------------------------------------ |\n| Lower                    | 1     | 678      | 678      |\n| Upper                    | 2     | 678      | 678      |\n| All_Boundaries           | 1001  | 768      | 768      |\n| UW_Boundaries            | --    | 1356     | 1356     |\n| ------------------------------------------------------ |\n\n\nDM Object: uw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh 1 MPI process\n  type: plex\nuw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexFalse.msh in 3 dimensions:\n  Number of 0-cells per rank: 3474\n  Number of 1-cells per rank: 10000\n  Number of 2-cells per rank: 9600\n  Number of 3-cells per rank: 3072\nLabels:\n  depth: 4 strata with value/size (0 (3474), 1 (10000), 2 (9600), 3 (3072))\n  All_Boundaries: 1 strata with value/size (1001 (768))\n  Elements: 1 strata with value/size (99999 (5130))\n  Lower: 1 strata with value/size (1 (678))\n  Upper: 1 strata with value/size (2 (678))\n  celltype: 4 strata with value/size (0 (3474), 1 (10000), 4 (9600), 7 (3072))\n  UW_Boundaries: 2 strata with value/size (1 (678), 2 (678))\n\n\n\n\nMesh deformation\nYou can adjust the coordinates using:\n    mesh.deform(local_coordinate_array)\nThis rebuilds all the finite element gadgets that live on the mesh but it will not do any remeshing of the points. It is useful for small deformation such as following a free surface but not large-deformation adaptive meshing.\nSee Notebook 8 for a short mesh-deformation example.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Notebook 1: Meshes</span>"
    ]
  },
  {
    "objectID": "Notebooks/2-Variables.html",
    "href": "Notebooks/2-Variables.html",
    "title": "Notebook 2: Variables",
    "section": "",
    "text": "More information\nWe can add discrete variables (unknowns associated with the mesh points).\nThis example shows how we can add a scalar field with a single value associated with each mesh node, and a vector field which has quadratic interpolation (points at the nodes plus interpolating points along mesh edges).\nTo set values of the variable, we first have to unlock it using the access context manager, and then we can evaluate a function at the coordinates appropriate to fill up each variable:\nVariables are like most underworld and PETSc objects - they can be examined using their view() method. The information that you will see is split into the underworld representation (listed under MeshVariable) and the PETSc representation (listed under FE Data which also includes the numerical values).\nThe meshVariable code is described in the API docs: https://underworldcode.github.io/underworld3/main_api/underworld3/meshing.html",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Notebook 2: Variables</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html",
    "href": "Notebooks/3-Symbolic_Forms.html",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Symbolic forms, derivatives\nUnderworld is deeply integrated with sympy (www.sympy.org) so that any mesh variable can also be used in a sympy expression. We already saw sympy expressions for the coordinates and coordinate directions.\nIn the examples below, we use a simple 2D, Cartesian mesh because it is much simpler to see the various changes.\nAs before, we add discrete variables\nVariables can be part of complicated sympy expressions. It is important to note that all symbols are matrices and sympy can be fussy when it comes to operations with other matrices (scalars are not entirely equivalent to \\(1 \\times 1\\) matrices).\ns.sym[0]+t.sym[0] + v.sym[0]\n\n\\(\\displaystyle {\\cal{S}}(\\mathbf{x}) + {\\cal{T}}(\\mathbf{x}) + {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\nDerivatives can be handled explicitly, but the mesh also provides vector operators and these are generally better because they are automatically consistent with the underlying coordinate system for the mesh.\nFor compound expressions of variables, use mesh.vector.curl(expression) but for individual variables, variable.curl() is an equivalent shorthand.\n# grad by hand\ns.sym[0].diff(x) + s.sym[0].diff(y)\n\n\\(\\displaystyle {\\cal{S}}_{,0}(\\mathbf{x}) + {\\cal{S}}_{,1}(\\mathbf{x})\\)\n# grad\ns.gradient()\n\n\\(\\displaystyle \\left[\\begin{matrix}{\\cal{S}}_{,0}(\\mathbf{x}) & {\\cal{S}}_{,1}(\\mathbf{x})\\end{matrix}\\right]\\)\nv.curl()\n\n\\(\\displaystyle - {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\mathbf{v}}_{ 1,0}(\\mathbf{x})\\)\n# curl\nmesh.vector.curl(s.sym * v.sym)\n\n\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n# v dot grad (scalar)... \nv.sym.dot(mesh.vector.gradient(s.sym))\n\n\\(\\displaystyle {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x}) + {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x})\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "href": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Underworld Expressions\nWe often want to define symbols that represent complicated expressions which do not want to expand when we probe the mathematical formulation.\nAn example might be a constitutive model that has a number of conditional expressions, or a concept such as a timestep which we want to refer to as \\(\\delta t\\) regardless of its current numerical value.\nUnderworld expressions are objects that have a sympy symbolic representation that is only expanded at the time numerical evaluations are required. How about the example above in expression form:\n    curl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    f\"Curl of {v.symbol}\"\n                ) \ncreates an expression object which displays as \\(\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\\) but which also has curl_sv.sym which is the full expression.\n\ncurl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    rf\"Curl of {v.symbol}\"\n                ) \n\ncurl_sv.view()\ndisplay(curl_sv.sym) \n\ncurl_sv + 1\n\nClass: &lt;class ‘underworld3.function.expressions.UWexpression’&gt;\n\n\n\\(\\quad\\)\\(\\displaystyle { \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right) \\hspace{ 0.0pt } }\\)\\(=\\)\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\quad\\)Description: Curl of {}\n\n\n\\(\\displaystyle - {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 0,1}(\\mathbf{x}) + {\\cal{S}}(\\mathbf{x}) {\\mathbf{v}}_{ 1,0}(\\mathbf{x}) + {\\cal{S}}_{,0}(\\mathbf{x}) {\\mathbf{v}}_{ 1 }(\\mathbf{x}) - {\\cal{S}}_{,1}(\\mathbf{x}) {\\mathbf{v}}_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\displaystyle { \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right) \\hspace{ 0.0pt } } + 1\\)\n\n\n\n\nUnderworld Sub-expressions\nThe viscosity for a material with a yield stress might look like this:\n\\[\n\\eta_\\textrm{eff} = \\displaystyle \\min\\left({  {\\eta} }, \\frac{\\max\\left({ {\\tau_{y}} }, {  {\\tau_{y, \\mathrm{min}}} }\\right)}{2 {  \\dot\\varepsilon_{II} }}\\right)\n\\]\nwhere \\(\\tau_y\\) is a scalar yield stress, and \\(\\dot\\varepsilon_{II}\\) is the second invariant of the strain-rate tensor. Each of these would be a nested Underworld expression.\nTo expand the expression and see inside, we can use\n    expression.unwrap(keep_constants=True)\nwhich reaches down the hierarchy and recursively replaces any expression with its expanded sympy representation. If a symbol represents a constant value (float, int, or sympy number), then it is only replaced if keep_constants is set to False.\nSymbolic forms can be evaluated at points in the (meshed domain) using uw.function.evaluate. Pure sympy functions can be used to set values in the data container of a meshVariable object\n\nwith mesh.access(s, t):\n    s.data[:,0] = uw.function.evaluate(sympy.cos(3 * sympy.pi * x)**2 , s.coords)\n    t.data[:,0] = uw.function.evaluate(sympy.sin(3 * sympy.pi * y)**2 , t.coords)\n\n\ns.view()\n\nClass: &lt;class ‘underworld3.discretisation._MeshVariable’&gt;\n\n\nMeshVariable:\n\n\n\nsymbol: \\({\\cal{S}}\\)\n\n\nshape: \\((1, 1)\\)\n\n\ndegree: \\(1\\)\n\n\ncontinuous: True\n\n\ntype: SCALAR\n\n\n\nFE Data:\n\n\n\nPETSc field id: \\(0\\)\n\n\nPETSc field name: S\n\n\n\narray([[1.        ],\n       [1.        ],\n       [1.        ],\n       ...,\n       [0.79389263],\n       [0.79389263],\n       [0.79389263]])\n\n\n\n# Visualise it / them\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"s\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0])\npvmesh.point_data[\"t\"] = vis.scalar_fn_to_pv_points(pvmesh, t.sym[0])\npvmesh.point_data[\"sxt\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0]*t.sym[0])\n\npvmesh.warp_by_scalar(scalars=\"sxt\", factor=0.3, normal=(0,0,1), inplace=True)\n\n# pvmesh.plot(show_edges=True, show_scalar_bar=False)\n\npl = pv.Plotter(window_size=(750, 750))\n\npl.add_mesh(pvmesh, \n            show_edges=True,\n            edge_color=\"#4455FF\",\n            cmap=\"Greys\",\n            scalars=\"sxt\", \n            show_scalar_bar=False)\n\n# Save and show the mesh\n\npl.camera_position = 'yz'\npl.camera.azimuth = 45\npl.camera.elevation = 45\n\npl.export_html(\"html5/sine_squared.html\")\n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/sine_squared.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Square mesh of triangular elements on which we evaluated a simple sympy function of position\n\n\n\nLazy evaluation of expressions\nGenerally speaking, we use expressions as placeholders for parameters or functions that we know will be needed when it comes to solve a problem, but we can’t be sure that we can specify them at the time we set up the solver.\nIn the code for our solvers, for example, we set up a template with expressions that describe where the parameters of the problem will be and we expect you to fill the details in when we create a new solver-object. These template expressions are protected so that assignment just changes the value that the expression holds, it does not change the symbol or the description (though you can do this if you want).\nThis is a rather contrived example:\n\nR = uw.function.expression(r\"r\\left( \\mathbf{x} \\right)\",\n                           sympy.sqrt(x**2+y**2), \n                           \"distance from origin\")\n\nR1 = R + 1\n\nS = sympy.sqrt(x**2+y**2)\nS1 = S + 1\n               \n\n\nR2 = R.sym + 1\n\n\nS1\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nR.sym = S = sympy.sqrt((x-1)**2 + (y-1)**2)\n\n\nuw.function.expressions.unwrap(R1) # Lazy evaluation \n\n\\(\\displaystyle \\sqrt{\\left(\\mathrm{x} - 1\\right)^{2} + \\left(\\mathrm{y} - 1\\right)^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(S1)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(R2)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "href": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "title": "Notebook 3: Symbolic forms",
    "section": "Exercise 3.1",
    "text": "Exercise 3.1\nHave a look at the visco-plastic constitutive model (template) for Stokes equation\nstokes_solver = uw.systems.solvers.SNES_Stokes(mesh)\nstokes_solver.constitutive_model = uw.constitutive_models.ViscoPlasticFlowModel\nstokes_solver.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes_solver.constitutive_model.Parameters.yield_stress = 100\nYou can examine this expression in more detail using the view method of the stokes_solver.constitutive_model, and you can expand the expression to see how it reduces when sympy needs to evaluate this expression at one or more locations in the domain.\n\nExercise 3.2\nAssignment to an expression object replaces the sympy value but does not change the rest of the object. This is the concept of lazy evaluation which we introduced earlier.\nValidate this using the constititutive model above. Try changing the yield stress or the shear viscosity and see how the expression for the apparent viscosity changes.\ne.g. \n    stokes_solver.constitutive_model.Parameters.shear_viscosity_0 = sympy.exp(-10 * t.sym[0])\n    display(stokes_solver.constitutive_model.viscosity)\nActually, that won’t look different, will it ? You need to expand out the expressions a bit to see it. Try using stokes_solver.constitutive_model.viscosity.unwrap(). This function makes substitutions of all (underworld) sub-expressions in any sympy expression.\nYou can pass keep_constants=False if you want to expand all the numerical values as well. An expression is considered to be a constant if it contains no sub-expressions, MeshVariables, or mesh-coordinates. We usually do not want to have long floating point numbers all over the place when we check an expression except if it’s the values that we want to check.\nTry it !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers.html",
    "href": "Notebooks/4-Solvers.html",
    "title": "Notebook 4: Poisson Equation",
    "section": "",
    "text": "The Poisson Solver\nIn this example, we solve a steady, non-linear, scalar diffusion equation and show how to recover the fluxes.\nThere are a number of pre-defined solver systems defined in underworld3 which are templates for orchestrating the underlying PETSc objects. A solver requires us to define the unknown in the form of meshVariables, provide boundary conditions, a constitutive model, and provide uw.functions to define constitutive properties, and driving terms.\nWe will use the Poisson solver for the diffusion equation, and we will use a Projection solver to compute the vertical gradient term.\nThe solver classes themselves are documented, so we can figure out what is needed before we define anything:\nuw.systems.Poisson.view()\n\nThis class provides functionality for a discrete representation of the Poisson equation\n\\[\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{f}}}\n\\]\nThe term \\(\\mathbf{F}\\) relates the flux to gradients in the unknown \\(u\\)\n\nProperties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term\nuw.systems.Projection.view()\n\nSolves \\(u = \\tilde{f}\\) where \\(\\tilde{f}\\) is a function that can be evaluated within an element and \\(u\\) is a meshVariable with associated shape functions. Typically, the projection is used to obtain a continuous representation of a function that is not well defined at the mesh nodes. For example, functions of the spatial derivatives of one or more meshVariable (e.g. components of fluxes) can be mapped to continuous variables with a projection. More broadly it is a projection from one basis to another and its limitations should be evaluated within that context.\nThe projection implemented by creating a solver for this problem\n\\[\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla u \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ u - \\tilde{f} \\Bigl] }_{\\mathbf{f}}} = 0\n\\]\nWhere the term \\(\\mathbf{F}\\) provides a smoothing regularization. \\(\\alpha\\) can be zero.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers.html#properties",
    "href": "Notebooks/4-Solvers.html#properties",
    "title": "Notebook 4: Poisson Equation",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/5-Solvers.html",
    "href": "Notebooks/5-Solvers.html",
    "title": "Notebook 5: Stokes Equation",
    "section": "",
    "text": "Mesh with embedded internal surface where we apply harmonic thermal forcing. This allows us to compute topography and gravity kernels. We’ll use a cylindrical annulus this timeand we’ll use free-slip boundary conditions throughout.\n\nimport underworld3 as uw\nimport numpy as np\nimport sympy\n\n\nres = 0.075\nr_o = 1.0\nr_int = 0.825\nr_i = 0.55\n\n\nmeshball = uw.meshing.AnnulusInternalBoundary(radiusOuter=r_o, \n                                              radiusInternal=r_int, \n                                              radiusInner=r_i, \n                                              cellSize_Inner=res,\n                                              cellSize_Internal=res*0.5,\n                                              cellSize_Outer=res,\n                                              centre=False,)\nmeshball.view()\n\nx, y = meshball.CoordinateSystem.X\nr, th = meshball.CoordinateSystem.xR\nunit_rvec = meshball.CoordinateSystem.unit_e_0\n\n\n# Orientation of surface normals\nGamma_N = unit_rvec\n\n\n\n\nMesh # 0: .meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh\n\nNo variables are defined on the mesh\n\n| Boundary Name            | ID    | Min Size | Max Size |\n| ------------------------------------------------------ |\n| Lower                    | 1     | 94       | 94       |\n| Internal                 | 2     | 278      | 278      |\n| Upper                    | 3     | 166      | 166      |\n| Centre                   | 10    | 0        | 0        |\n| All_Edges                | 1000  | 0        | 0        |\n| All_Boundaries           | 1001  | 132      | 132      |\n| UW_Boundaries            | --    | 538      | 538      |\n| ------------------------------------------------------ |\n\n\nDM Object: uw_.meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh 1 MPI process\n  type: plex\nuw_.meshes/uw_annulus_internalBoundary_rO1.0rInt0.825_rI0.55_csize0.1_csizefs0.075.msh in 2 dimensions:\n  Number of 0-cells per rank: 1142\n  Number of 1-cells per rank: 3294\n  Number of 2-cells per rank: 2152\nLabels:\n  depth: 3 strata with value/size (0 (1142), 1 (3294), 2 (2152))\n  All_Boundaries: 1 strata with value/size (1001 (132))\n  Elements: 1 strata with value/size (666666 (3022))\n  Internal: 1 strata with value/size (2 (278))\n  Lower: 1 strata with value/size (1 (94))\n  Upper: 1 strata with value/size (3 (166))\n  celltype: 3 strata with value/size (0 (1142), 1 (3294), 3 (2152))\n  UW_Boundaries: 3 strata with value/size (1 (94), 2 (278), 3 (166))\n\n\n\nSolver setup\nWe can obtain unit vectors in the natural coordinate system (here \\(r\\), \\(\\theta\\)) as mesh.CoordinateSystem.unit_e_0, mesh.CoordinateSystem.unit_e_1. There is a null space if we apply the boundary conditions exactly, and so we define a function to represent the null space.\nWe can set solver options via the petsc_options interface on the solver.\n\n# Create a density structure / buoyancy force\n# gravity will vary linearly from zero at the centre\n# of the sphere to (say) 1 at the surface\n\n\n# Null space in velocity (constant v_theta) expressed in x,y coordinates\nv_theta_fn_xy = r * meshball.CoordinateSystem.rRotN.T * sympy.Matrix((0,1))\n\n# Mesh variables for the unknowns\n\nv_soln = uw.discretisation.MeshVariable(\"V0\", meshball, 2, degree=2, varsymbol=r\"{v_0}\")\np_soln = uw.discretisation.MeshVariable(\"p\", meshball, 1, degree=1, continuous=True)\n\nstokes = uw.systems.Stokes(\n    meshball, \n    velocityField=v_soln, \n    pressureField=p_soln,\n)\n\nstokes.constitutive_model = uw.constitutive_models.ViscousFlowModel\nstokes.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes.tolerance = 1.0e-6\n\nstokes.petsc_options.setValue(\"ksp_monitor\", None)\nstokes.petsc_options.setValue(\"snes_monitor\", None)\nstokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"\n\n\n\nNatural boundary conditions\nIn FEM, natural boundary conditions are fluxes specified at a boundary (through surface integrals). We can also apply integrals to internal surfaces. We need to compute the vector components of the boundary condition (normal / tangential) and supply them in the Cartesian frame.\nThe bouyancy force on the internal surface is already radial, so this translates to\n    stokes.add_natural_bc(-t_init * unit_rvec, \"Internal\")\nTo set a no-normal-flow boundary condition, we need to penalise the radial velocity at the boundaries. Symbolically this is\n\\[\n    \\mathbf{f} = \\lambda \\left( \\mathbf{v} \\cdot \\Gamma_N \\right) \\,\\, \\Gamma_N\n\\]\nwhere \\(\\lambda\\) is a large penalty value. This translates into sympy code as\n    stokes.add_natural_bc(\n                penalty * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Lower\"\n                )\n\n\nstokes.bodyforce = sympy.Matrix([0,0])\n\n# Note, the thermal bouyancy field is localised in the radius using a \n# gaussian solely for the purposes of plotting. It is automatically\n# a delta function when applied through a surface integral\n\nt_init = sympy.sin(5*th) * sympy.exp(-1000.0 * ((r - r_int) ** 2)) \n\nstokes.add_natural_bc(-t_init * unit_rvec, \"Internal\")\nstokes.add_natural_bc(10000 * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Upper\")\n\nif r_i != 0.0:\n    stokes.add_natural_bc(10000 * Gamma_N.dot(v_soln.sym) *  Gamma_N, \"Lower\")\n\nstokes.solve()\n\n  0 SNES Function norm 2.307507502179e-01\n    Residual norms for stokes_ solve.\n    0 KSP Residual norm 8.742204758135e+00\n    1 KSP Residual norm 7.603223176805e-07\n  1 SNES Function norm 4.751452850114e-08\n\n\n\n\nRemoval of the null space\nWe can use the uw.maths.Integral to compute the inner product of the null space and the velocity solution. It is not zero, so we remove it !\n\n# Null space evaluation\n\nI0 = uw.maths.Integral(meshball, v_theta_fn_xy.dot(v_theta_fn_xy))\nvnorm = I0.evaluate()\n                                  \nI0.fn = v_theta_fn_xy.dot(v_soln.sym)\nns = I0.evaluate()\n\nprint(ns/vnorm, vnorm)\n\nwith meshball.access(v_soln):\n    dv = uw.function.evaluate(ns * v_theta_fn_xy, v_soln.coords) / vnorm\n    v_soln.data[...] -= dv \n\nns = I0.evaluate()\nprint(ns/vnorm, vnorm)\n\n0.0005624988949826505 1.4249504223200373\n1.9675625281382883e-19 1.4249504223200373\n\n\n\n\nif uw.mpi.size == 1:\n    import pyvista as pv\n    import underworld3.visualisation as vis\n\n    pvmesh = vis.mesh_to_pv_mesh(meshball)\n    pvmesh.point_data[\"P\"] = vis.scalar_fn_to_pv_points(pvmesh, p_soln.sym)\n    pvmesh.point_data[\"V\"] = vis.vector_fn_to_pv_points(pvmesh, v_soln.sym)\n    pvmesh.point_data[\"T\"] = vis.scalar_fn_to_pv_points(pvmesh, t_init)\n    \n    skip = 1\n    points = np.zeros((meshball._centroids[::skip].shape[0], 3))\n    points[:, 0] = meshball._centroids[::skip, 0]\n    points[:, 1] = meshball._centroids[::skip, 1]\n    point_cloud = pv.PolyData(points)\n\n    pvstream = pvmesh.streamlines_from_source(\n        point_cloud, vectors=\"V\", \n        integration_direction=\"both\", \n        integrator_type=45,\n        surface_streamlines=True,\n        initial_step_length=0.01,\n        max_time=0.5,\n        max_steps=500, \n    )\n   \n\n    pl = pv.Plotter(window_size=(750, 750))\n\n    pl.add_mesh(\n        pvmesh,\n        cmap=\"coolwarm\",\n        edge_color=\"Grey\",\n        edge_opacity=0.33,\n        scalars=\"T\",\n        show_edges=True,\n        use_transparency=False,\n        opacity=1.0,\n        show_scalar_bar=False\n    )\n\n\n    pl.add_mesh(pvstream, opacity=0.3, show_scalar_bar=False, cmap=\"Greens\", render_lines_as_tubes=False)\n\n    pl.export_html(\"html5/stokes_annulus_plot.html\")\n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/stokes_annulus_plot.html\", width=500, height=400)\n\n\n        \n        \nInteractive Image: Annulus mesh of triangular elements on which we evaluated Stokes flow driven by an internal delta function buoyancy. Boundary conditions are free slip, imposed using a penalty on the radial velocity at the boundary",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Notebook 5: Stokes Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html",
    "href": "Notebooks/6-Timestepping.html",
    "title": "Notebook 6: Time-dependence",
    "section": "",
    "text": "Create linked solvers\nWe’ll look at a convection problem which couples Stokes Flow with time-dependent advection/diffusion.\nThe starting point is our previous notebook where we solved for Stokes flow in a cylindrical annulus geometry. We then add an advection-diffusion solver to evolve temperature. The Stokes buoyancy force is proportional to the temperature anomaly, and the velocity solution is fed back into the temperature advection term.\nWe create the Stokes solver as we did in the previous notebook. The buoyancy force is proportional to the temperature anomaly (t_soln). Solvers can either be provided with unknowns as pre-defined meshVariables, or they will define their own. When solvers are coupled, explicitly defining unknowns makes everything clearer.\nThe advection-diffusion solver evolved t_soln using the Stokes velocity v_soln in the fluid-transport term.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---null-space",
    "href": "Notebooks/6-Timestepping.html#exercise---null-space",
    "title": "Notebook 6: Time-dependence",
    "section": "Exercise - Null space",
    "text": "Exercise - Null space\nBased on our previous notebook, can you see how to calculate and (if necessary) remove rigid-body the rotation null-space from the solution ?\nThe use of a coarse-level singular-value decomposition for the velocity solver should help, in this case, but it’s wise to check anyway.\n    stokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "href": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "title": "Notebook 6: Time-dependence",
    "section": "Exercise - Heat flux",
    "text": "Exercise - Heat flux\nCould you calculate the radial heat flux field ? Its surface average value plotted against time tells you if you have reached a steady state.\nHint:\n\\[\n    Q_\\textrm{surf} = \\nabla T \\cdot \\hat{r} + T (\\mathbf{v} \\cdot \\hat{r} )\n\\]\n    Q_surf = -meshball.vector.gradient(t_soln.sym).dot(unit_rvec) +\\\n                    t_soln.sym[0] * v_soln.sym.dot(unit_rvec)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Time-dependence</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html",
    "href": "Notebooks/7-Unsteady_Flow.html",
    "title": "Notebook 7: Unsteady Flow",
    "section": "",
    "text": "Exercise - 7.1\nWe’ll look at tracking an unsteady flow using a swarm of particle flow-tracers.\nTo begin with, the set up follows the same path as all previous notebooks: - Create a mesh - Add some variables - Create the solver we need (NavierStokes this time) - Add boundary conditions and constitutive properties.\nWe also add a projection solver to compute the vorticity of the flow (see 4-\nTo track the time evolution of the flow, we introduce a “passive” particle swarm. Passive, here, refers to the fact that the flow is not changed by the presence of the marker particles.\nIn the time-loop we have to update the particle locations and we keep this as an explicity operation, in general, because it provide the opportunity for you to make changes or perform analyses. In this case, we are adding new particles near the inflow to track the flow.\nNow that you have seen the structure of the flow in this example, can you adjust the addition of particles to capture the structure more clearly ?\nThis is a very low-resolution example. You can try increasing the resolution but you will see that this would benefit from running in parallel. In parallel we should remove all the visualisation and visualise the h5 output files when we are done. The rest of the code is parallel-safe.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html",
    "href": "Notebooks/8-Particle_Swarms.html",
    "title": "Notebook 8: Particle Swarms",
    "section": "",
    "text": "Deform the mesh\nWe used a particle swarm to track the flow in Example 7. We called this a “passive” swarm because the points did not influence the flow in any way but was simply carried along.\nParticle swarms are unstructured data objects that live within the computational domain. Their points can be moved arbitrarily through the domain and points may migrate from one process to another when the coordinates are changed. By default they carry only the particle location, but we can add scalar, vector and tensor variables to the swarm and they will be transported with the particles.\nParticle transport is usually through a velocity or displacement field that incrementally changes the locations. This is a common use, but particles can be used to represent any unstructured field. For example, during mesh adaptation, the nodal points from the previous mesh are equivalent to a disconnected swarm from the point of view of the new mesh. The same is true when reading data save from one mesh to the MeshVariables on another.\nMove all nodes down to meet an undulating lower surface. The displacement field is smooth and continuous, so there is no particular need to remesh in this case. However, it is generally better to consider either deforming the mesh with gmsh before triangulation, or remeshing (both are possible with underworld3, but not as simple to demonstrate).\nnew_coords = mesh.data\ndy =  (1-y) * (sympy.sin(sympy.pi * x)/10) \nnew_coords[:,1] = uw.function.evalf(y-dy, mesh.data)\n\ndisplay(dy)\n\nmesh.deform_mesh(new_coords)\n\n\\(\\displaystyle \\frac{\\left(1 - \\mathrm{y}\\right) \\sin{\\left(\\mathrm{x} \\pi \\right)}}{10}\\)\n# y coordinate after 1st deformation\ny1 = uw.discretisation.MeshVariable(\"Y1\", \n                                    mesh, \n                                    vtype=uw.VarType.SCALAR,\n                                    varsymbol=r\"y_1\")\n\nwith mesh.access(y1):\n    y1.data[:,0] = uw.function.evalf(y, y1.coords)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "href": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "title": "Notebook 8: Particle Swarms",
    "section": "Exercise - 8.1",
    "text": "Exercise - 8.1\nLook at the Stokes example and try with a free slip base and low / high viscosity for the trapped material. You could also see what mixing the boundary condition looks like: free slip in the troughs, fixed in the highs. This is possible with a single boundary condition if you use sympy.Piecewise to switch between different penalty conditions.\n\n    ## Free slip base (conditional)\n\n    Gamma = mesh.Gamma\n    GammaNorm = uw.function.expression(r\"|\\Gamma|\", sympy.sqrt(Gamma.dot(Gamma)), \"Scaling for surface normals\")\n    GammaN = Gamma / GammaNorm\n    \n    bc_mask = sympy.Piecewise((1.0, y1.sym[0] &lt; -0.05), (0.0, True))\n    nbc = 10000 * bc_mask * GammaN.dot(v_soln.sym) *  GammaN + (1-bc_mask) * v_soln.sym            \n    stokes.add_natural_bc(nbc, \"Lower\")\nGive that a try !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  }
]