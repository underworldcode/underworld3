[
  {
    "name": "SolverBaseClass",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 22,
    "signature": "class SolverBaseClass(uw_object):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Scalar",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 807,
    "signature": "class SNES_Scalar(SolverBaseClass):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Vector",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1401,
    "signature": "class SNES_Vector(SolverBaseClass):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Stokes_SaddlePt",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2092,
    "signature": "class SNES_Stokes_SaddlePt(SolverBaseClass):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_MyEquation",
    "kind": "class",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 17,
    "signature": "class SNES_MyEquation",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Template solver for scalar PDEs.\n\nProvides a discrete representation of a general scalar equation.\nThe governing equation is:\n\n.. math::\n\n    \\underbrace{\\frac{\\partial u}{\\partial t}}_{\\dot{u}}\n    + \\underbrace{\\nabla \\cdot \\mathbf{F}(u, \\nabla u)}_{\\text{Flux}}\n    = \\underbrace{f(\\mathbf{x}, t, u)}_{\\text{Source}}\n\nwhere:\n\n- :math:`u` is the unknown scalar field\n- :math:`\\mathbf{F}(u, \\nabla u)` is the flux term (diffusion, advection, etc.)\n- :math:`f(\\mathbf{x}, t, u)` is the source/sink term\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    The solution field. Created automatically if None.\ndegree : int, default=2\n    Polynomial degree for the finite element basis.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : DDt object, optional\n    Time derivative discretization method for solution.\nDFDt : DDt object, optional\n    Time derivative discretization method for flux.\n\nAttributes\n----------\nu : MeshVariable\n    The scalar unknown :math:`u`.\nf : sympy.Expr\n    Source/sink term.\n\nNotes\n-----\n- The constitutive model relates flux to gradients: :math:`\\mathbf{F} = -\\kappa \\nabla u`\n- Material properties are provided through the ``constitutive_model`` property\n- Supports time-dependent problems and nonlinear constitutive relationships\n\nExamples\n--------\nCreate a basic solver:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1))\n>>> solver = uw.systems.SNES_MyEquation(mesh, degree=2)\n>>> solver.f = 1.0  # Set source term\n>>> solver.solve()\n\nWith custom field and constitutive model:\n\n>>> u_field = uw.discretisation.MeshVariable(\"u\", mesh, 1, degree=2)\n>>> solver = uw.systems.SNES_MyEquation(mesh, u_Field=u_field)\n>>> solver.constitutive_model = uw.constitutive_models.DiffusionModel(mesh)\n>>> solver.constitutive_model.Parameters.diffusivity = 1.0",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_MyVectorEquation",
    "kind": "class",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 309,
    "signature": "class SNES_MyVectorEquation",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Template solver for vector-valued PDEs.\n\nProvides a discrete representation of a general vector equation:\n\n.. math::\n\n    \\underbrace{\\frac{\\partial \\mathbf{u}}{\\partial t}}_{\\dot{\\mathbf{u}}}\n    + \\underbrace{\\nabla \\cdot \\mathbf{F}(\\mathbf{u}, \\nabla \\mathbf{u})}_{\\text{Flux}}\n    = \\underbrace{\\mathbf{f}(\\mathbf{x}, t, \\mathbf{u})}_{\\text{Source}}\n\nwhere :math:`\\mathbf{u}` is a vector field.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    The solution vector field. Created automatically if None.\ndegree : int, default=2\n    Polynomial degree for the finite element basis.\nverbose : bool, default=False\n    Enable verbose output.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Poisson",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 154,
    "signature": "class SNES_Poisson",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Poisson equation solver.\n\nProvides a discrete representation of the Poisson equation:\n\n.. math::\n\n    \\nabla \\cdot \\left[ \\boldsymbol{\\kappa} \\nabla u \\right] = f\n\nwhere :math:`\\mathbf{F} = \\boldsymbol{\\kappa} \\nabla u` relates the flux to\ngradients in the unknown :math:`u`.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    Pre-existing mesh variable for the solution. If None, one is created.\nverbose : bool, optional\n    Enable verbose output during solve.\ndegree : int, optional\n    Polynomial degree for the solution field (default: 2).\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for time-dependent problems.\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nu : MeshVariable\n    The unknown scalar field.\nconstitutive_model : DiffusionModel\n    Provides the diffusivity tensor :math:`\\kappa`. Set to one of the\n    scalar ``uw.constitutive_models`` classes. Can be constant, spatially\n    varying, non-linear, or anisotropic.\nf : sympy.Expr\n    Volumetric source term.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Darcy",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 333,
    "signature": "class SNES_Darcy",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Darcy flow equation solver for groundwater problems.\n\nProvides a discrete representation of the groundwater flow equations:\n\n.. math::\n\n    \\underbrace{S_s \\frac{\\partial h}{\\partial t}}_{\\dot{u}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa} \\nabla h\n    - \\boldsymbol{s} \\right]}_{\\mathbf{F}}\n    = \\underbrace{W}_{h}\n\nThe flux term :math:`\\mathbf{F}` relates the effective velocity to\npressure gradients:\n\n.. math::\n\n    \\boldsymbol{v} = \\boldsymbol{\\kappa} \\nabla h - \\boldsymbol{s}\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nh_Field : MeshVariable, optional\n    Mesh variable for hydraulic head. Created automatically if not provided.\nv_Field : MeshVariable, optional\n    Mesh variable for Darcy velocity. Created automatically if not provided.\ndegree : int, default=2\n    Polynomial degree for the finite element discretization.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : optional\n    Time derivative operator for the unknown.\nDFDt : optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nh : MeshVariable\n    The hydraulic head unknown.\nv : MeshVariable\n    The Darcy velocity field.\ns : sympy.Expr\n    Source term for pressure gradients (e.g., :math:`\\rho g`).\nSs : sympy.Expr\n    Specific storage coefficient.\n\nNotes\n-----\n- The unknown is :math:`h`, the hydraulic head\n- The permeability tensor :math:`\\kappa` is set via the ``constitutive_model``\n  property using one of the ``uw.constitutive_models`` classes\n- :math:`W` is a pressure source term\n- :math:`S_s` is the specific storage coefficient\n- The time-dependent term :math:`\\dot{f}` is not implemented in this version\n- The solver returns both the primary field and the Darcy flux (mean-flow velocity)\n\nSee Also\n--------\nSNES_Poisson : Related diffusion-only solver.\nuw.constitutive_models.DarcyFlowModel : Constitutive model for Darcy flow.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 558,
    "signature": "class SNES_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Stokes equation solver for incompressible viscous flow.\n\nThis class provides functionality for a discrete representation\nof the Stokes flow equations assuming an incompressibility\n(or near-incompressibility) constraint.\n\nThe momentum equation is:\n\n.. math::\n\n    -\\nabla \\cdot \\left[ \\boldsymbol{\\tau} - p \\mathbf{I} \\right] = \\mathbf{f}\n\nwith the incompressibility constraint:\n\n.. math::\n\n    \\nabla \\cdot \\mathbf{u} = 0\n\nThe flux term is a deviatoric stress (:math:`\\boldsymbol{\\tau}`) related to velocity\ngradients (:math:`\\nabla \\mathbf{u}`) through a viscosity tensor :math:`\\eta`, and a\nvolumetric (pressure) part :math:`p`:\n\n.. math::\n\n    \\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\nThe constraint equation gives incompressible flow by default but can be set\nto any function of the unknown :math:`\\mathbf{u}` and :math:`\\nabla \\cdot \\mathbf{u}`.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The computational mesh.\nvelocityField : uw.discretisation.MeshVariable, optional\n    Pre-existing velocity field. If None, one is created automatically.\npressureField : uw.discretisation.MeshVariable, optional\n    Pre-existing pressure field. If None, one is created automatically.\ndegree : int, optional\n    Polynomial degree for velocity interpolation. Default is 2.\np_continuous : bool, optional\n    If True (default), pressure is continuous. Set False for discontinuous pressure.\nverbose : bool, optional\n    Enable verbose output during solving. Default is False.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for velocity (used in derived classes).\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for flux (used in viscoelastic models).\n\nAttributes\n----------\nu : MeshVariable\n    The velocity field (accessed via ``solver.Unknowns.u``).\np : MeshVariable\n    The pressure field (accessed via ``solver.Unknowns.p``).\nbodyforce : UWexpression\n    Volumetric body force vector :math:`\\mathbf{f}`.\nconstitutive_model : ConstitutiveModel\n    Viscosity model providing the stress-strain relationship.\npenalty : UWexpression\n    Augmented Lagrangian penalty parameter :math:`\\lambda`.\nsaddle_preconditioner : sympy.Expr\n    Preconditioner for the saddle point system (default: :math:`1/\\eta`).\nconstraints : sympy.Matrix\n    Constraint equation(s), default is :math:`\\nabla \\cdot \\mathbf{u}`.\n\nNotes\n-----\n**Viscosity model**: The viscosity tensor :math:`\\boldsymbol{\\eta}` is provided by\nsetting the ``constitutive_model`` property to one of the ``uw.constitutive_models``\nclasses. It may be constant, spatially varying, non-linear, or anisotropic.\n\n**Augmented Lagrangian**: Setting ``penalty`` to a non-zero value adds\n:math:`\\lambda \\nabla \\cdot \\mathbf{u}` to the weak form, improving convergence\nfor incompressible flow (in addition to the constraint equation).\n\n**Mixed finite elements**: The pressure field interpolation order determines\nthe integration order of the mixed method and is typically lower than the\nvelocity field order.\n\n**Viscoelastic models**: For viscoelastic behaviour, the flux term contains\nstress history tracked on a particle swarm. See :class:`SNES_VE_Stokes`.\n\nSee Also\n--------\nSNES_VE_Stokes : Viscoelastic Stokes solver with flux history.\nSNES_NavierStokes : Navier-Stokes solver with inertial terms.\nuw.constitutive_models : Available viscosity models.\n\nExamples\n--------\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1), cellSize=0.1)\n>>> stokes = uw.systems.Stokes(mesh, degree=2)\n>>> stokes.constitutive_model = uw.constitutive_models.ViscousFlowModel()\n>>> stokes.constitutive_model.Parameters.viscosity = 1.0\n>>> stokes.bodyforce = [0, -1]  # gravity\n>>> stokes.solve()",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_VE_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1119,
    "signature": "class SNES_VE_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoelastic Stokes equation solver.\n\nProvides a discrete representation of the Stokes flow equations with\nincompressibility (or near-incompressibility) constraint and a flux\nhistory term for viscoelastic modelling. Inherits from :class:`SNES_Stokes`.\n\nMomentum equation:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\tau} - p \\mathbf{I}\n    \\right]}_{\\mathbf{F}} = \\underbrace{\\mathbf{f}}_{\\mathbf{h}}\n\nContinuity equation:\n\n.. math::\n\n    \\underbrace{\\nabla \\cdot \\mathbf{u}}_{\\mathbf{h}_p} = 0\n\nThe flux term is a deviatoric stress :math:`\\boldsymbol{\\tau}` related\nto velocity gradients :math:`\\nabla \\mathbf{u}` through a viscosity\ntensor :math:`\\eta`, plus a volumetric (pressure) part :math:`p`:\n\n.. math::\n\n    \\mathbf{F}: \\quad \\boldsymbol{\\tau} = \\frac{\\eta}{2}\n    \\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\nThe constraint equation :math:`\\mathbf{h}_p = 0` is incompressible flow\nby default but can be set to any function of :math:`\\mathbf{u}` and\n:math:`\\nabla \\cdot \\mathbf{u}`.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nvelocityField : MeshVariable, optional\n    Mesh variable for velocity. Created automatically if not provided.\npressureField : MeshVariable, optional\n    Mesh variable for pressure. Created automatically if not provided.\ndegree : int, default=2\n    Polynomial degree for velocity elements.\norder : int, default=2\n    Order parameter (typically same as degree).\np_continuous : bool, default=True\n    If False, use discontinuous pressure elements.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator (may be used in child classes).\n\nAttributes\n----------\nu : MeshVariable\n    Velocity field unknown :math:`\\mathbf{u}`.\np : MeshVariable\n    Pressure field unknown :math:`p`.\nbodyforce : sympy.Expr\n    Body force term :math:`\\mathbf{f}`.\npenalty : float\n    Augmented Lagrangian penalty parameter :math:`\\lambda`.\nsaddle_preconditioner : sympy.Expr\n    Preconditioner for saddle point system (default: :math:`1/\\eta`).\n\nNotes\n-----\n- The viscosity tensor :math:`\\boldsymbol{\\eta}` is set via the\n  ``constitutive_model`` property\n- For viscoelastic problems, the flux term contains stress history\n  tracked on a particle swarm\n- Augmented Lagrangian approach adds :math:`\\lambda \\nabla \\cdot \\mathbf{u}`\n  to penalize incompressibility\n- Pressure element order determines mixed FEM integration order\n\nSee Also\n--------\nSNES_Stokes : Base Stokes solver.\nuw.constitutive_models.ViscoElasticPlasticFlowModel : Constitutive model for VE flow.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1323,
    "signature": "class SNES_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Scalar projection solver for mapping functions to mesh variables.\n\nSolves :math:`u = \\tilde{f}` where :math:`\\tilde{f}` is a function that\ncan be evaluated within an element and :math:`u` is a mesh variable with\nassociated shape functions.\n\nTypically used to obtain a continuous representation of a function not\nwell-defined at mesh nodes (e.g., derivatives or flux components). More\nbroadly, it is a projection from one basis to another.\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla u \\right]}_{\\mathbf{F}}\n    - \\underbrace{\\left[ u - \\tilde{f} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    Target mesh variable for the projection.\nscalar_Field : MeshVariable, optional\n    Alternative name for the target field.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nsolver_name : str, optional\n    Name for the solver instance.\nverbose : bool, default=False\n    Enable verbose output.\n\nAttributes\n----------\nuw_function : sympy.Expr\n    The function :math:`\\tilde{f}` to project.\nsmoothing : float\n    The regularization parameter :math:`\\alpha`.\n\nSee Also\n--------\nSNES_Vector_Projection : Vector field projection.\nSNES_Tensor_Projection : Tensor field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Vector_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1446,
    "signature": "class SNES_Vector_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector projection solver for mapping vector functions to mesh variables.\n\nSolves :math:`\\mathbf{u} = \\tilde{\\mathbf{f}}` where :math:`\\tilde{\\mathbf{f}}`\nis a vector function that can be evaluated within an element and\n:math:`\\mathbf{u}` is a vector mesh variable with associated shape functions.\n\nTypically used to obtain a continuous representation of a vector function\nnot well-defined at mesh nodes (e.g., gradient or flux vectors).\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla \\mathbf{u}\n    \\right]}_{\\mathbf{F}} - \\underbrace{\\left[ \\mathbf{u}\n    - \\tilde{\\mathbf{f}} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    Target vector mesh variable for the projection.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nverbose : bool, default=False\n    Enable verbose output.\n\nAttributes\n----------\nuw_function : sympy.Matrix\n    The vector function :math:`\\tilde{\\mathbf{f}}` to project.\nsmoothing : float\n    The regularization parameter :math:`\\alpha`.\n\nSee Also\n--------\nSNES_Projection : Scalar field projection.\nSNES_Tensor_Projection : Tensor field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Tensor_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1591,
    "signature": "class SNES_Tensor_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Tensor projection solver for mapping tensor functions to mesh variables.\n\nSolves :math:`\\mathbf{u} = \\tilde{\\mathbf{f}}` where :math:`\\tilde{\\mathbf{f}}`\nis a tensor-valued function that can be evaluated within an element and\n:math:`\\mathbf{u}` is a tensor mesh variable with associated shape functions.\n\nTypically used to obtain a continuous representation of a tensor function\nnot well-defined at mesh nodes (e.g., stress or strain tensors).\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla \\mathbf{u}\n    \\right]}_{\\mathbf{F}} - \\underbrace{\\left[ \\mathbf{u}\n    - \\tilde{\\mathbf{f}} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\ntensor_Field : MeshVariable, optional\n    Target tensor mesh variable for the projection.\nscalar_Field : MeshVariable, optional\n    Scalar work variable used internally.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nverbose : bool, default=False\n    Enable verbose output.\n\nNotes\n-----\nCurrently implemented component-wise as there is no native solver\nfor tensor unknowns.\n\nSee Also\n--------\nSNES_Projection : Scalar field projection.\nSNES_Vector_Projection : Vector field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_AdvectionDiffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1739,
    "signature": "class SNES_AdvectionDiffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Advection-diffusion equation solver using semi-Lagrangian Crank-Nicolson.\n\nImplements the characteristics-based method described in Spiegelman & Katz (2006):\n\n.. math::\n\n    \\underbrace{\\frac{\\partial u}{\\partial t} + \\left( \\mathbf{v} \\cdot \\nabla\n    \\right) u}_{\\dot{u}} - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa}\n    \\nabla u \\right]}_{\\mathbf{F}} = \\underbrace{f}_{\\mathbf{h}}\n\nThe flux term :math:`\\mathbf{F}` relates diffusive fluxes to gradients in\n:math:`u`. Advective fluxes along the velocity field :math:`\\mathbf{v}` are\nhandled in the :math:`\\dot{u}` term.\n\nThe time derivative :math:`\\dot{u}` involves upstream sampling to find\n:math:`u^*`, the value of :math:`u` at points which later arrive at mesh\nnodes. This is achieved using a hidden swarm variable advected backwards\nfrom nodal points automatically during solve.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable\n    Mesh variable for the transported scalar.\nV_fn : MeshVariable or sympy.Basic\n    Velocity field for advection.\norder : int, default=1\n    Time integration order (1 or 2).\nrestore_points_func : callable, optional\n    Function to restore particles to valid domain.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for the unknown.\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nu : MeshVariable\n    The scalar unknown.\nf : sympy.Expr\n    Volumetric source term.\n\nNotes\n-----\n- The diffusivity :math:`\\kappa` is set via the ``constitutive_model`` property\n- Sources :math:`f` can be any sympy expression involving mesh/swarm variables\n\nReferences\n----------\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson\nalgorithm for the numerical solution of advection-diffusion problems.\n*Geochemistry, Geophysics, Geosystems*, 7(4).\nhttps://doi.org/10.1029/2005GC001073\n\nSee Also\n--------\nSNES_Diffusion : Pure diffusion solver without advection.\nSNES_Navier_Stokes : Full momentum advection-diffusion.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Diffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2255,
    "signature": "class SNES_Diffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusion equation solver using mesh-based finite elements.\n\nSolves the scalar diffusion equation:\n\n.. math::\n\n    \\underbrace{\\frac{\\partial u}{\\partial t}}_{\\dot{f}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa} \\nabla u\n    \\right]}_{\\mathbf{F}} = \\underbrace{f}_{h}\n\nThe flux term :math:`\\mathbf{F}` relates diffusive fluxes to gradients\nin the unknown :math:`u`.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable\n    Mesh variable for the diffusing scalar.\norder : int, default=1\n    Time integration order.\ntheta : float, default=0.0\n    Time integration parameter (0=explicit, 0.5=Crank-Nicolson, 1=implicit).\nevalf : bool, default=False\n    Numerically evaluate symbolic expressions during setup.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : Eulerian_DDt, SemiLagrangian_DDt, or Lagrangian_DDt, optional\n    Time derivative operator for the unknown.\nDFDt : Eulerian_DDt, SemiLagrangian_DDt, or Lagrangian_DDt, optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nu : MeshVariable\n    The scalar unknown.\nf : sympy.Expr\n    Volumetric source term.\n\nNotes\n-----\n- The diffusivity :math:`\\kappa` is set via the ``constitutive_model`` property\n- Sources :math:`f` can be any sympy expression involving mesh/swarm variables\n\nSee Also\n--------\nSNES_AdvectionDiffusion : Adds advection transport.\nSNES_Poisson : Steady-state diffusion (no time derivative).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_NavierStokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2635,
    "signature": "class SNES_NavierStokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Navier-Stokes equation solver with momentum advection.\n\nProvides a solver for the Navier-Stokes (vector advection-diffusion) equation\nsimilar to the Semi-Lagrange Crank-Nicolson method (Spiegelman & Katz, 2006)\nbut using distributed upstream sampling from a swarm variable.\n\n.. math::\n\n    \\underbrace{\\frac{\\partial \\mathbf{u}}{\\partial t}\n    + \\left( \\mathbf{u} \\cdot \\nabla \\right) \\mathbf{u}}_{\\dot{\\mathbf{u}}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\frac{\\boldsymbol{\\eta}}{2}\n    \\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n    - p \\mathbf{I} \\right]}_{\\mathbf{F}} = \\underbrace{\\mathbf{f}}_{\\mathbf{h}}\n\nThe flux term :math:`\\mathbf{F}` relates viscous stresses to velocity gradients.\nAdvective momentum transport is handled in the :math:`\\dot{\\mathbf{u}}` term.\n\nThe time derivative :math:`\\dot{\\mathbf{u}}` involves upstream sampling to find\n:math:`\\mathbf{u}^*`, representing velocity at the start of the timestep. This is\nachieved using a swarm variable that carries history information along flow paths.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nvelocityField : MeshVariable\n    Mesh variable for velocity.\npressureField : MeshVariable\n    Mesh variable for pressure.\nrho : float or sympy.Expr\n    Fluid density.\norder : int, default=1\n    Time integration order.\ntheta : float, default=0.5\n    Time integration parameter.\np_continuous : bool, default=True\n    If False, use discontinuous pressure elements.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for velocity.\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for stress.\n\nAttributes\n----------\nu : MeshVariable\n    Velocity field unknown.\np : MeshVariable\n    Pressure field unknown.\nrho : sympy.Expr\n    Fluid density.\nbodyforce : sympy.Expr\n    Body force term :math:`\\mathbf{f}`.\n\nNotes\n-----\n- The viscosity :math:`\\eta` is set via the ``constitutive_model`` property\n- High-order shape functions (cubic or higher) are recommended for accurate\n  history term interpolation\n- The user must supply and update the swarm variable representing :math:`\\mathbf{u}^*`\n\nReferences\n----------\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson\nalgorithm for the numerical solution of advection-diffusion problems.\n*Geochemistry, Geophysics, Geosystems*, 7(4).\nhttps://doi.org/10.1029/2005GC001073\n\nSee Also\n--------\nSNES_Stokes : Steady-state Stokes flow (no inertia).\nSNES_AdvectionDiffusion : Scalar advection-diffusion.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "KDTree",
    "kind": "class",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 17,
    "signature": "cdef class KDTree:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Integral",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 16,
    "signature": "class Integral:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CellWiseIntegral",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 208,
    "signature": "class CellWiseIntegral:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "PtrContainer",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_types.pyx",
    "line": 1,
    "signature": "cdef class PtrContainer:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CachedDMInterpolationInfo",
    "kind": "class",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 39,
    "signature": "cdef class CachedDMInterpolationInfo:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UnderworldAppliedFunction",
    "kind": "class",
    "file": "src/underworld3/function/_function.pyx",
    "line": 50,
    "signature": "class UnderworldAppliedFunction(sympy.core.function.AppliedUndef):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UnderworldAppliedFunctionDeriv",
    "kind": "class",
    "file": "src/underworld3/function/_function.pyx",
    "line": 84,
    "signature": "class UnderworldAppliedFunctionDeriv(UnderworldAppliedFunction):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UnderworldFunction",
    "kind": "class",
    "file": "src/underworld3/function/_function.pyx",
    "line": 92,
    "signature": "class UnderworldFunction(sympy.Function):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "sympy_function_printable",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 18,
    "signature": "class sympy_function_printable(sympy.Function):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_base",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 40,
    "signature": "class AnalyticSolNL_base(sympy_function_printable):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_velocity_x",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 44,
    "signature": "class AnalyticSolNL_velocity_x(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_velocity_y",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 50,
    "signature": "class AnalyticSolNL_velocity_y(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_velocity",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 55,
    "signature": "class AnalyticSolNL_velocity(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_bodyforce_x",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 62,
    "signature": "class AnalyticSolNL_bodyforce_x(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_bodyforce_y",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 68,
    "signature": "class AnalyticSolNL_bodyforce_y(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_bodyforce",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 73,
    "signature": "class AnalyticSolNL_bodyforce(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnalyticSolNL_viscosity",
    "kind": "class",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 80,
    "signature": "class AnalyticSolNL_viscosity(AnalyticSolNL_base):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "VarType",
    "kind": "class",
    "file": "src/underworld3/_var_types.py",
    "line": 21,
    "signature": "class VarType",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable type specification for mesh and swarm fields.\n\nThis enum specifies the tensor rank and symmetry properties of field\nvariables, which determines storage layout and number of components.\n\nAttributes\n----------\nSCALAR : int\n    Scalar field (1 component).\nVECTOR : int\n    Vector field (dim components).\nMATRIX : int\n    General matrix field (dim \u00d7 dim components).\nTENSOR : int\n    Full rank-2 tensor (dim \u00d7 dim), alias for MATRIX.\nSYM_TENSOR : int\n    Symmetric rank-2 tensor (6 components in 3D, 3 in 2D).\nOTHER : int\n    Custom type marker.\n\nExamples\n--------\n>>> temperature = mesh.add_variable(\"T\", vtype=uw.VarType.SCALAR)\n>>> velocity = mesh.add_variable(\"V\", vtype=uw.VarType.VECTOR)\n>>> stress = mesh.add_variable(\"tau\", vtype=uw.VarType.SYM_TENSOR)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Constitutive_Model",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 122,
    "signature": "class Constitutive_Model",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Base class for constitutive laws relating gradients to fluxes.\n\nConstitutive laws relate gradients in the unknowns to fluxes of quantities\n(for example, heat fluxes are related to temperature gradients through a\nthermal conductivity). This class is a base class for building Underworld\nconstitutive laws.\n\nIn a scalar problem, the relationship is:\n\n.. math::\n\n    q_i = k_{ij} \\frac{\\partial T}{\\partial x_j}\n\nand the constitutive parameters describe :math:`k_{ij}`. The template\nassumes :math:`k_{ij} = \\delta_{ij}`.\n\nIn a vector problem (such as the Stokes problem), the relationship is:\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{\\partial u_k}{\\partial x_l}\n\nbut is usually written to eliminate the anti-symmetric part of the\ndisplacement or velocity gradients:\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nand the constitutive parameters describe :math:`c_{ijkl}`. The template\nassumes :math:`k_{ij} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})`\nwhich is the 4th rank identity tensor accounting for symmetry in the flux\nand the gradient terms.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscousFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 494,
    "signature": "class ViscousFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscous flow constitutive model for Stokes-type solvers.\n\nDefines the relationship between deviatoric stress and strain rate:\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity, which can be a scalar constant, SymPy\nfunction, Underworld mesh variable, or any valid combination. This results\nin an isotropic (but not necessarily homogeneous or linear) relationship\nbetween :math:`\\tau` and the velocity gradients.\n\nParameters\n----------\nunknowns : Unknowns\n    The solver unknowns (typically velocity and pressure fields).\nmaterial_name : str, optional\n    Name identifier for this material (used in multi-material setups).\n\nAttributes\n----------\nParameters : _Parameters\n    Material parameters container. Set ``Parameters.shear_viscosity_0``\n    to define the viscosity.\nflux : sympy.Matrix\n    The computed deviatoric stress tensor :math:`\\boldsymbol{\\tau}`.\nC : sympy.Matrix\n    Mandel form of the constitutive tensor :math:`\\eta_{IJ}`.\nc : sympy.Array\n    Rank-4 tensor form :math:`\\eta_{ijkl}`.\n\nExamples\n--------\n>>> import underworld3 as uw\n>>> stokes = uw.systems.Stokes(mesh)\n>>> viscous = uw.constitutive_models.ViscousFlowModel(stokes.Unknowns)\n>>> viscous.Parameters.shear_viscosity_0 = 1e21  # Pa.s\n>>> stokes.constitutive_model = viscous\n\nSee Also\n--------\nViscoPlasticFlowModel : Adds yield stress for plastic behavior.\nViscoElasticPlasticFlowModel : Adds viscoelastic memory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 725,
    "signature": "class ViscoPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoplastic flow constitutive model with yield stress.\n\nExtends :class:`ViscousFlowModel` with a yield stress that limits the\nmaximum deviatoric stress. When stress would exceed the yield stress,\nthe effective viscosity is reduced to cap the stress.\n\n.. math::\n\n    \\tau_{ij} = \\eta_\\mathrm{eff} \\cdot \\dot{\\varepsilon}_{ij}\n\nwhere the effective viscosity is:\n\n.. math::\n\n    \\eta_\\mathrm{eff} = \\min\\left(\\eta_0, \\frac{\\tau_y}{2\\dot{\\varepsilon}_{II}}\\right)\n\nand :math:`\\tau_y` is the yield stress and :math:`\\dot{\\varepsilon}_{II}`\nis the second invariant of the strain rate.\n\nParameters\n----------\nunknowns : Unknowns\n    The solver unknowns (typically velocity and pressure fields).\nmaterial_name : str, optional\n    Name identifier for this material.\n\nAttributes\n----------\nParameters : _Parameters\n    Material parameters including:\n\n    - ``shear_viscosity_0``: Background viscosity :math:`\\eta_0`\n    - ``yield_stress``: Yield stress :math:`\\tau_y`\n\nviscosity : UWexpression\n    The effective (possibly yielded) viscosity.\n\nNotes\n-----\nIf yield stress is not defined, this model behaves identically to\n:class:`ViscousFlowModel`. The message ``not~yet~defined`` in the\neffective viscosity indicates missing parameters.\n\nSee Also\n--------\nViscousFlowModel : Base viscous model without yielding.\nViscoElasticPlasticFlowModel : Adds viscoelastic memory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoElasticPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 945,
    "signature": "class ViscoElasticPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoelastic-plastic flow constitutive model.\n\nThe stress (flux term) is given by:\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination. This results in an\nisotropic (but not necessarily homogeneous or linear) relationship between\n:math:`\\tau` and the velocity gradients. You can also supply :math:`\\eta_{IJ}`,\nthe Mandel form of the constitutive tensor, or :math:`\\eta_{ijkl}`, the rank-4 tensor.\n\nThe Mandel constitutive matrix is available in `viscous_model.C` and the rank 4 tensor form is\nin `viscous_model.c`.  Apply the constitutive model using:",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DiffusionModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1537,
    "signature": "class DiffusionModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusion (Fourier/Fick) constitutive model for scalar transport.\n\nDefines the flux-gradient relationship for scalar diffusion:\n\n.. math::\n\n    q_{i} = \\kappa_{ij} \\frac{\\partial \\phi}{\\partial x_j}\n\nFor isotropic diffusion, :math:`\\kappa_{ij} = \\kappa \\delta_{ij}`.\n\nParameters\n----------\nunknowns : Unknowns\n    The solver unknowns (the scalar field being diffused).\nmaterial_name : str, optional\n    Name identifier for this material.\n\nAttributes\n----------\nParameters : _Parameters\n    Material parameters container. Set ``Parameters.diffusivity``\n    to define :math:`\\kappa`.\nflux : sympy.Matrix\n    The computed diffusive flux vector.\ndiffusivity : UWexpression\n    Shortcut to ``Parameters.diffusivity``.\nK : UWexpression\n    Alias for ``diffusivity``.\n\nExamples\n--------\n>>> diffusion = uw.constitutive_models.DiffusionModel(poisson.Unknowns)\n>>> diffusion.Parameters.diffusivity = 1e-6  # m^2/s\n>>> poisson.constitutive_model = diffusion\n\nSee Also\n--------\nAnisotropicDiffusionModel : For direction-dependent diffusivity.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnisotropicDiffusionModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1659,
    "signature": "class AnisotropicDiffusionModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Anisotropic diffusion with direction-dependent diffusivities.\n\nDefines a diagonal diffusivity tensor :math:`\\kappa_{ij} = \\text{diag}(\\kappa_0, \\kappa_1, ...)`\nfor direction-dependent diffusion rates.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "GenericFluxModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1727,
    "signature": "class GenericFluxModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A generic constitutive model with symbolic flux expression.\n\nExample usage:\n```python\ngrad_phi = sympy.Matrix([sp.Symbol(\"\u2202\u03c6/\u2202x\"), sp.Symbol(\"\u2202\u03c6/\u2202y\")])\nflux_expr = sympy.Matrix([[kappa_11, kappa_12], [kappa_21, kappa_22]]) * grad_phi\n\nmodel = GenericFluxModel(dim=2)\nmodel.flux = flux_expr\nscalar_solver.constititutive_model = model\n```",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DarcyFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1804,
    "signature": "class DarcyFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Darcy flow constitutive model for porous media flow.\n\nRelates the Darcy flux to pressure gradients and body forces:\n\n.. math::\n\n    q_{i} = \\kappa_{ij} \\left( \\frac{\\partial p}{\\partial x_j} - s_j \\right)\n\nwhere :math:`\\kappa` is the permeability (or hydraulic conductivity),\n:math:`p` is the pressure (or hydraulic head), and :math:`s` is the\nbody force term (e.g., gravity: :math:`s = \\rho g`).\n\nParameters\n----------\nunknowns : Unknowns\n    The solver unknowns (the pressure/head field).\nmaterial_name : str, optional\n    Name identifier for this material.\n\nAttributes\n----------\nParameters : _Parameters\n    Material parameters container:\n\n    - ``permeability``: Intrinsic permeability :math:`\\kappa` [m\u00b2]\n    - ``s``: Body force vector (e.g., gravity term)\n\nflux : sympy.Matrix\n    The computed Darcy flux vector.\npermeability : UWexpression\n    Shortcut to ``Parameters.permeability``.\n\nExamples\n--------\n>>> darcy = uw.constitutive_models.DarcyFlowModel(solver.Unknowns)\n>>> darcy.Parameters.permeability = 1e-12  # m^2\n>>> darcy.Parameters.s = [0, -rho * g]  # Gravity in y-direction\n>>> solver.constitutive_model = darcy\n\nSee Also\n--------\nDiffusionModel : For pure diffusion without body forces.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "TransverseIsotropicFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1958,
    "signature": "class TransverseIsotropicFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Transversely isotropic (anisotropic) viscous flow model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity tensor defined as:\n\n.. math::\n\n    \\eta_{ijkl} = \\eta_0 \\cdot I_{ijkl} + (\\eta_0-\\eta_1) \\left[ \\frac{1}{2} \\left[\n    n_i n_l \\delta_{jk} + n_j n_k \\delta_{il} + n_i n_l \\delta_{jk}\n    + n_j n_l \\delta_{ik} \\right] - 2 n_i n_j n_k n_l \\right]\n\nand :math:`\\hat{\\mathbf{n}} \\equiv \\{n_i\\}` is the unit vector defining\nthe local orientation of the weak plane (a.k.a. the director).\n\nThe Mandel constitutive matrix is available in ``viscous_model.C`` and the\nrank-4 tensor form is in ``viscous_model.c``.\n\nExamples\n--------\n>>> viscous_model = TransverseIsotropicFlowModel(dim)\n>>> viscous_model.material_properties = viscous_model.Parameters(\n...     eta_0=viscosity_fn,\n...     eta_1=weak_viscosity_fn,\n...     director=orientation_vector_fn\n... )\n>>> solver.constitutive_model = viscous_model\n>>> tau = viscous_model.flux(gradient_matrix)\n---",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MultiMaterialConstitutiveModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2158,
    "signature": "class MultiMaterialConstitutiveModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Multi-material constitutive model using level-set weighted flux averaging.\n\nMathematical Foundation:\n\n.. math::\n\n    \\mathbf{f}_{\\text{composite}}(\\mathbf{x}) = \\sum_{i=1}^{N}\n    \\phi_i(\\mathbf{x}) \\cdot \\mathbf{f}_i(\\mathbf{x})\n\nCritical Architecture:\n\n- Solver owns Unknowns (including :math:`D\\mathbf{F}/Dt` stress history)\n- All constituent models share solver's Unknowns\n- Composite flux becomes stress history for all materials",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Constitutive_Model",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 31,
    "signature": "class Constitutive_Model",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Base class for constitutive models.\n\nConstitutive laws relate gradients in the unknowns to fluxes of quantities\n(e.g., heat fluxes related to temperature gradients via thermal conductivity).\n\nFor scalar problems:\n\n.. math::\n\n    q_i = k_{ij} \\frac{\\partial T}{\\partial x_j}\n\nwhere :math:`k_{ij}` are the constitutive parameters. The template assumes\n:math:`k_{ij} = \\delta_{ij}` (identity).\n\nFor vector problems (e.g., Stokes):\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{\\partial u_k}{\\partial x_l}\n\nUsually written with symmetrized gradients:\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`c_{ijkl}` are the constitutive parameters. The template assumes\n:math:`c_{ijkl} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})`,\nthe 4th-rank identity tensor with flux and gradient symmetry.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscousFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 259,
    "signature": "class ViscousFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscous flow constitutive model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity\u2014a scalar constant, sympy function,\nor mesh variable. This gives an isotropic (but not necessarily homogeneous\nor linear) relationship between :math:`\\tau` and velocity gradients. You can\nalso supply :math:`\\eta_{IJ}` (Mandel form) or :math:`\\eta_{ijkl}` (rank-4 tensor).\n\nThe Mandel constitutive matrix is in ``viscous_model.C`` and the rank-4\ntensor form is in ``viscous_model.c``.\n\nExamples\n--------\n>>> viscous_model = ViscousFlowModel(dim)\n>>> viscous_model.material_properties = viscous_model.Parameters(viscosity=viscosity_fn)\n>>> solver.constitutive_model = viscous_model\n>>> tau = viscous_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 344,
    "signature": "class ViscoPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoplastic flow constitutive model with yield stress.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity\u2014a scalar constant, sympy function,\nor mesh variable. This gives an isotropic relationship between :math:`\\tau`\nand velocity gradients. You can also supply :math:`\\eta_{IJ}` (Mandel form)\nor :math:`\\eta_{ijkl}` (rank-4 tensor).\n\nIn a viscoplastic model, the viscosity is defined to cap the overall stress\nat the *yield stress*. This assumes the yield stress is a scalar limit on\nthe 2nd invariant of the stress. Anisotropic models require careful yield\nsurface definition\u2014only a subset of cases is available.\n\nThe Mandel matrix is in ``viscoplastic_model.C`` and the rank-4 tensor in\n``viscoplastic_model.c``.\n\nNotes\n-----\nIf ``not~yet~defined`` appears in the effective viscosity, not all required\nfunctions have been set. The model defaults to standard viscous behavior\nif yield terms are not specified.\n\nExamples\n--------\n>>> viscoplastic_model = ViscoPlasticFlowModel(dim)\n>>> viscoplastic_model.material_properties = viscoplastic_model.Parameters(\n...     viscosity=viscosity_fn,\n...     yield_stress=yieldstress_fn,\n...     min_viscosity=min_viscosity_fn,\n...     max_viscosity=max_viscosity_fn,\n...     strain_rate_II=strain_rate_inv_fn\n... )\n>>> solver.constitutive_model = viscoplastic_model\n>>> tau = viscoplastic_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoElasticPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 786,
    "signature": "class ViscoElasticPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoelastic-plastic flow constitutive model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity\u2014a scalar constant, sympy function,\nor mesh variable. This gives an isotropic relationship between :math:`\\tau`\nand velocity gradients. You can also supply :math:`\\eta_{IJ}` (Mandel form)\nor :math:`\\eta_{ijkl}` (rank-4 tensor).\n\nThe Mandel matrix is in ``viscoelastic_model.C`` and the rank-4 tensor in\n``viscoelastic_model.c``.\n\nExamples\n--------\n>>> viscoelastic_model = ViscoElasticFlowModel(dim)\n>>> viscoelastic_model.material_properties = viscoelastic_model.Parameters(\n...     viscosity=viscosity_fn\n... )\n>>> solver.constitutive_model = viscoelastic_model\n>>> tau = viscoelastic_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DiffusionModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1468,
    "signature": "class DiffusionModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusion constitutive model for scalar transport.\n\n.. math::\n\n    q_{i} = \\kappa_{ij} \\cdot \\frac{\\partial \\phi}{\\partial x_j}\n\nwhere :math:`\\kappa` is a diffusivity\u2014a scalar constant, sympy function,\nor mesh variable.\n\nExamples\n--------\n>>> diffusion_model = DiffusionModel(dim)\n>>> diffusion_model.material_properties = diffusion_model.Parameters(\n...     diffusivity=diffusivity_fn\n... )\n>>> scalar_solver.constitutive_model = diffusion_model\n>>> flux = diffusion_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "TransverseIsotropicFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1538,
    "signature": "class TransverseIsotropicFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Transversely isotropic viscous flow model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere the viscosity tensor :math:`\\eta` is defined as:\n\n.. math::\n\n    \\eta_{ijkl} = \\eta_0 I_{ijkl} + (\\eta_0 - \\eta_1) \\left[\n    \\frac{1}{2}\\left( n_i n_l \\delta_{jk} + n_j n_k \\delta_{il}\n    + n_i n_l \\delta_{jk} + n_j n_l \\delta_{ik} \\right)\n    - 2 n_i n_j n_k n_l \\right]\n\nand :math:`\\hat{\\mathbf{n}} \\equiv \\{n_i\\}` is the unit vector defining the\nlocal orientation of the weak plane (the director).\n\nThe Mandel matrix is in ``viscous_model.C`` and the rank-4 tensor in\n``viscous_model.c``.\n\nExamples\n--------\n>>> viscous_model = TransverseIsotropicFlowModel(dim)\n>>> viscous_model.material_properties = viscous_model.Parameters(\n...     eta_0=viscosity_fn,\n...     eta_1=weak_viscosity_fn,\n...     director=orientation_vector_fn\n... )\n>>> solver.constitutive_model = viscous_model\n>>> tau = viscous_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MultiMaterial",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1686,
    "signature": "class MultiMaterial",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Manage multiple materials in a constitutive framework.\n\nBundles multiple materials into a single consitutive law. The expectation\nis that these all have compatible flux terms.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UWCoordinate",
    "kind": "class",
    "file": "src/underworld3/coordinates.py",
    "line": 51,
    "signature": "class UWCoordinate",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A Cartesian coordinate variable (x, y, or z).\n\nThis class represents a mesh coordinate that:\n- Subclasses BaseScalar for full SymPy differentiation compatibility\n- Is recognizable by type (isinstance check) for unwrap/evaluate logic\n- Parallels MeshVariable pattern: .sym for symbolic, .data for numeric\n- Works transparently with sympy.diff() for expressions containing N.x, N.y, N.z\n\nThe key insight is that by subclassing BaseScalar and implementing __eq__/__hash__\nto match the original N.x/N.y/N.z objects, SymPy's differentiation machinery\nrecognizes UWCoordinate as equivalent to the original BaseScalar.\n\nParameters\n----------\nindex : int\n    Index in the coordinate system (0, 1, or 2)\nsystem : CoordSys3D\n    The SymPy coordinate system (mesh.N)\nmesh : Mesh, optional\n    Parent mesh object\naxis_index : int, optional\n    Axis index (0=x, 1=y, 2=z) - same as index but kept for API consistency\n\nExamples\n--------\n>>> x, y = mesh.X  # UWCoordinate objects\n>>> x.sym          # Returns self (UWCoordinate IS a BaseScalar)\n>>> x.data         # numpy array of x-coordinates\n>>> r = sympy.sqrt(x**2 + y**2)  # Works in expressions\n>>> sympy.diff(v.sym[0], y)      # Works correctly! (key improvement)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CoordinateSystemType",
    "kind": "class",
    "file": "src/underworld3/coordinates.py",
    "line": 299,
    "signature": "class CoordinateSystemType",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate system types for mesh geometry.\n\nMeshes can have natural coordinate systems that overlay the Cartesian\ncoordinate system used internally for solver assembly. The coordinate\nsystem type determines how vector calculus operators (gradient, divergence,\ncurl) are computed.\n\nAttributes\n----------\nCARTESIAN : int\n    Standard Cartesian coordinates (x, y, z).\nCYLINDRICAL2D : int\n    2D cylindrical/polar coordinates (r, theta).\nPOLAR : int\n    Alias for CYLINDRICAL2D.\nCYLINDRICAL3D : int\n    3D cylindrical coordinates (r, theta, z).\nSPHERICAL : int\n    Spherical coordinates (r, theta, phi).\nGEOGRAPHIC : int\n    Ellipsoidal geographic coordinates (lon, lat, depth) for\n    Earth and planetary modeling.\n\nSee Also\n--------\nunderworld3.maths.vector_calculus : Operators for each coordinate system.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "GeographicCoordinateAccessor",
    "kind": "class",
    "file": "src/underworld3/coordinates.py",
    "line": 491,
    "signature": "class GeographicCoordinateAccessor",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Geographic coordinates on ellipsoidal (WGS84) meshes.\n\nThis class provides natural coordinate access for geographic meshes,\nincluding longitude, latitude, and depth data arrays, symbolic coordinates\nfor equations (:math:`\\lambda_{lon}`, :math:`\\lambda_{lat}`, :math:`\\lambda_d`),\nand ellipsoidal basis vectors.\n\nAccess via ``mesh.X.geo`` on GEOGRAPHIC meshes. Use ``.view()`` for a\ncomplete summary of available properties and methods.\n\nAttributes\n----------\nlon : ndarray\n    Longitude in degrees East (-180 to 180)\nlat : ndarray\n    Geodetic latitude in degrees North (-90 to 90)\ndepth : ndarray\n    Depth below ellipsoid surface in km (positive downward)\ncoords : ndarray\n    Combined (N, 3) array: [lon, lat, depth]\n\nExamples\n--------\n>>> geo = mesh.X.geo\n>>> geo.view()               # Show all available properties\n>>> geo.coords               # (N, 3) array of [lon, lat, depth]\n>>> lon, lat, d = geo[:]     # Symbolic coordinates for equations\n>>> geo.unit_down            # Geodetic normal (into planet)\n\nNotes\n-----\nThe 'up' direction is the geodetic normal\u2014perpendicular to the ellipsoid\nsurface\u2014NOT the radial direction. At mid-latitudes, these differ by\napproximately 10-11 arcminutes, which matters for regional models.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SphericalCoordinateAccessor",
    "kind": "class",
    "file": "src/underworld3/coordinates.py",
    "line": 945,
    "signature": "class SphericalCoordinateAccessor",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Spherical/polar coordinates for spherical and cylindrical meshes.\n\nThis class provides natural coordinate access for spherical (3D) and\npolar/cylindrical (2D) meshes, including radius, angle data arrays,\nsymbolic coordinates for equations, and basis vectors.\n\nAccess via ``mesh.X.spherical`` on SPHERICAL or CYLINDRICAL2D meshes.\nUse ``.view()`` for a complete summary of available properties and methods.\n\nAttributes\n----------\nr : ndarray\n    Radial distance from origin\ntheta : ndarray\n    Angle in radians:\n    - 3D: Colatitude (0 at north pole, \u03c0 at south pole)\n    - 2D: Polar angle from x-axis (standard \u03b8)\nphi : ndarray (3D only)\n    Longitude/azimuth in radians (-\u03c0 to \u03c0). Not available for 2D meshes.\ncoords : ndarray\n    Combined array: [r, \u03b8, \u03c6] for 3D, [r, \u03b8] for 2D\n\nExamples\n--------\n>>> sph = mesh.X.spherical\n>>> sph.view()               # Show all available properties\n>>> sph.coords               # (N, 3) or (N, 2) coordinate array\n>>> r, theta = sph[:2]       # Works for both 2D and 3D\n>>> sph.unit_r               # Radial unit vector (outward)\n\nNotes\n-----\nThe coordinate convention follows physics conventions:\n\n- :math:`r`: Radial distance from origin\n- :math:`\\theta`: Angle (colatitude in 3D, polar angle in 2D)\n- :math:`\\phi`: Longitude/azimuth (3D only)\n\nFor Earth-like applications with geodetic (ellipsoidal) geometry,\nuse a GEOGRAPHIC mesh with ``mesh.X.geo`` instead.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CoordinateSystem",
    "kind": "class",
    "file": "src/underworld3/coordinates.py",
    "line": 1353,
    "signature": "class CoordinateSystem",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This class is attached to a mesh to provide programmatic access to coordinate system operations.\n\n`CoordinateSystem.R` - the coordinates in the natural reference (sympy symbols)\n`CoordinateSystem.xR` - the coordinates in the natural reference (sympy symbols in terms of mesh.X)\n`CoordinateSystem._Rot` - the matrix to rotate from X to R, written symbolically\n`CoordinateSystem._xRot` - the matrix to rotate from X to R, written in terms of mesh.X\n\nNeed these:\n\n  Coordinates N -> Native, xi_1, xi_2 by default, but over-written with meaningful symbols if possible\n  Coordinates R -> Natural XYZ or R Theta Phi or R Theta z\n  Coordinates X -> Cartesian XYZ\n\n  nRotr - Matrix to map N to R\n  rRotn - nRotr.T\n  nRotx - Matrix to map N to X\n  xRotn - nRotx.T\n  xRotr = xRotn * nRotr\n  rRotx = rRotn * nRotx\n\n  Either R or X will be an alias for N depending on whether the DM is Cartesian  (Alias has the same vectors but different names)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "u",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 74,
    "signature": "def u(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "u",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 78,
    "signature": "def u(inner_self, new_u):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 95,
    "signature": "def DuDt(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 99,
    "signature": "def DuDt(inner_self, new_DuDt):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 105,
    "signature": "def DFDt(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 109,
    "signature": "def DFDt(inner_self, new_DFDt):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "E",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 115,
    "signature": "def E(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "L",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 119,
    "signature": "def L(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "W",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 123,
    "signature": "def W(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Einv2",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 127,
    "signature": "def Einv2(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CoordinateSystem",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 131,
    "signature": "def CoordinateSystem(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_snes_diagnostics",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 165,
    "signature": "def get_snes_diagnostics(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "check_snes_convergence",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 248,
    "signature": "def check_snes_convergence(self, raise_on_divergence=True, print_diagnostics=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "solve_with_diagnostics",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 313,
    "signature": "def solve_with_diagnostics(self,\n                              check_convergence=True,\n                              raise_on_divergence=False,\n                              print_diagnostics=False,\n                              **solve_kwargs):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 598,
    "signature": "def F0(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 602,
    "signature": "def F1(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "u",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 606,
    "signature": "def u(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "u",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 610,
    "signature": "def u(self, new_u):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 615,
    "signature": "def DuDt(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 619,
    "signature": "def DuDt(self, new_du):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 624,
    "signature": "def DFDt(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 628,
    "signature": "def DFDt(self, new_dF):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "constitutive_model",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 634,
    "signature": "def constitutive_model(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "constitutive_model",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 638,
    "signature": "def constitutive_model(self, model_or_class):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate_solver",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 668,
    "signature": "def validate_solver(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_dof_partition",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 687,
    "signature": "def get_dof_partition(self,\n                          section_type: str,\n                          filename: Optional[str | None] = None,\n                          outputPath: Optional[str] = \"\"):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 908,
    "signature": "def tolerance(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 912,
    "signature": "def tolerance(self, value):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1264,
    "signature": "def solve(self,\n              zero_init_guess: bool =True,\n              _force_setup:    bool =False,\n              verbose:         bool=False,\n              debug:           bool=False,\n              debug_name:      str=None ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1513,
    "signature": "def tolerance(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1516,
    "signature": "def tolerance(self, value):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1931,
    "signature": "def solve(self,\n              zero_init_guess: bool =True,\n              _force_setup:    bool =False,\n              verbose=False,\n              debug=False,\n              debug_name=None,\n               ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "p",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2138,
    "signature": "def p(inner_self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "p",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2142,
    "signature": "def p(inner_self, new_p):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2335,
    "signature": "def tolerance(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tolerance",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2339,
    "signature": "def tolerance(self, value):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "strategy",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2351,
    "signature": "def strategy(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "strategy",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2355,
    "signature": "def strategy(self, value):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "PF0",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2417,
    "signature": "def PF0(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "PF0",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2421,
    "signature": "def PF0(self, value):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "p",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2427,
    "signature": "def p(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "p",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2431,
    "signature": "def p(self, new_p):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2436,
    "signature": "def saddle_preconditioner(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2440,
    "signature": "def saddle_preconditioner(self, function):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate_solver",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2500,
    "signature": "def validate_solver(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_dof_partition",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2522,
    "signature": "def get_dof_partition(self,\n                          section_type: str,\n                          filename: Optional[str | None] = None,\n                          outputPath: Optional[str] = \"\"):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 3092,
    "signature": "def solve(self,\n              zero_init_guess: bool = True,\n              picard: int = 0,\n              verbose=False,\n              debug=False,\n              debug_name=None,\n              _force_setup: bool =False, ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Mesh",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 149,
    "signature": "class Mesh",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unstructured mesh with PETSc DMPlex backend.\n\nThe Mesh class provides the spatial discretisation for finite element\ncomputations. It wraps PETSc's DMPlex for unstructured mesh management,\nsupporting various cell types (triangles, quadrilaterals, tetrahedra,\nhexahedra) and coordinate systems.\n\nParameters\n----------\nplex_or_meshfile : PETSc.DMPlex or str\n    Either a PETSc DMPlex object or path to a mesh file (gmsh, exodus).\ndegree : int, optional\n    Polynomial degree for the coordinate field (default 1).\nsimplex : bool, optional\n    True for simplicial elements (triangles/tets), False for quads/hexes.\ncoordinate_system_type : CoordinateSystemType, optional\n    Coordinate system for vector calculus (Cartesian, cylindrical, etc.).\nqdegree : int, optional\n    Quadrature degree for numerical integration (default 2).\nboundaries : list of NamedTuple, optional\n    Boundary region definitions with names and values.\nboundary_normals : dict, optional\n    Outward normal vectors for each boundary.\nunits : str or pint.Unit, optional\n    Physical units for mesh coordinates.\nverbose : bool, optional\n    Print mesh construction information.\n\nAttributes\n----------\nN : sympy.vector.CoordSys3D\n    SymPy coordinate system for symbolic expressions.\nX : UWCoordinate tuple\n    Coordinate variables (x, y, z) for use in expressions.\ndim : int\n    Spatial dimension of the mesh.\ndm : PETSc.DMPlex\n    Underlying PETSc distributed mesh object.\n\nExamples\n--------\nMeshes are typically created via the meshing module::\n\n    >>> mesh = uw.meshing.UnstructuredSimplexBox(\n    ...     minCoords=(0, 0), maxCoords=(1, 1), cellSize=0.1\n    ... )\n    >>> T = mesh.add_variable(\"T\", vtype=uw.VarType.SCALAR)\n\nSee Also\n--------\nunderworld3.meshing : Mesh generation utilities.\nunderworld3.discretisation.MeshVariable : Field variables on meshes.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "EnhancedMeshVariable",
    "kind": "class",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 37,
    "signature": "class EnhancedMeshVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Enhanced MeshVariable with mathematical operations, units support, and persistence.\n\nThis class enhances the base MeshVariable with:\n- Mathematical operations (via MathematicalMixin) - direct arithmetic, component access\n- Units support (via DimensionalityMixin) - dimensional analysis, unit conversion\n- Optional persistence for adaptive meshing scenarios\n- Collision-safe registration with qualified naming\n- All original MeshVariable functionality (via controlled delegation)\n\nThe wrapper uses controlled delegation to avoid assignment issues with\noperators like += while providing seamless access to the underlying\nMeshVariable functionality.\n\nExamples:\n    # Basic enhanced variable\n    velocity = EnhancedMeshVariable(\"velocity\", mesh, 2, units=\"m/s\")\n\n    # Mathematical operations\n    momentum = density * velocity\n    v_x = velocity[0]\n    speed = velocity.norm(\"L2\")\n\n    # Persistence for adaptive meshing\n    persistent_var = EnhancedMeshVariable(\"pressure\", mesh, 1, persistent=True)\n    success = persistent_var.transfer_data_from(old_pressure)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DMInterpolationCache",
    "kind": "class",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 24,
    "signature": "class DMInterpolationCache",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Per-mesh cache for DMInterpolation structures.\n\nCache key: (coord_hash, dofcount)\nCache value: CachedDMInterpolationInfo object (Cython wrapper)\n\nAutomatically tracks hits, misses, and invalidations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UWexpression",
    "kind": "class",
    "file": "src/underworld3/function/expressions.py",
    "line": 533,
    "signature": "class UWexpression",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A SymPy Symbol that wraps a value for lazy evaluation.\n\nUWexpression is a named symbolic placeholder. When used in SymPy expressions,\nit acts as a Symbol. At evaluation time, the wrapped value is substituted.\n\nKey Design (Simplified 2025-11):\n- Inherits from Symbol for SymPy compatibility\n- Does NOT inherit from UWQuantity (expressions don't have units themselves)\n- Units are discovered from the wrapped thing when needed\n- Arithmetic returns pure SymPy expressions\n\nSymbol Disambiguation (2025-12):\n- Uses _hashable_content() override (like sympy.Dummy) for uniqueness\n- Clean display names without invisible whitespace hacks\n- Symbols with same name but different _uw_id are distinct\n\nParameters\n----------\nname : str\n    LaTeX-style name for display (e.g., r\"\\alpha\", r\"\\rho_0\")\nsym : any, optional\n    The wrapped value. Can be:\n    - A number\n    - A UWQuantity (carries units)\n    - Another UWexpression (nested lazy evaluation)\n    - A SymPy expression\ndescription : str, optional\n    Human-readable description\n\nExamples\n--------\n>>> alpha = uw.expression(r\"\\alpha\", uw.quantity(3e-5, \"1/K\"))\n>>> rho0 = uw.expression(r\"\\rho_0\", uw.quantity(3300, \"kg/m^3\"))\n>>>\n>>> # Symbolic multiplication\n>>> product = rho0 * alpha  # Returns SymPy Mul\n>>>\n>>> # Wrap the product for lazy evaluation\n>>> combo = uw.expression(r\"\\rho_0 \\alpha\", product)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UWDerivativeExpression",
    "kind": "class",
    "file": "src/underworld3/function/expressions.py",
    "line": 1657,
    "signature": "class UWDerivativeExpression",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Expression representing a derivative for lazy evaluation.\n\nA specialized expression that stores a derivative operation and\nevaluates it only when :meth:`doit` is called.\n\nParameters\n----------\nexpr : sympy.Basic\n    The expression to differentiate.\n*args : sympy.Symbol\n    Variables to differentiate with respect to.\n**kwargs\n    Additional arguments passed to :class:`UWexpression`.\n\nExamples\n--------\n>>> deriv = UWDerivativeExpression(x**2, x)\n>>> deriv.doit()\n2*x",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UWQuantity",
    "kind": "class",
    "file": "src/underworld3/function/quantities.py",
    "line": 22,
    "signature": "class UWQuantity",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A number with units.\n\nSimple, clean, Pint-backed. Follows the MeshVariable pattern:\n- .value \u2192 dimensional (what user sees)\n- .data \u2192 non-dimensional (what solver sees)\n- .units \u2192 Pint Unit object\n\nAll arithmetic is delegated to Pint. No symbolic complexity.\n\nParameters\n----------\nvalue : float, int, array-like\n    The numerical value (dimensional)\nunits : str or Pint Unit, optional\n    Units specification (e.g., \"Pa*s\", \"cm/year\", \"K\")\n\nExamples\n--------\n>>> viscosity = uw.quantity(1e21, \"Pa*s\")\n>>> viscosity.value  # 1e21 (dimensional)\n>>> viscosity.data   # 1.0 (non-dimensional, if model is set up)\n>>> viscosity.units  # <Unit('pascal * second')>\n\n>>> # Arithmetic via Pint\n>>> T1 = uw.quantity(1000, \"kelvin\")\n>>> T2 = uw.quantity(273, \"kelvin\")\n>>> dT = T1 - T2  # UWQuantity(727, \"kelvin\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "KDTree",
    "kind": "class",
    "file": "src/underworld3/kdtree.py",
    "line": 18,
    "signature": "class KDTree",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unit-aware KDTree for spatial indexing and queries.\n\nThis class extends pykdtree.KDTree to handle coordinate units properly:\n- Stores coordinate units when constructed from unit-aware data\n- Automatically converts query coordinates to match the KD-tree's units\n- Returns distances with appropriate units (when not squared)\n- Compatible with both unit-aware and plain numpy arrays\n\nUsage:\n    # Create KD-tree from mesh with units\n    mesh = uw.meshing.StructuredQuadBox(..., units=\"km\")\n    kd = uw.kdtree.KDTree(mesh.points)\n\n    # Query with coordinates (units will be converted if needed)\n    query_pts = np.array([[100.0, 50.0]])  # Can have units or not\n    distances, indices = kd.query(query_pts)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MaterialProperty",
    "kind": "class",
    "file": "src/underworld3/materials.py",
    "line": 15,
    "signature": "class MaterialProperty",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Standard material properties for geodynamic models",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MaterialDefinition",
    "kind": "class",
    "file": "src/underworld3/materials.py",
    "line": 45,
    "signature": "class MaterialDefinition",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Definition of a material with its properties and metadata.\n\nAttributes:\n-----------\nname : str\n    Material name (e.g., 'mantle', 'crust', 'plume')\nproperties : dict\n    Dictionary of property_name -> value mappings\ndescription : str\n    Human-readable description\nreference : str\n    Literature reference or source\ntemperature_dependent : dict\n    Temperature-dependent property functions\npressure_dependent : dict\n    Pressure-dependent property functions\nconstitutive_model : object\n    Associated constitutive model instance",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MaterialRegistry",
    "kind": "class",
    "file": "src/underworld3/materials.py",
    "line": 129,
    "signature": "class MaterialRegistry",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Central registry for material definitions and region assignments.\n\nFeatures:\n---------\n- Material property database with validation\n- Region-based material assignments\n- Temperature/pressure dependent properties\n- Integration with constitutive models\n- Automatic property propagation to solvers\n\nExample:\n--------\n>>> registry = MaterialRegistry()\n>>> mantle = registry.create_material('mantle')\n>>> mantle.set_property('viscosity', 1e21)\n>>> mantle.set_property('density', 3300)\n>>> registry.assign_to_region('mantle', region_id=1)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh_vector_calculus",
    "kind": "class",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 31,
    "signature": "class mesh_vector_calculus",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector calculus operators for Cartesian meshes.\n\nProvides gradient, divergence, curl, and strain tensor operations\nusing SymPy's vector calculus module. Operates on row matrices\nrepresenting vector fields.\n\nParameters\n----------\nmesh : Mesh\n    The mesh object providing the coordinate system.\n\nAttributes\n----------\nmesh : Mesh\n    Reference to the parent mesh.\ndim : int\n    Spatial dimension (2 or 3).\n\nMethods\n-------\ngradient(scalar)\n    Compute :math:`\\nabla \\phi`.\ndivergence(vector)\n    Compute :math:`\\nabla \\cdot \\mathbf{v}`.\ncurl(vector)\n    Compute :math:`\\nabla \\times \\mathbf{v}`.\nstrain_tensor(vector)\n    Compute symmetric gradient (strain rate tensor).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh_vector_calculus_cylindrical",
    "kind": "class",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 271,
    "signature": "class mesh_vector_calculus_cylindrical",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector calculus operators for cylindrical coordinates.\n\nProvides gradient, divergence, curl operations in cylindrical\n:math:`(r, \\theta, z)` coordinates, accounting for the metric terms\nthat arise from coordinate curvature.\n\nParameters\n----------\nmesh : Mesh\n    Mesh with cylindrical coordinate system.\n\nWarnings\n--------\nNative cylindrical coordinate meshes are deprecated. This class\nissues a warning when used with non-native coordinate types.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh_vector_calculus_spherical",
    "kind": "class",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 598,
    "signature": "class mesh_vector_calculus_spherical",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector calculus operators for spherical coordinates.\n\nProvides gradient, divergence, curl operations in spherical\n:math:`(r, \\theta, \\phi)` coordinates using the standard physics\nconvention: radius, colatitude (polar angle), and longitude (azimuth).\n\nParameters\n----------\nmesh : Mesh\n    Mesh with spherical coordinate system.\n\nWarnings\n--------\nIssues a warning if the mesh coordinate type is not\n``SPHERICAL_NATIVE``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "kind": "class",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 784,
    "signature": "class mesh_vector_calculus_spherical_surface2D_lonlat",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector calculus operators for 2D spherical surface.\n\nProvides gradient, divergence, curl operations on the surface of a\nsphere using longitude-latitude :math:`(\\lambda, \\phi)` coordinates.\nThis convention is convenient for Earth-Science applications.\n\nParameters\n----------\nmesh : Mesh\n    Mesh with spherical surface coordinate system.\n\nNotes\n-----\nThe radius is fixed at :math:`r = 1` (unit sphere). Use coordinate\nscaling if physical units are needed.\n\nWarnings\n--------\nIssues a warning if the mesh coordinate type is not\n``SPHERE_SURFACE_NATIVE``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "FaultSurface",
    "kind": "class",
    "file": "src/underworld3/meshing/faults.py",
    "line": 69,
    "signature": "class FaultSurface",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A triangulated fault surface with orientation data.\n\nRepresents a single fault segment as a 2D surface embedded in 3D space.\nCan be created from:\n- A point cloud (requires triangulation via pyvista)\n- A VTK file (pre-triangulated surface)\n\nAttributes:\n    name: Identifier for this fault segment\n    points: (N, 3) array of surface points\n    triangles: (M, 3) array of triangle vertex indices (after triangulation)\n    normals: (M, 3) array of face normals (after triangulation)\n    pv_mesh: PyVista PolyData object (if pyvista available)\n    is_triangulated: Whether the surface has been triangulated\n\nExample:\n    >>> # Create from points and triangulate\n    >>> points = np.array([[0, 0, 0], [1, 0, 0], [0.5, 1, 0], [0.5, 0.5, 1]])\n    >>> fault = uw.meshing.FaultSurface(\"fault1\", points)\n    >>> fault.triangulate()\n    >>> fault.to_vtk(\"fault1.vtk\")\n    >>>\n    >>> # Load from VTK\n    >>> fault2 = uw.meshing.FaultSurface.from_vtk(\"fault1.vtk\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "FaultCollection",
    "kind": "class",
    "file": "src/underworld3/meshing/faults.py",
    "line": 376,
    "signature": "class FaultCollection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Collection of fault surfaces for mesh integration.\n\nManages multiple FaultSurface objects and provides methods to:\n- Compute minimum distance from mesh points to any fault\n- Transfer fault normals to mesh variables via nearest-neighbor\n- Create rheology functions for fault-weakened zones\n\nExample:\n    >>> faults = uw.meshing.FaultCollection()\n    >>> faults.add_from_vtk(\"fault1.vtk\")\n    >>> faults.add_from_vtk(\"fault2.vtk\")\n    >>>\n    >>> # Compute distance field\n    >>> fault_distance = faults.compute_distance_field(mesh)\n    >>>\n    >>> # Transfer normals\n    >>> fault_normals = faults.transfer_normals(mesh)\n    >>>\n    >>> # Create weakness function for rheology\n    >>> eta_weak = faults.create_weakness_function(\n    ...     fault_distance,\n    ...     fault_width=mesh.get_min_radius() * 5,\n    ...     eta_weak=0.01,\n    ... )",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SurfaceVariable",
    "kind": "class",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 71,
    "signature": "class SurfaceVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable defined on surface vertices, stored in pyvista point_data.\n\nProvides direct access to per-vertex data via .data property, and\nsymbolic access for expressions via .sym property.\n\nThe .sym property uses a proxy MeshVariable that is lazily interpolated\nfrom surface vertices to mesh nodes when accessed.\n\nUnit awareness is provided via UnitAwareArray wrapper on .data access.\nDistance-based masking is available via .mask property when mask_width is set.\n\nAttributes:\n    name: Variable name (also the key in pyvista point_data)\n    surface: Parent Surface object\n    size: Number of components per vertex\n    units: Optional units for this variable (e.g., \"Pa\", \"m/s\")\n\nExample:\n    >>> friction = surface.add_variable(\"friction\", size=1, mask_width=0.1)\n    >>> friction.data[:] = 0.6  # Set values on surface vertices\n    >>> friction.data[weak_mask] = 0.3  # Set weak zone values\n    >>>\n    >>> # Use in expressions with explicit masking\n    >>> eta = friction.sym[0] * friction.mask",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Surface",
    "kind": "class",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 317,
    "signature": "class Surface",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A discretized embedded surface with variable storage.\n\nRepresents a surface embedded in a computational mesh using pyvista PolyData\nfor storage. In 3D, surfaces are triangulated meshes; in 2D, they are polylines.\nSupports per-vertex variables with symbolic access for use in Underworld expressions.\n\nThe surface uses lazy evaluation with stale flags:\n- Discretization is computed when first accessed\n- Distance field is computed when first accessed\n- Proxy MeshVariables are updated when .sym is accessed\n\nAttributes:\n    name: Identifier for this surface\n    mesh: Associated computational mesh (for proxy MeshVariables)\n    vertices: (N, 3) array of vertex positions (via pyvista)\n    normals: (N, 3) array of vertex normals (via pyvista)\n    n_vertices: Number of vertices\n    n_triangles: Number of triangles (3D only)\n\nExample:\n    >>> # Create from points and discretize\n    >>> surface = uw.meshing.Surface(\"fault\", mesh, points)\n    >>> surface.discretize()\n    >>>\n    >>> # Add a variable\n    >>> friction = surface.add_variable(\"friction\")\n    >>> friction.data[:] = 0.6\n    >>>\n    >>> # Use distance field in influence function\n    >>> eta_weak = surface.influence_function(\n    ...     width=0.05,\n    ...     value_near=0.01,\n    ...     value_far=1.0,\n    ...     profile=\"gaussian\",\n    ... )",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SurfaceCollection",
    "kind": "class",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1251,
    "signature": "class SurfaceCollection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Collection of surfaces for combined operations.\n\nManages multiple Surface objects and provides methods to:\n- Compute minimum distance from mesh points to any surface\n- Transfer surface normals to mesh variables via nearest-neighbor\n- Create combined influence functions\n\nExample:\n    >>> surfaces = uw.meshing.SurfaceCollection()\n    >>> surfaces.add(fault1)\n    >>> surfaces.add(fault2)\n    >>>\n    >>> # Compute combined distance field\n    >>> dist = surfaces.compute_distance_field(mesh)\n    >>>\n    >>> # Combined influence function\n    >>> eta = surfaces.influence_function(\n    ...     width=0.05,\n    ...     value_near=0.01,\n    ...     value_far=1.0,\n    ... )",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ModelState",
    "kind": "class",
    "file": "src/underworld3/model.py",
    "line": 46,
    "signature": "class ModelState",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Model lifecycle states",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Model",
    "kind": "class",
    "file": "src/underworld3/model.py",
    "line": 57,
    "signature": "class Model",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Central orchestrator for Underworld3 simulations.\n\nEnhanced with Pydantic for validation, serialization, and configuration management\nwhile preserving the original design philosophy of simple orchestration.\n\nThe Model object manages:\n- Mesh and coordinate system lifecycle\n- Swarm registration and migration\n- Variable dependencies and updates\n- Parameter validation and propagation\n- Material definitions and assignments\n- Solver coordination\n\nBenefits:\n- Eliminates circular references between components\n- Enables mesh swapping and dynamic reconfiguration\n- Provides single point for parameter management\n- Supports model composition and reuse\n- Enhanced serialization with YAML/JSON support\n- Optional validation with Pydantic\n\nExample:\n    >>> model = uw.Model()\n    >>> model.set_mesh(mesh)\n    >>> swarm = model.create_swarm()\n    >>> temperature = model.add_variable(\"temperature\", mesh, uw.VarType.SCALAR)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ThermalConvectionConfig",
    "kind": "class",
    "file": "src/underworld3/model.py",
    "line": 4549,
    "signature": "class ThermalConvectionConfig",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Configuration model for thermal convection simulations.\n\nDemonstrates how to create specialized parameter configurations\nthat work with the enhanced Model infrastructure.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CollectiveOperationError",
    "kind": "class",
    "file": "src/underworld3/mpi.py",
    "line": 209,
    "signature": "class CollectiveOperationError",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Raised when a collective operation is called inside selective_ranks()",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "call_pattern",
    "kind": "class",
    "file": "src/underworld3/mpi.py",
    "line": 361,
    "signature": "class call_pattern",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This context manager calls the code within its block using the\nspecified calling pattern.\n\nParameters\n----------\npattern: str\n    'collective', each process calls the block of code simultaneously.\n    'sequential', processes call block of code in order of rank.\n\nExample\n-------\nThis example is redundant as it will only run with a single process.\nHowever, where run in parallel, you should expect the outputs to be\nordered according to process rank. Note also that for deterministic\nprinting in parallel, and you may need to run Python unbuffered\n(`mpirun -np 4 python -u yourscript.py`, for example).\n\n>>> import underworld as uw\n>>> with uw.mpi.call_pattern(pattern=\"sequential\"):\n...     print(\"My rank is {}\".format(uw.mpi.rank))\nMy rank is 0",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ParameterType",
    "kind": "class",
    "file": "src/underworld3/parameters.py",
    "line": 16,
    "signature": "class ParameterType",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Supported parameter types with validation",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ParameterDefinition",
    "kind": "class",
    "file": "src/underworld3/parameters.py",
    "line": 29,
    "signature": "class ParameterDefinition",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Definition of a parameter including validation rules and metadata.\n\nAttributes:\n-----------\nname : str\n    Parameter name (e.g., 'viscosity', 'Ra', 'solver.tolerance')\nptype : ParameterType\n    Parameter type for validation\ndefault : Any\n    Default value\nbounds : tuple, optional\n    (min, max) bounds for numerical parameters\nchoices : list, optional\n    Valid choices for enum parameters\ndescription : str\n    Human-readable description\nunits : str\n    Physical units (for documentation)\nvalidator : callable, optional\n    Custom validation function\ndependencies : list\n    List of parameter paths that depend on this parameter",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ParameterRegistry",
    "kind": "class",
    "file": "src/underworld3/parameters.py",
    "line": 119,
    "signature": "class ParameterRegistry",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Central registry for model parameters with validation and dependency tracking.\n\nFeatures:\n---------\n- Hierarchical parameter organization (e.g., 'material.viscosity', 'solver.tolerance')\n- Type validation and bounds checking\n- Dependency tracking and automatic updates\n- Parameter history and versioning\n- Import/export for reproducible configurations\n\nExample:\n--------\n>>> registry = ParameterRegistry()\n>>> registry.define_parameter('Ra', ParameterType.SCALAR, default=1e5,\n...                          bounds=(1e3, 1e8), description='Rayleigh number')\n>>> registry.set_parameter('Ra', 2e5)\n>>> registry.get_parameter('Ra')\n2e5",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SwarmType",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 52,
    "signature": "class SwarmType",
    "parameters": [],
    "returns": null,
    "existing_docstring": "PETSc swarm type specification.\n\nDetermines how particles are managed by PETSc's DMSwarm infrastructure.\n\nAttributes\n----------\nDMSWARM_BASIC : int\n    Basic point cloud without mesh association.\nDMSWARM_PIC : int\n    Particle-in-cell mode with automatic mesh cell tracking.\n    Particles are migrated between MPI ranks as they move across\n    cell boundaries.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SwarmVariable",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 82,
    "signature": "class SwarmVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable supported by a particle swarm (point cloud).\n\nA SwarmVariable stores values at discrete particle locations and provides\na mesh-based proxy representation for use in symbolic expressions. This\nenables Lagrangian tracking of material properties through deformation.\n\nParameters\n----------\nname : str\n    Identifier for this variable (must be unique within the swarm).\nswarm : Swarm\n    The supporting particle swarm.\nsize : int or tuple, optional\n    Shape specification: int for vectors, tuple for matrices.\n    If None, inferred from ``vtype``.\nvtype : VarType, optional\n    Variable type (SCALAR, VECTOR, TENSOR, SYM_TENSOR, MATRIX).\n    If None, inferred from ``size``.\ndtype : type, default=float\n    Data type for storage (float or int).\nproxy_degree : int, default=1\n    Polynomial degree for the mesh proxy variable.\nproxy_continuous : bool, default=True\n    Whether the proxy uses continuous (True) or discontinuous (False)\n    interpolation.\nvarsymbol : str, optional\n    LaTeX symbol for display. Defaults to ``name``.\nrebuild_on_cycle : bool, default=True\n    If True, rebuild the proxy when particles cycle through periodic\n    boundaries. Recommended for continuous fields.\nunits : str or pint.Unit, optional\n    Physical units for this variable (e.g., 'kelvin', 'Pa').\n    Requires reference quantities to be set on the model.\n\nAttributes\n----------\ndata : numpy.ndarray\n    Direct access to variable values at particle locations.\nsym : sympy.Matrix\n    Symbolic representation for use in expressions.\n\nSee Also\n--------\nMeshVariable : Variable supported by mesh nodes.\nSwarm : Container for particle locations.\n\nExamples\n--------\nCreate a temperature field on a swarm:\n\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> T = swarm.add_variable(\"T\", size=1, vtype=uw.VarType.SCALAR)\n>>> T.data[:] = 1600.0  # Set initial temperature\n\nCreate a velocity field:\n\n>>> v = swarm.add_variable(\"v\", size=mesh.dim, vtype=uw.VarType.VECTOR)\n\nNotes\n-----\nSwarmVariables are essential for tracking material properties that\nadvect with the flow. The mesh proxy enables their use in finite\nelement formulations while particle storage preserves Lagrangian\nhistory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "IndexSwarmVariable",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 1903,
    "signature": "class IndexSwarmVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Integer-valued swarm variable for material tracking.\n\nIndexSwarmVariable stores integer indices at particle locations, typically\nused for tracking distinct material types. It automatically generates\nsymbolic mask expressions for each material index, enabling material-\ndependent properties in constitutive models.\n\nParameters\n----------\nname : str\n    Variable name for identification and I/O.\nswarm : Swarm\n    Parent swarm object.\nindices : int\n    Number of distinct material indices (default 1).\nproxy_degree : int\n    Polynomial degree for mesh projection (default 1).\nproxy_continuous : bool\n    Whether mesh proxy is continuous (default True).\n\nAttributes\n----------\nsym : list of sympy.Expr\n    Symbolic mask expressions for each material index.\n\nExamples\n--------\n>>> material = IndexSwarmVariable(\"M\", swarm, indices=3)\n>>> material.data[:] = 0  # Set all particles to material 0\n>>> # Use sym[i] as multiplier for material i properties\n>>> viscosity = material.sym[0] * 1e20 + material.sym[1] * 1e21\n\nSee Also\n--------\nSwarmVariable : Base class for particle-supported variables.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Swarm",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 2213,
    "signature": "class Swarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A basic particle swarm implementation for Lagrangian particle tracking and data storage.\n\nThe UW `Swarm` class provides a simplified particle management system that uses\nPETSc's DMSWARM_BASIC type. Unlike the standard `Swarm` class, this implementation\ndoes not rely on PETSc to determine ranks for particle migration but instead uses\nour own kdtree neighbour-domain computations.\n\nThis class is preferred for most operations except where particle / cell relationships\nare always required.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The mesh object that defines the computational domain for particle operations.\n    Particles will be associated with this mesh for spatial queries and operations.\nrecycle_rate : int, optional\n    Rate at which particles are recycled for streak management. If > 1, enables\n    streak particle functionality where particles are duplicated and tracked\n    across multiple cycles. Default is 0 (no recycling).\nverbose : bool, optional\n    Enable verbose output for debugging and monitoring particle operations.\n    Default is False.\n\nAttributes\n----------\nmesh : uw.discretisation.Mesh\n    Reference to the associated mesh object.\ndim : int\n    Spatial dimension of the mesh (2D or 3D).\ncdim : int\n    Coordinate dimension of the mesh.\ndata : numpy.ndarray\n    Direct access to particle coordinate data.\nparticle_coordinates : SwarmVariable\n    SwarmVariable containing particle coordinate information.\nrecycle_rate : int\n    Current recycle rate for streak management.\ncycle : int\n    Current cycle number for streak particles.\n\nMethods\n-------\npopulate(fill_param=1)\n    Populate the swarm with particles throughout the domain.\nmigrate(remove_sent_points=True, delete_lost_points=True, max_its=10)\n    Manually migrate particles across MPI processes after coordinate updates.\nadd_particles_with_coordinates(coords)\n    Add new particles at specified coordinate locations.\nadd_particles_with_global_coordinates(coords)\n    Add particles using global coordinate system.\nadd_variable(name, size, dtype=float)\n    Add a new variable to track additional particle properties.\nsave(filename, meshUnits=1.0, swarmUnits=1.0, units=\"dimensionless\")\n    Save swarm data to file.\nread_timestep(filename, step_name, outputPath=\"./output/\")\n    Read swarm data from a specific timestep file.\nadvection(V_fn, delta_t, evalf=False, corrector=True, restore_points_func=None)\n    Advect particles using a velocity field.\nestimate_dt(V_fn, dt_min=1.0e-15, dt_max=1.0)\n    Estimate appropriate timestep for particle advection.\n\nExamples\n--------\nCreate a basic swarm and populate with particles:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1))\n>>> swarm = uw.swarm.Swarm(mesh=mesh)\n>>> swarm.populate(fill_param=2)\n\nCreate a streak swarm with recycling:\n\n>>> streak_swarm = uw.swarm.Swarm(mesh=mesh, recycle_rate=5)\n>>> streak_swarm.populate(fill_param=1)\n\nAdd custom particle data:\n\n>>> temperature = swarm.add_variable(\"temperature\", 1)\n>>> velocity = swarm.add_variable(\"velocity\", mesh.dim)\n\nManual particle migration after coordinate updates:\n\nNote: particle migration is still called automatically when we\n`access` and update the particle_coordinates variables\n\nNote: `swarm.populate` uses a the mesh point locations for discontinuous interpolants to\ndetermine the particle locations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "NodalPointSwarm",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 4301,
    "signature": "class NodalPointSwarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "BASIC_Swarm with particles located at the coordinate points of a meshVariable\n\nThe swarmVariable `X0` is defined so that the particles can \"snap back\" to their original locations\nafter they have been moved.\n\nThe purpose of this Swarm is to manage sample points for advection schemes based on upstream sampling\n(method of characteristics etc)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SwarmPICLayout",
    "kind": "class",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 25,
    "signature": "class SwarmPICLayout",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Particle population fill type:\n\nSwarmPICLayout.REGULAR     defines points on a regular ijk mesh. Supported by simplex cell types only.\nSwarmPICLayout.GAUSS       defines points using an npoint Gauss-Legendre tensor product quadrature rule.\nSwarmPICLayout.SUBDIVISION defines points on the centroid of a sub-divided reference cell.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "PICSwarm",
    "kind": "class",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 39,
    "signature": "class PICSwarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Particle swarm implementation with automatic mesh-particle interactions.\n\nThe `Swarm` class is Underworld's primary particle management system, built on PETSc's\nDMSWARM_PIC type. It provides automatic particle migration, mesh-particle connectivity,\nand streamlined particle operations for Lagrangian particle tracking and data storage.\n\nDifferences from UW Swarm:\n- **Mesh Integration**: Built-in particle-in-cell (PIC) connectivity with automatic cell tracking\n- **Migration**: Uses the standard PETSc strategy for migration which depends on the DM type. This requires\n  calculation of cell-relationships each time the coordinates are updated and particles that are not found will\n  be deleted.\n\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The mesh object that defines the computational domain. Particles will be\n    automatically associated with mesh cells for efficient spatial operations.\nrecycle_rate : int, optional\n    Rate at which particles are recycled for streak management. If > 1, enables\n    streak particle functionality where particles are duplicated and tracked\n    across multiple cycles. Default is 0 (no recycling).\nverbose : bool, optional\n    Enable verbose output for debugging and monitoring particle operations.\n    Default is False.\n\nAttributes\n----------\nmesh : uw.discretisation.Mesh\n    Reference to the associated mesh object.\ndim : int\n    Spatial dimension of the mesh (2D or 3D).\ncdim : int\n    Coordinate dimension of the mesh.\ndata : numpy.ndarray\n    Direct access to particle coordinate data.\nparticle_coordinates : SwarmVariable\n    SwarmVariable containing particle coordinate information (auto-created).\nparticle_cellid : SwarmVariable\n    SwarmVariable containing particle cell ID information (auto-created).\nrecycle_rate : int\n    Current recycle rate for streak management.\ncycle : int\n    Current cycle number for streak particles.\n\nMethods\n-------\npopulate_petsc(fill_param=1)\n    Populate swarm using PETSc's built-in particle generation.\npopulate(fill_param=1, layout=SwarmPICLayout.GAUSS)\n    Populate the swarm with particles using specified layout.\nadd_particles_with_coordinates(coords)\n    Add new particles at specified coordinate locations.\nadd_variable(name, size, dtype=float)\n    Add a new variable to track additional particle properties.\nsave(filename, meshUnits=1.0, swarmUnits=1.0, units=\"dimensionless\")\n    Save swarm data to file.\nread_timestep(filename, step_name, outputPath=\"./output/\")\n    Read swarm data from a specific timestep file.\nadvection(V_fn, delta_t, evalf=False, corrector=True, restore_points_func=None)\n    Advect particles using a velocity field with automatic migration.\nestimate_dt(V_fn, dt_min=1.0e-15, dt_max=1.0)\n    Estimate appropriate timestep for particle advection.\n\nExamples\n--------\nCreate a standard swarm with automatic features:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1))\n>>> swarm = uw.swarm.Swarm(mesh=mesh)\n>>> swarm.populate(fill_param=2, layout=uw.swarm.SwarmPICLayout.GAUSS)\n\nAccess automatic coordinate and cell ID fields:\n\n>>> coords = swarm._particle_coordinates.data\n>>> cell_ids = swarm.particle_cellid.data\n\nCreate a streak swarm with recycling:\n\n>>> streak_swarm = uw.swarm.Swarm(mesh=mesh, recycle_rate=5)\n>>> streak_swarm.populate(fill_param=1)\n\nAdd custom particle data and perform advection:\n\n>>> temperature = swarm.add_variable(\"temperature\", 1)\n>>> velocity_field = mesh.add_variable(\"velocity\", mesh.dim)\n>>> # ... set up velocity field ...\n>>> swarm.advection(velocity_field.sym, delta_t=0.01)  # Automatic migration\n\nNotes\n-----\n- Particle migration occurs automatically during advection operations\n- Coordinate and cell ID fields are created and managed automatically at the\n  PETSc level",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "NodalPointPICSwarm",
    "kind": "class",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1387,
    "signature": "class NodalPointPICSwarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm with particles located at the coordinate points of a meshVariable\n\nThe swarmVariable `X0` is defined so that the particles can \"snap back\" to their original locations\nafter they have been moved.\n\nThe purpose of this Swarm is to manage sample points for advection schemes based on upstream sampling\n(method of characteristics etc)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Symbolic",
    "kind": "class",
    "file": "src/underworld3/systems/ddt.py",
    "line": 50,
    "signature": "class Symbolic",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic history manager for time derivative approximations.\n\nManages the update of a variable :math:`\\psi` across timesteps. The history\noperator stores :math:`\\psi` over several timesteps (given by ``order``) so\nthat it can compute backward differentiation (BDF) or Adams-Moulton expressions.\n\nThe history operator is defined as:\n\n.. math::\n\n    \\psi_p^{t-n\\Delta t} &\\leftarrow \\psi_p^{t-(n-1)\\Delta t} \\\\\n    \\psi_p^{t-(n-1)\\Delta t} &\\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots \\\\\n    \\psi_p^{t-\\Delta t} &\\leftarrow \\psi_p^{t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Eulerian",
    "kind": "class",
    "file": "src/underworld3/systems/ddt.py",
    "line": 240,
    "signature": "class Eulerian",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Eulerian (mesh-based) history manager.\n\nManages the update of a variable :math:`\\psi` on the mesh across timesteps:\n\n.. math::\n\n    \\psi_p^{t-n\\Delta t} &\\leftarrow \\psi_p^{t-(n-1)\\Delta t} \\\\\n    \\psi_p^{t-(n-1)\\Delta t} &\\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots \\\\\n    \\psi_p^{t-\\Delta t} &\\leftarrow \\psi_p^{t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SemiLagrangian",
    "kind": "class",
    "file": "src/underworld3/systems/ddt.py",
    "line": 537,
    "signature": "class SemiLagrangian",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Semi-Lagrangian history manager using nodal swarm.\n\nManages the semi-Lagrangian update of a mesh variable :math:`\\psi`\nacross timesteps:\n\n.. math::\n\n    \\psi_p^{t-n\\Delta t} &\\leftarrow \\psi_p^{t-(n-1)\\Delta t} \\\\\n    \\psi_p^{t-(n-1)\\Delta t} &\\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots \\\\\n    \\psi_p^{t-\\Delta t} &\\leftarrow \\psi_p^{t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Lagrangian",
    "kind": "class",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1146,
    "signature": "class Lagrangian",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm-based Lagrangian history manager.\n\nManages the update of a Lagrangian variable :math:`\\psi` on the swarm\nacross timesteps:\n\n.. math::\n\n    \\psi_p^{t-n\\Delta t} \\leftarrow \\psi_p^{t-(n-1)\\Delta t}\n\n    \\psi_p^{t-(n-1)\\Delta t} \\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots\n\n    \\psi_p^{t-\\Delta t} \\leftarrow \\psi_p^{t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Lagrangian_Swarm",
    "kind": "class",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1356,
    "signature": "class Lagrangian_Swarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm-based Lagrangian history manager (user-provided swarm).\n\nManages the update of a Lagrangian variable :math:`\\psi` on a user-supplied\nswarm across timesteps:\n\n.. math::\n\n    \\psi_p^{t-n\\Delta t} \\leftarrow \\psi_p^{t-(n-1)\\Delta t}\n\n    \\psi_p^{t-(n-1)\\Delta t} \\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots\n\n    \\psi_p^{t-\\Delta t} \\leftarrow \\psi_p^{t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UnitsError",
    "kind": "class",
    "file": "src/underworld3/units.py",
    "line": 25,
    "signature": "class UnitsError",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Exception raised for units-related errors.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DimensionalityError",
    "kind": "class",
    "file": "src/underworld3/units.py",
    "line": 31,
    "signature": "class DimensionalityError",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Exception raised for dimensional inconsistency errors.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "NoUnitsError",
    "kind": "class",
    "file": "src/underworld3/units.py",
    "line": 37,
    "signature": "class NoUnitsError",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Exception raised when units are expected but not found.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_condition",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 405,
    "signature": "def add_condition(self, f_id, c_type, conds, label, components=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Add a dirichlet or neumann condition to the mesh.\n\n        This function prepares UW data to use PetscDSAddBoundary().\n\n        Parameters\n        ----------\n        f_id: int\n            Index of the solver's field (equation) to apply the condition.\n            Note: The solvers field id is usually different to the mesh's field ids.\n        c_type: string\n            BC type. Either dirichlet (essential) or neumann (natural) conditions.\n        conds: array_like of floats or a sympy.Matrix\n            eg. For a 3D model with an unconstraint x component: (None, 5, 1.2) or sympy.Matrix([sympy.oo, 5, 1.2])\n        label: string\n            The label name to apply the BC. To find a label/boundary name run something like\n            mesh.view()\n        components: array_like, single int value or None.\n            (optional) tuple, or int of active conds components to use. Use 'None' for all conds to be used.\n            If 'None' and components in 'cond' equal sympy.oo or -sympy.oo those components won't be used.\n            eg. For the 3D example cond = (2, 5, 1.2), components = (1,2) the x components is ignored and uncontrainted.\n",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_numeric_only",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 538,
    "signature": "def is_numeric_only(val):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if value is a pure number (no symbols).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_essential_bc",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 576,
    "signature": "def add_essential_bc(self, conds, boundary, components=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        see add_condtion() docstring\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_natural_bc",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 584,
    "signature": "def add_natural_bc(self, conds, boundary, components=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        see add_condtion() docstring\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_dirichlet_bc",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 591,
    "signature": "def add_dirichlet_bc(self, conds, boundary, components=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        see add_condtion() docstring\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_local_field_is",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 3197,
    "signature": "def get_local_field_is(section, field, unconstrained=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n            This function returns the index set of unconstrained points if True, or all points if False.\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 3267,
    "signature": "def estimate_dt(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Calculates an appropriate advective timestep for the given\n        mesh and velocity configuration.\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 136,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise source/sink term :math:`f_0(u)`.\n\nThis represents the volumetric source term in the weak form.",
    "harvested_comments": [
      "Note: negative sign for weak form"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 151,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flux term :math:`\\mathbf{F}_1(u, \\nabla u)`.\n\nThis represents the flux that appears in the divergence term.",
    "harvested_comments": [
      "Default: simple diffusion"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "my_equation_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 172,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Set up the problem description for the PETSc solver.\n\nThis method defines the residual terms for the finite element formulation.",
    "harvested_comments": [
      "Source term (f0 - pointwise integration)",
      "Flux term (f1 - integration by parts)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 188,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term function.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 193,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "alpha",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 199,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Example parameter alpha.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "alpha",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 204,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set parameter alpha.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "beta",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 210,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Example parameter beta.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "beta",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 215,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set parameter beta.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "constitutive_model",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 221,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constitutive model defining material response.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "constitutive_model",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 226,
    "signature": "(self, model)",
    "parameters": [
      {
        "name": "model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the constitutive model.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 232,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if constitutive model is set up.",
    "harvested_comments": [
      "No model needed"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 240,
    "signature": "(self, verbose = False, debug = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "debug",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Solve the equation system.\n\nParameters\n----------\nverbose : bool\n    Enable verbose solver output\ndebug : bool\n    Enable debug output\n\nReturns\n-------\nConvergence information from PETSc solver\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "Set up problem if needed",
      "Call parent solve method"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 266,
    "signature": "(self, dt_min = 1e-15, dt_max = 1.0)",
    "parameters": [
      {
        "name": "dt_min",
        "type_hint": null,
        "default": "1e-15",
        "description": ""
      },
      {
        "name": "dt_max",
        "type_hint": null,
        "default": "1.0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Estimate appropriate timestep for stability.\n\nParameters\n----------\ndt_min : float\n    Minimum allowed timestep\ndt_max : float\n    Maximum allowed timestep\n\nReturns\n-------\nfloat\n    Estimated timestep",
    "harvested_comments": [
      "Get characteristic length scale",
      "Example: CFL-type condition",
      "dt < h^2 / (2 * diffusivity) for diffusion",
      "Extract diffusivity parameter (problem-specific)",
      "Additional stability constraints"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SNES_MyEquation",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 354,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector pointwise source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyVectorEquation",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 364,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector flux term - typically a tensor.",
    "harvested_comments": [
      "Default: identity tensor (for demonstration)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyVectorEquation",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 377,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyVectorEquation",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 382,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set vector source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyVectorEquation",
    "is_public": true
  },
  {
    "name": "poisson_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 234,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for Poisson FEM assembly.",
    "harvested_comments": [
      "f1 residual term (weighted integration) - scalar function",
      "f1 residual term (integration by parts / gradients)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 246,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the Poisson equation.\n\nThe source term :math:`f` appears on the right-hand side:\n\n.. math::\n    \\nabla \\cdot (\\kappa \\nabla u) = f\n\nReturns\n-------\nsympy.Matrix\n    Source term expression (scalar, shape ``(1, 1)``).\n\nSee Also\n--------\nconstitutive_model : Provides the diffusivity :math:`\\kappa`.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 266,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the source term (handles units and scaling).",
    "harvested_comments": [
      "Handle UWQuantity with units - enforce \"units everywhere\" principle",
      "Extract the plain value",
      "If ND scaling is active, scale the constant",
      "The source term should have same dimensionality as the unknown field",
      "Access via self.Unknowns.u (Poisson) or self.Unknowns.DuDt.u (Stokes)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 328,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whether the constitutive model is configured for this solver.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "darcy_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 453,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for Darcy flow FEM assembly.",
    "harvested_comments": [
      "f1 residual term (weighted integration)",
      "f1 residual term (integration by parts / gradients)",
      "Flow calculation"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 467,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the Darcy equation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 472,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "darcy_flux",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 478,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Darcy flux velocity computed from pressure gradient.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 484,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Projected Darcy velocity field.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 489,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the velocity projection target.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 495,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, verbose: bool = False, _force_setup: bool = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Solve the Darcy flow system.\n\nComputes the pressure field and Darcy flux velocity.\n\nParameters\n----------\nzero_init_guess : bool, optional\n    If True (default), start from zero initial guess.\n    If False, use current field values as initial guess.\ntimestep : float, optional\n    Timestep value for inertial terms (if applicable).\nverbose : bool, optional\n    If True, print solver progress information.\n_force_setup : bool, optional\n    Force re-setup of solver even if already configured.\n\nNotes\n-----\nAfter solving, the pressure field ``self.u`` and velocity field\n``self.v`` contain the solution.",
    "harvested_comments": [
      "Solve pressure",
      "Now solve flow field",
      "self._v_projector.petsc_options[\"snes_rtol\"] = 1.0e-6",
      "self._v_projector.petsc_options.delValue(\"ksp_monitor\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 733,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for Stokes FEM assembly (deprecated).",
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p0 residual term"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 747,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whether the constitutive model is configured for this solver.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 752,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symmetric strain rate tensor from velocity gradients.\n\nThe strain rate tensor :math:`\\dot{\\varepsilon}` is computed as:\n\n.. math::\n    \\dot{\\varepsilon}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)\n\nReturns\n-------\nsympy.Matrix\n    Symmetric tensor of shape ``(dim, dim)`` where ``dim`` is the\n    mesh dimensionality.\n\nSee Also\n--------\nstrainrate_1d : Voigt notation (vector) form.\nstress_deviator : Deviatoric stress computed from strain rate.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 775,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Strain rate in Voigt notation (vector form).\n\nConverts the symmetric strain rate tensor to Voigt notation for\nuse in constitutive model calculations. In 2D, returns a 3-component\nvector; in 3D, a 6-component vector.\n\nReturns\n-------\nsympy.Matrix\n    Strain rate in Voigt notation.\n\nSee Also\n--------\nstrainrate : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_star_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 794,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Historical strain rate in Voigt notation (for viscoelastic models).\n\nUsed in viscoelastic formulations where the stress depends on\nboth current and historical strain rates.\n\nReturns\n-------\nsympy.Matrix\n    Historical strain rate in Voigt notation.\n\nSee Also\n--------\nstrainrate_1d : Current strain rate.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 812,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deviatoric stress tensor from the constitutive model.\n\nThe deviatoric stress :math:`\\boldsymbol{\\tau}` is the traceless part\nof the stress tensor, computed by the constitutive model from the\nstrain rate:\n\n.. math::\n    \\boldsymbol{\\tau} = \\boldsymbol{\\eta} : \\dot{\\boldsymbol{\\varepsilon}}\n\nFor a Newtonian fluid: :math:`\\boldsymbol{\\tau} = 2\\eta\\dot{\\boldsymbol{\\varepsilon}}`\n\nReturns\n-------\nsympy.Matrix\n    Deviatoric stress tensor of shape ``(dim, dim)``.\n\nSee Also\n--------\nstress : Total stress (deviatoric + pressure).\nconstitutive_model : Provides the viscosity relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 837,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deviatoric stress in Voigt notation.\n\nReturns\n-------\nsympy.Matrix\n    Deviatoric stress in Voigt notation.\n\nSee Also\n--------\nstress_deviator : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 852,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total Cauchy stress tensor.\n\nThe total stress combines the deviatoric stress and pressure:\n\n.. math::\n    \\boldsymbol{\\sigma} = \\boldsymbol{\\tau} - p\\mathbf{I}\n\nwhere :math:`\\boldsymbol{\\tau}` is the deviatoric stress and\n:math:`p` is the pressure (positive in compression).\n\nReturns\n-------\nsympy.Matrix\n    Total stress tensor of shape ``(dim, dim)``.\n\nSee Also\n--------\nstress_deviator : Deviatoric (traceless) part.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 875,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total stress in Voigt notation.\n\nReturns\n-------\nsympy.Matrix\n    Total stress in Voigt notation.\n\nSee Also\n--------\nstress : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 890,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Velocity divergence.\n\nFor incompressible flow, this should be zero:\n\n.. math::\n    \\nabla \\cdot \\mathbf{u} = 0\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence expression.\n\nNotes\n-----\nNon-zero divergence indicates compressibility or mass sources/sinks.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 910,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constraint equation for the saddle-point system.\n\nBy default, this is the incompressibility constraint\n:math:`\\nabla \\cdot \\mathbf{u} = 0`. Can be modified for\ncompressible or other constrained formulations.\n\nReturns\n-------\nsympy.Expr\n    Constraint expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 925,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the constraint equation (e.g., incompressibility).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 932,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Body force vector (source term).\n\nThe volumetric body force :math:`\\mathbf{f}` appears on the\nright-hand side of the momentum equation:\n\n.. math::\n    -\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}\n\nCommon examples include gravity (:math:`\\rho\\mathbf{g}`) or\nbuoyancy forces.\n\nReturns\n-------\nUWexpression\n    Body force vector expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 952,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the body force vector (e.g., gravity, buoyancy).",
    "harvested_comments": [
      "Convert UWQuantity objects to SymPy expressions before Matrix creation",
      "If UWQuantity contains a Matrix, extract the scalar element"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 973,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Preconditioner for the Schur complement in the saddle-point system.\n\nFor the Stokes system, the default preconditioner is :math:`1/\\eta`\n(inverse viscosity), which approximates the Schur complement\n:math:`\\mathbf{S} \\approx \\mathbf{B}\\mathbf{A}^{-1}\\mathbf{B}^T`.\n\nReturns\n-------\nsympy.Expr\n    Preconditioner expression (typically inverse viscosity).\n\nNotes\n-----\nA good preconditioner significantly improves convergence of the\niterative solver. For variable viscosity, use the local viscosity.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 993,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the Schur complement preconditioner.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1000,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Augmented Lagrangian penalty parameter.\n\nThe penalty :math:`\\lambda` adds a term to the weak form that\npenalizes non-zero divergence:\n\n.. math::\n    \\lambda \\int (\\nabla \\cdot \\mathbf{u})(\\nabla \\cdot \\mathbf{v}) \\, dV\n\nThis improves convergence for incompressible flow without\nchanging the solution (since :math:`\\nabla \\cdot \\mathbf{u} = 0`\nat convergence).\n\nReturns\n-------\nUWexpression\n    Penalty parameter (typically a large constant, e.g., ``1e6 * eta``).\n\nNotes\n-----\nSet to zero for standard Stokes without augmentation.\nTypical values are ``O(10^6)`` times the characteristic viscosity.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1026,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the augmented Lagrangian penalty parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1041,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the Stokes solver.\n\nThe Stokes equations are quasi-static (no time derivative \u2202v/\u2202t),\nso there is no diffusive CFL constraint. The only relevant timescale\nis the advective one: how long it takes material to cross an element.\n\nThis method computes a per-element timestep:\n    dt_i = h_i / |v_i|\n\nwhere h_i is the element radius and v_i is the velocity at the element\ncentroid, then returns the global minimum. This is more accurate than\nusing global max velocity with global min element size, especially for\nnon-uniform meshes with spatially varying velocity.\n\nReturns:\n    Pint Quantity or float: The advective timestep with physical time units\n    if a model with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "Evaluate velocity at element centroids (consistent with AdvDiff)",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii",
      "Note: .magnitude returns physical units, which would be wrong here",
      "Plain UWQuantity without units context - use magnitude"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1249,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Elastic timestep from the constitutive model.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1256,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1414,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Smoothing regularization parameter for the projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1419,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the smoothing regularization parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1425,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Weighting function applied during projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1430,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the weighting function for the projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "projection_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1533,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for vector projection FEM assembly.",
    "harvested_comments": [
      "residual terms - defines the problem:",
      "solve for a best fit to the continuous mesh",
      "variable given the values in self.function",
      "F0 is left in place for the user to inject",
      "non-linear constraints if required"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1557,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Smoothing regularization parameter for the projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1562,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the smoothing regularization parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1568,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Divergence penalty parameter for incompressibility.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1573,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the divergence penalty parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1580,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Weighting function applied during projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1585,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the weighting function for the projection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1660,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Solve by projecting each tensor component sequentially.",
    "harvested_comments": [
      "Loop over the components of the tensor. If this is a symmetric",
      "tensor, we'll usually be given the 1d form to prevent duplication",
      "if self.t_field.sym_1d.shape != self.uw_function.shape:",
      "raise ValueError(",
      "\"Tensor shapes for uw_function and MeshVariable are not the same\""
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1692,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise misfit term for scalar subproblem.",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1706,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise smoothing flux term for scalar subproblem.",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1720,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Current scalar component function being projected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1725,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the scalar component function for current tensor element.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1906,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise source term including time derivative.",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1920,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise diffusive flux term (Adams-Moulton integration).",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "adv_diff_slcn_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1933,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for advection-diffusion FEM assembly.",
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1944,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the advection-diffusion equation.\n\nThe source :math:`f` appears on the right-hand side:\n\n.. math::\n    \\frac{\\partial u}{\\partial t} + \\mathbf{V} \\cdot \\nabla u\n    = \\nabla \\cdot (\\kappa \\nabla u) + f\n\nReturns\n-------\nsympy.Matrix\n    Source term expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1961,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the volumetric source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1967,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Velocity field for advection.\n\nThe advection velocity :math:`\\mathbf{V}` transports the scalar\nfield :math:`u`. Can be a MeshVariable or symbolic expression.\n\nReturns\n-------\nsympy.Matrix\n    Velocity vector expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1981,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the velocity function for advection.\n\nParameters:\n-----------\nvalue : uw.discretisation.MeshVariable or sympy.Basic\n    Velocity field as either a MeshVariable or sympy expression",
    "harvested_comments": [
      "Mark as needing setup when velocity changes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1997,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Timestep for time integration.\n\nThe timestep :math:`\\Delta t` controls the temporal discretization.\nFor explicit advection, this should satisfy the CFL condition:\n\n.. math::\n    \\Delta t < \\frac{h}{|\\mathbf{V}|}\n\nwhere :math:`h` is the element size and :math:`|\\mathbf{V}|` is the\nvelocity magnitude.\n\nReturns\n-------\nUWexpression\n    Timestep value.\n\nSee Also\n--------\nestimate_dt : Computes a stable timestep automatically.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2021,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the timestep (handles unit conversion if provided).",
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2066,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the advection-diffusion solver.\n\nThis is an implicit solver so the returned :math:`\\delta t` is the\nminimum of:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for diffusion across an element\n- :math:`\\delta t_{\\textrm{adv}}`: typical element-crossing time for a fluid parcel\n\nReturns\n-------\npint.Quantity or float\n    The recommended timestep with physical time units if a model\n    with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2198,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, _evalf = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing.",
      "Invalidate cached data views - PETSc may have replaced underlying buffers",
      "This ensures .data and .array properties return fresh data from PETSc"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2412,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise source term including time derivative.",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2426,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise diffusive flux term.",
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2440,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the diffusion equation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2445,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the volumetric source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2451,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Timestep for time integration.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2456,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the timestep (handles unit conversion if provided).",
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2501,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the diffusion solver.\n\nThis solver only has a diffusive component, so the returned\n:math:`\\delta t` is:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for diffusion across an element\n\nReturns\n-------\npint.Quantity or float\n    The diffusive timestep with physical time units if a model\n    with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2576,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, evalf: bool = False, _force_setup: bool = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "self._flux =  self.constitutive_model.flux.T",
      "self._flux_star =  self._flux.copy()",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2813,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise momentum source term (body force + inertia).",
    "harvested_comments": [
      "I think this should be bdf(1) ... the higher order",
      "terms are introduced through the adams_moulton fluxes"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2831,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise stress flux term (viscous + pressure).",
    "harvested_comments": [
      "We can flag to only do this if the constitutive model has been updated",
      "Is the else condition useful - other than to prevent a crash ?",
      "Yes, because then it can just live on the Stokes solver ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "PF0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2862,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Pointwise constraint term (continuity equation).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "navier_stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2877,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build residual terms for Navier-Stokes FEM assembly (deprecated).",
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p1 residual term"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2891,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Timestep for time integration.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2896,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the timestep value.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2902,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Fluid density.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2907,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the fluid density.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2913,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the momentum equation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2918,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the volumetric source term.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2924,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Velocity divergence: :math:`\\nabla \\cdot \\mathbf{u} = \\mathrm{tr}(\\dot{\\varepsilon})`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2931,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symmetric strain rate tensor (with 1/2 factor).\n\n.. math::\n    \\dot{\\varepsilon}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2941,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Time derivative operator for velocity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2946,
    "signature": "(self, DuDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DuDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the time derivative operator for velocity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2955,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Time derivative operator for stress flux.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2960,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constraint equation (typically incompressibility).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2965,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the constraint equation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2972,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Body force vector (e.g., gravity).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2977,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the body force vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2983,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Preconditioner for the Schur complement.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2988,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the Schur complement preconditioner.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2995,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Augmented Lagrangian penalty parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 3000,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the augmented Lagrangian penalty parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 3006,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, _evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 3072,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the Navier-Stokes solver.\n\nThis is an implicit solver, so the returned :math:`\\delta t` should\nbe interpreted as:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for vorticity diffusion across an element\n- :math:`\\delta t_{\\textrm{adv}}`: typical element-crossing time for a fluid parcel\n\nThe Navier-Stokes equations include momentum diffusion via kinematic\nviscosity :math:`\\nu = \\eta/\\rho`, so the diffusive timestep is computed\nfrom this quantity.\n\nReturns\n-------\ntuple\n    (:math:`\\delta t_{\\textrm{diff}}`, :math:`\\delta t_{\\textrm{adv}}`)",
    "harvested_comments": [
      "## required modules",
      "For Navier-Stokes, diffusivity is the kinematic viscosity: \u03bd = \u03b7/\u03c1",
      "Use the unified .K property from the constitutive model (returns viscosity)",
      "Evaluate the viscosity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 94,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Docstring (static)",
      "docstring = docstring.replace(\"$\", \"$\").replace(\"$\", \"$\")"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh_adapt_meshVar",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 508,
    "signature": "(mesh, meshVarH, metricVar, verbose = False, redistribute = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "meshVarH",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "metricVar",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "redistribute",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Create / use a field on the old mesh to hold the metric",
      "Perhaps that should be a user-definition"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "n",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 86,
    "signature": "def n(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ndim",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 90,
    "signature": "def ndim(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "kdtree_points",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 160,
    "signature": "def kdtree_points(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "find_closest_point",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 170,
    "signature": "def find_closest_point(self,\n                          const double[:,::1] coords not None:   numpy.ndarray):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "find_closest_n_points",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 215,
    "signature": "def find_closest_n_points(self,\n                  const int nCount                    :   numpy.int64,\n                  const double[: ,::1] coords not None:   numpy.ndarray):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "query",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 273,
    "signature": "def query(self,\n             coords,\n             k=1,\n             sqr_dists=True,\n    ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 336,
    "signature": "def rbf_interpolator_local(self,\n            coords,\n            data,\n            nnn = 4,\n            p=2,\n            verbose = False,\n        ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "old_rbf_interpolator_local_from_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 348,
    "signature": "def old_rbf_interpolator_local_from_kdtree(self,\n            coords,\n            data,\n            nnn = 4,\n            verbose = False,\n        ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "old_rbf_interpolator_local_to_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 409,
    "signature": "def old_rbf_interpolator_local_to_kdtree(self,\n                    coords,\n                    data,\n                    nnn = 4,\n                    verbose = False,\n                    weights = None\n                ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local_from_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 476,
    "signature": "def rbf_interpolator_local_from_kdtree(self, coords, data, nnn, p, verbose):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "k",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 111,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "k",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 115,
    "signature": "(inner_self, value)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "solver",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 150,
    "signature": "(self, solver_object)",
    "parameters": [
      {
        "name": "solver_object",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 300,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 304,
    "signature": "(inner_self, value: Union[float, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[float, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_0",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 434,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_0",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 438,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 443,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 447,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_max",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 452,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_max",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 456,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 461,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 465,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 470,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 474,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 479,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 483,
    "signature": "(inner_self, value: sympy.Function)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 488,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 492,
    "signature": "(inner_self, value: float)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "float",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "averaging_method",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 497,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "averaging_method",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 501,
    "signature": "(inner_self, value: str)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "materialIndex",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 507,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "materialIndex",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 511,
    "signature": "(inner_self, indexVar)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "indexVar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "error checking, only support IndexSwarmVariables for now"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "plastic_eff_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 519,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "## creates list of values that has the same length as the material index"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 607,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_0",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 861,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_0",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 865,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_modulus",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 870,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_modulus",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 874,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "dt_elastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 879,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "dt_elastic",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 883,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 888,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 892,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_max",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 897,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "shear_viscosity_max",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 901,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 906,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 910,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 915,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "yield_stress_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 919,
    "signature": "(inner_self, value: Union[list, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[list, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 924,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 928,
    "signature": "(inner_self, value: sympy.Function)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "stress_star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 933,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "stress_star",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 937,
    "signature": "(inner_self, value: sympy.Function)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "stress_star_star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 942,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "stress_star_star",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 946,
    "signature": "(inner_self, value: sympy.Function)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II_min",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 951,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "strainrate_inv_II_min",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 955,
    "signature": "(inner_self, value: float)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "float",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "averaging_method",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 960,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "averaging_method",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 964,
    "signature": "(inner_self, value: str)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "materialIndex",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 970,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "materialIndex",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 974,
    "signature": "(inner_self, indexVar)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "indexVar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "error checking, only support IndexSwarmVariables for now"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "t_relax",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 981,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "shear modulus defaults to infinity so t_relax goes to zero",
      "in the viscous limit"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "ve_effective_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 997,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "the dt_elastic defaults to infinity, t_relax to zero,",
      "so this should be well behaved in the viscous limit",
      "# The effective viscosity depends on the number of history terms",
      "## creates list of values that has the same length as the material index",
      "# The effective viscosity depends on the number of history terms"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "plastic_eff_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1091,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "+ inner_self.strainrate_inv_II_min",
      "## creates list of values that has the same length as the material index"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1180,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "detect if values we need are defined or are placeholder symbols"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "is_elastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1440,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "If any of these is not defined, elasticity is switched off"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "is_viscoplastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1455,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1502,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1506,
    "signature": "(inner_self, value: Union[float, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[float, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "eta_0",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1594,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "eta_0",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1598,
    "signature": "(inner_self, value: Union[float, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[float, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "eta_1",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1606,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "eta_1",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1610,
    "signature": "(inner_self, value: Union[float, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[float, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "director",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1618,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "director",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1622,
    "signature": "(inner_self, value: Union[sympy.Matrix, sympy.Function])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Union[sympy.Matrix, sympy.Function]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "petsc_fvm_get_min_radius",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 14,
    "signature": "def petsc_fvm_get_min_radius(mesh) -> float:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_fvm_get_local_cell_sizes",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 35,
    "signature": "def petsc_fvm_get_local_cell_sizes(mesh) -> np.array:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_create_submesh_from_label",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 61,
    "signature": "def petsc_dm_create_submesh_from_label(incoming_dm, boundary_label_name, boundary_label_value, marked_faces=True) -> float:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_find_labeled_points_local",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 85,
    "signature": "def petsc_dm_find_labeled_points_local(dm, label_name, sectionIndex=False, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_get_periodicity",
    "kind": "function",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 150,
    "signature": "def petsc_dm_get_periodicity(incoming_dm):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_set_periodicity",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 184,
    "signature": "def petsc_dm_set_periodicity(incoming_dm, maxCell, Lstart, L):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_vec_concatenate",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 221,
    "signature": "def petsc_vec_concatenate( inputVecs  ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_get_swarm_coord_name",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_discretisation.pyx",
    "line": 244,
    "signature": "def petsc_get_swarm_coord_name( sdm ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "has_meaningful_units",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 131,
    "signature": "def has_meaningful_units(u):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 247,
    "signature": "def evaluate(self) -> float:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 34,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "nuke_coords_and_rebuild",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1087,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)",
      "let's go ahead and do an initial projection from linear (the default)",
      "to linear. this really is a nothing operation, but a",
      "side effect of this operation is that coordinate DM DMField is",
      "converted to the required `PetscFE` type. this may become necessary"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "checkpoint_xdmf",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3124,
    "signature": "(filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Identify the mesh file. Use the",
      "# zeroth one if this option is turned off",
      "# Obtain the mesh information",
      "We only use a subset of the possible cell types",
      "# Create the header"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 61,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "load_from_h5_plex_vector",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1217,
    "signature": "(self, filename: str, data_name: Optional[str] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Ensure vectors are initialized"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "create_structure",
    "kind": "method",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 78,
    "signature": "def create_structure(self, mesh, np.ndarray[double, ndim=2] coords,\n                        np.ndarray[long, ndim=1] cells, int dofcount):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate",
    "kind": "method",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 144,
    "signature": "def evaluate(self, mesh, np.ndarray[double, ndim=2] outarray):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "fdiff",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 90,
    "signature": "def fdiff(self,argindex):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "global_evaluate_nd",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 288,
    "signature": "def global_evaluate_nd(   expr,\n                coords=None,\n                coord_sys=None,\n                other_arguments=None,\n                simplify=True,\n                verbose=False,\n                evalf=False,\n                rbf=False,\n                data_layout=None,\n                check_extrapolated=False,\n                force_l2=False,\n                smoothing=1e-6,\n            ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate_nd",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 662,
    "signature": "def evaluate_nd(   expr,\n                coords=None,\n                coord_sys=None,\n                other_arguments=None,\n                simplify=True,\n                verbose=False,\n                evalf=False,\n                rbf=False,\n                data_layout=None,\n                check_extrapolated=False,\n                force_l2=False,\n                smoothing=1e-6):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_interpolate",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 838,
    "signature": "def petsc_interpolate(   expr,\n                np.ndarray coords=None,\n                coord_sys=None,\n                mesh=None,\n                other_arguments=None,\n                simplify=True,\n                verbose=False, ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "interpolate_vars_on_mesh",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 977,
    "signature": "def interpolate_vars_on_mesh( varfns, np.ndarray coords ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rbf_evaluate",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 1119,
    "signature": "def rbf_evaluate(  expr,\n            coords=None,\n            coord_sys=None,\n            mesh=None,\n            other_arguments=None,\n            verbose=False,\n            simplify=True,):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "dm_swarm_get_migrate_type",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 1241,
    "signature": "def dm_swarm_get_migrate_type(swarm):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "dm_swarm_set_migrate_type",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 1253,
    "signature": "def dm_swarm_set_migrate_type(swarm, mtype:PETsc.DMSwarm.MigrateType):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "eval",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 58,
    "signature": "def eval(cls, *args ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "eval",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 76,
    "signature": "def eval(cls, *args ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "description",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 907,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "description",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 911,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local",
    "kind": "method",
    "file": "src/underworld3/kdtree.py",
    "line": 128,
    "signature": "(self, coords, data, nnn = 4, p = 2, verbose = False)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "data",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "4",
        "description": ""
      },
      {
        "name": "p",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "KDTree",
    "is_public": true
  },
  {
    "name": "write_proxy",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1827,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "if not proxied, nothing to do. return."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1838,
    "signature": "(self, data_filename: str, swarmID: str, data_name: str, index: int, outputPath = '')",
    "parameters": [
      {
        "name": "data_filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmID",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": null,
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "mesh.write_timestep( \"test\", meshUpdates=False, meshVars=[X], outputPath=\"\", index=0)",
      "swarm.write_timestep(\"test\", \"swarm\", swarmVars=[var], outputPath=\"\", index=0)",
      "check if swarmFilename exists",
      "easier to debug abs path",
      "## open up file with coords on all procs and open up data on all procs. May be problematic for large problems."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2043,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "visMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2085,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "clip_to_mesh",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2818,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "clip_to_mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2822,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3474,
    "signature": "(self, base_filename: str, swarm_id: str, index: int, outputPath: Optional[str] = '', migrate = True)",
    "parameters": [
      {
        "name": "base_filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarm_id",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "migrate",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "## open up file with coords on all procs",
      "We make it possible not to migrate the swarm because this",
      "will also delete points outside the mesh. We may not want to do",
      "that (either for debugging / visualisation, or when adapting the mesh)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4002,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = False)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Convert delta_t to model units if it has units",
      "This ensures consistent arithmetic: velocity is in model units, so time must be too",
      "X0 holds the particle location at the start of advection",
      "This is needed because the particles may be migrated off-proc",
      "during timestepping. Probably not needed - use global evaluation instead"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4397,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = True)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "NodalPointSwarm",
    "is_public": true
  },
  {
    "name": "use_nondimensional_scaling",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 268,
    "signature": "(enabled = True)",
    "parameters": [
      {
        "name": "enabled",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enable or disable non-dimensional scaling globally.\n\nWhen enabled, equations are scaled during unwrap() for better numerical\nconditioning. Variables with units and reference scales are automatically\nscaled (divided by their scaling_coefficient).\n\nThis is the ONLY way to control non-dimensional scaling - there are no\nother flags, solver settings, or context managers that affect this.\n\nParameters\n----------\nenabled : bool, default=True\n    True to enable non-dimensional scaling, False to disable\n\nNotes\n-----\n- Scaling coefficients are ALWAYS computed from model.set_reference_quantities()\n- This flag only controls whether those coefficients are APPLIED during unwrap()\n- Changing this flag requires recompiling solvers (set solver.is_setup=False)\n\nExamples\n--------\nSetup problem with reference quantities:\n\n>>> model = uw.Model()\n>>> model.set_reference_quantities(\n...     domain_depth=uw.quantity(100, \"km\"),\n...     temperature_diff=uw.quantity(1000, \"kelvin\")\n... )\n>>> T = uw.discretisation.MeshVariable('T', mesh, 1, units='kelvin')\n\nSolve with dimensional form (default):\n\n>>> uw.use_nondimensional_scaling(False)  # Default\n>>> poisson.solve()\n>>> u_dimensional = T.array.copy()\n\nSolve with non-dimensional form (for comparison):\n\n>>> uw.use_nondimensional_scaling(True)\n>>> poisson.is_setup = False  # Force recompilation with new scaling\n>>> poisson.solve()\n>>> u_nondimensional = T.array.copy()\n>>>\n>>> # Solutions should be identical\n>>> import numpy as np\n>>> assert np.allclose(u_dimensional, u_nondimensional)\n\nSee Also\n--------\nis_nondimensional_scaling_active : Check current scaling state\nmodel.set_reference_quantities : Set reference scales",
    "harvested_comments": [
      "Force recompilation with new scaling",
      "Solutions should be identical"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_nondimensional_scaling_active",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 327,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if non-dimensional scaling is currently enabled.\n\nReturns\n-------\nbool\n    True if non-dimensional scaling is active, False otherwise\n\nSee Also\n--------\nuse_nondimensional_scaling : Enable/disable scaling",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "nondimensional_scaling_context",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 344,
    "signature": "(enabled = True)",
    "parameters": [
      {
        "name": "enabled",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager to temporarily set non-dimensional scaling state.\n\nAutomatically restores the previous state when exiting the context.\nThis is useful for operations that need to temporarily work in\nnon-dimensional space (like semi-Lagrangian advection) without\naffecting the global state.\n\nParameters\n----------\nenabled : bool, default=True\n    True to enable non-dimensional scaling within context\n\nExamples\n--------\n>>> # Temporarily enable non-dimensional mode\n>>> with uw.nondimensional_scaling_context(True):\n...     # evaluate() returns non-dimensional results here\n...     velocity_nd = uw.function.evaluate(u.sym, coords)\n>>> # Original state restored automatically\n\nSee Also\n--------\nuse_nondimensional_scaling : Permanently set scaling state\nis_nondimensional_scaling_active : Check current state",
    "harvested_comments": [
      "Temporarily enable non-dimensional mode",
      "evaluate() returns non-dimensional results here",
      "Original state restored automatically"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "use_strict_units",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 392,
    "signature": "(enabled = True)",
    "parameters": [
      {
        "name": "enabled",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enable or disable strict units enforcement.\n\n**DEFAULT: ON** - Strict units mode is enabled by default to enforce best\npractices from the start. Variables with units REQUIRE reference quantities.\n\nWhen disabled, variables with units are allowed without reference quantities\nbut will get scaling_coefficient=1.0 and a warning. This \"half-way zone\"\nleads to poor numerical conditioning and silent errors.\n\n**Disabling strict mode is only recommended for:**\n- Expert users who understand the implications\n- Debugging specific issues\n- Legacy code migration (temporary)\n\nParameters\n----------\nenabled : bool, default=True\n    True to enforce strict units (DEFAULT - recommended)\n    False to allow units without reference quantities (expert/debugging only)\n\nExamples\n--------\nNormal usage (strict mode ON by default):\n\n>>> import underworld3 as uw\n>>> # Strict mode is ON by default - no need to enable\n>>>\n>>> # Set reference quantities FIRST:\n>>> model = uw.get_default_model()\n>>> model.set_reference_quantities(\n...     domain_depth=uw.quantity(1000, 'km'),\n...     plate_velocity=uw.quantity(5, 'cm/year')\n... )\n>>>\n>>> # Then create mesh and variables:\n>>> mesh = uw.meshing.StructuredQuadBox(elementRes=(4, 4))\n>>> v = uw.discretisation.MeshVariable(\"v\", mesh, 2, units=\"m/s\")  # \u2713 OK\n\nDisable for debugging (expert use only):\n\n>>> uw.use_strict_units(False)  # Expert/debugging only\n>>> mesh = uw.meshing.StructuredQuadBox(elementRes=(4, 4))\n>>> v = uw.discretisation.MeshVariable(\"v\", mesh, 2, units=\"m/s\")  # \u26a0\ufe0f Warning\n\nSee Also\n--------\nis_strict_units_active : Check current strict mode\nModel.set_reference_quantities : Set reference quantities",
    "harvested_comments": [
      "Strict mode is ON by default - no need to enable",
      "Set reference quantities FIRST:",
      "Then create mesh and variables:",
      "Expert/debugging only"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_strict_units_active",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 447,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if strict units enforcement is enabled.\n\nReturns\n-------\nbool\n    True if strict units mode is active, False otherwise\n\nSee Also\n--------\nuse_strict_units : Enable/disable strict units",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "unwrap",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 493,
    "signature": "(fn, keep_constants = True, return_self = True, apply_scaling = False)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "keep_constants",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "return_self",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "apply_scaling",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unwrap expressions with optional automatic scaling.\n\nParameters:\n-----------\nfn : expression\n    The expression to unwrap\nkeep_constants : bool, default=True\n    Whether to keep constants in the unwrapped expression\nreturn_self : bool, default=True\n    Whether to return self if no unwrapping is needed\napply_scaling : bool, default=False\n    Whether to automatically apply scale factors to variables with units\n\nExample:\n    model = uw.Model()\n    model.set_reference_quantities(mantle_temperature=1500*uw.scaling.units.K)\n\n    temperature = uw.discretisation.MeshVariable(\"T\", mesh, 1, units=\"K\")\n    expr = uw.function.expression(\"heat\", 2 * temperature.sym, \"heat equation\")\n\n    # Normal unwrap\n    result = uw.unwrap(expr)\n\n    # Unwrap with automatic scaling\n    scaled_result = uw.unwrap(expr, apply_scaling=True)",
    "harvested_comments": [
      "Normal unwrap",
      "Unwrap with automatic scaling"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "synchronised_array_update",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 542,
    "signature": "(context_info = 'user operations')",
    "parameters": [
      {
        "name": "context_info",
        "type_hint": null,
        "default": "'user operations'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager for synchronised array updates across multiple variables.\n\nBatches multiple array assignments together and defers PETSc synchronization\nuntil the end of the context, ensuring atomic updates and better performance.\n\nExample\n-------\nwith uw.synchronised_array_update():\n    velocity.array[...] = new_velocity_values\n    pressure.array[...] = new_pressure_values\n    temperature.array[...] = new_temperature_values\n# All arrays are synchronized here\n\nParameters\n----------\ncontext_info : str\n    Optional description of the update context for debugging\n\nReturns\n-------\nContext manager for delayed callback execution",
    "harvested_comments": [
      "All arrays are synchronized here"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_metric",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 88,
    "signature": "(mesh: 'Mesh', h_values: np.ndarray, name: str = None) -> 'MeshVariable'",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "h_values",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Create adaptation metric from target edge lengths.\n\nThis is the core utility that converts target edge lengths (h-field) to\nthe metric tensor format required by MMG/PETSc mesh adaptation.\n\nParameters\n----------\nmesh : Mesh\n    The mesh to create the metric on.\nh_values : np.ndarray\n    Array of target edge lengths at each mesh node. Shape should be\n    (n_nodes,) or (n_nodes, 1).\nname : str, optional\n    Name for the metric MeshVariable. Defaults to \"adaptation_metric\".\n\nReturns\n-------\nMeshVariable\n    Scalar MeshVariable containing metric values ready for mesh.adapt().\n\nNotes\n-----\n**Metric Tensor Mathematics**\n\nFor isotropic mesh adaptation, MMG/PETSc uses a metric tensor:\n\n.. math::\n\n    M = h^{-2} \\cdot I\n\nwhere :math:`h` is the target edge length and :math:`I` is the identity\nmatrix. This relationship is **dimension-independent** - the same formula\napplies in 2D and 3D.\n\nHigher metric values produce smaller elements. The adaptation algorithm\nseeks to make :math:`\\mathbf{e}^T M \\mathbf{e} = 1` for all edges.\n\nExamples\n--------\n>>> # Create metric from h-field computed elsewhere\n>>> h_field = compute_error_based_h(solution)  # User function\n>>> metric = uw.adaptivity.create_metric(mesh, h_field)\n>>> mesh.adapt(metric)\n\nSee Also\n--------\nmetric_from_gradient : Create metric from scalar field gradient.\nmetric_from_field : Create metric from indicator field.",
    "harvested_comments": [
      "Create metric from h-field computed elsewhere",
      "User function",
      "Ensure h_values is the right shape",
      "Create metric MeshVariable",
      "Convert to metric tensor: M = 1/h\u00b2 \u00d7 I (isotropic)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "metric_from_gradient",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 159,
    "signature": "(field: 'MeshVariable', h_min: float, h_max: float, gradient_min: float = None, gradient_max: float = None, profile: str = 'linear', name: str = None) -> 'MeshVariable'",
    "parameters": [
      {
        "name": "field",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      },
      {
        "name": "h_min",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "h_max",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "gradient_min",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "gradient_max",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "profile",
        "type_hint": "str",
        "default": "'linear'",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Create adaptation metric from gradient of a scalar field.\n\nProduces a metric that refines where gradients are steep (high |\u2207\u03c6|)\nand coarsens where the field is smooth (low |\u2207\u03c6|). This is the standard\napproach for error-driven or feature-based mesh adaptation.\n\nParameters\n----------\nfield : MeshVariable\n    Scalar MeshVariable whose gradient drives refinement. Must have\n    num_components=1.\nh_min : float\n    Target edge length where gradient is highest (finest mesh).\nh_max : float\n    Target edge length where gradient is lowest (coarsest mesh).\ngradient_min : float, optional\n    Gradient magnitude below this uses h_max. If None, uses 5th percentile\n    of |\u2207\u03c6| values.\ngradient_max : float, optional\n    Gradient magnitude above this uses h_min. If None, uses 95th percentile\n    of |\u2207\u03c6| values.\nprofile : str, optional\n    Interpolation profile: \"linear\", \"smoothstep\", or \"power\" (default: \"linear\").\n    - \"linear\": h varies linearly with gradient magnitude\n    - \"smoothstep\": smooth S-curve transition (C\u00b9 continuous)\n    - \"power\": h \u221d |\u2207\u03c6|^(-1/2), natural for error equidistribution\nname : str, optional\n    Name for the metric MeshVariable. Defaults to \"{field.name}_gradient_metric\".\n\nReturns\n-------\nMeshVariable\n    Scalar MeshVariable containing metric values ready for mesh.adapt().\n\nNotes\n-----\n**Gradient-Based Refinement Strategy**\n\nThe idea is that steep gradients indicate regions where the solution is\nchanging rapidly - these need finer resolution to capture accurately.\nSmooth regions can use coarser mesh without losing accuracy.\n\nThe mapping is:\n    - High |\u2207\u03c6| \u2192 small h \u2192 large metric \u2192 finer mesh\n    - Low |\u2207\u03c6| \u2192 large h \u2192 small metric \u2192 coarser mesh\n\n**Choosing h_min and h_max**\n\n- ``h_min`` controls finest resolution (where gradients are steepest)\n- ``h_max`` controls coarsest resolution (smooth regions)\n- Ratio ``h_max/h_min`` gives refinement factor (e.g., 10 = 10\u00d7 finer at peaks)\n\n**Auto-detection of Gradient Range**\n\nIf ``gradient_min`` and ``gradient_max`` are not specified, they are\ncomputed from the actual gradient field:\n    - gradient_min = 5th percentile of |\u2207\u03c6|\n    - gradient_max = 95th percentile of |\u2207\u03c6|\n\nThis ensures robust behavior even when gradient magnitudes span many\norders of magnitude.\n\n**Implementation Note**\n\nGradients are computed using the Clement interpolant via\n``uw.function.evaluate(field.sym.diff(x), coords)``. This uses PETSc's\n``DMPlexComputeGradientClementInterpolant`` which averages cell-wise\ngradients at vertices. The result is O(h) accurate and fast (no linear\nsolve required).\n\nExamples\n--------\n>>> # Refine based on temperature gradient\n>>> metric = uw.adaptivity.metric_from_gradient(\n...     T, h_min=0.005, h_max=0.05, profile=\"smoothstep\"\n... )\n>>> mesh.adapt(metric)\n\n>>> # Refine based on strain rate\n>>> # First compute strain rate magnitude as scalar field\n>>> SR = uw.discretisation.MeshVariable(\"SR\", mesh, 1)\n>>> # ... populate SR with strain rate second invariant ...\n>>> metric = uw.adaptivity.metric_from_gradient(SR, h_min=0.01, h_max=0.1)\n>>> mesh.adapt(metric)\n\nSee Also\n--------\ncreate_metric : Create metric from h-field directly.\nmetric_from_field : Create metric from indicator field (not gradient).",
    "harvested_comments": [
      "Refine based on temperature gradient",
      "Refine based on strain rate",
      "First compute strain rate magnitude as scalar field",
      "... populate SR with strain rate second invariant ...",
      "Compute gradient at mesh nodes using Clement interpolant"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "metric_from_field",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 319,
    "signature": "(indicator: 'MeshVariable', h_min: float, h_max: float, indicator_min: float = None, indicator_max: float = None, invert: bool = False, profile: str = 'linear', name: str = None) -> 'MeshVariable'",
    "parameters": [
      {
        "name": "indicator",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      },
      {
        "name": "h_min",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "h_max",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "indicator_min",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "indicator_max",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "invert",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "profile",
        "type_hint": "str",
        "default": "'linear'",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Create adaptation metric from an indicator field.\n\nMaps a scalar indicator field (e.g., error estimate, phase field, distance)\nto target edge lengths. This is more general than gradient-based adaptation -\nyou provide any field indicating where refinement is needed.\n\nParameters\n----------\nindicator : MeshVariable\n    Scalar field indicating where refinement is needed. Higher values\n    (by default) produce finer mesh.\nh_min : float\n    Target edge length where indicator is highest (finest mesh).\nh_max : float\n    Target edge length where indicator is lowest (coarsest mesh).\nindicator_min : float, optional\n    Indicator values below this use h_max. If None, uses field minimum.\nindicator_max : float, optional\n    Indicator values above this use h_min. If None, uses field maximum.\ninvert : bool, optional\n    If True, high indicator values \u2192 coarse mesh (swap h_min/h_max roles).\n    Useful when indicator represents \"smoothness\" rather than \"need for\n    refinement\". Default: False.\nprofile : str, optional\n    Interpolation profile: \"linear\" or \"smoothstep\". Default: \"linear\".\nname : str, optional\n    Name for the metric MeshVariable. Defaults to \"{indicator.name}_metric\".\n\nReturns\n-------\nMeshVariable\n    Scalar MeshVariable containing metric values ready for mesh.adapt().\n\nNotes\n-----\n**Use Cases**\n\n- **Error estimates**: Pass a computed error field; high error \u2192 fine mesh\n- **Phase fields**: Refine at interfaces (|\u03c6| near transition value)\n- **Distance fields**: Refine near surfaces (use with Surface.distance)\n- **Material boundaries**: Refine near composition gradients\n\n**Relationship to Surface.refinement_metric()**\n\nThis function is a general-purpose version. Surface.refinement_metric()\nis a specialized wrapper that computes the indicator from surface distance.\n\nExamples\n--------\n>>> # Refine based on error estimate\n>>> error = compute_error_estimate(solution)  # User function\n>>> metric = uw.adaptivity.metric_from_field(error, h_min=0.005, h_max=0.05)\n>>> mesh.adapt(metric)\n\n>>> # Refine at phase boundaries (\u03c6 transitions from 0 to 1)\n>>> # Want fine mesh where \u03c6 is near 0.5\n>>> phi_interface = 1 - 4 * (phi - 0.5)**2  # Peak at \u03c6=0.5\n>>> metric = uw.adaptivity.metric_from_field(phi_interface, h_min=0.01, h_max=0.1)\n\nSee Also\n--------\ncreate_metric : Create metric from h-field directly.\nmetric_from_gradient : Create metric from field gradient.",
    "harvested_comments": [
      "Refine based on error estimate",
      "User function",
      "Refine at phase boundaries (\u03c6 transitions from 0 to 1)",
      "Want fine mesh where \u03c6 is near 0.5",
      "Peak at \u03c6=0.5"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh2mesh_swarm",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 549,
    "signature": "(mesh0, mesh1, swarm0, swarmVarList, proxy = True, verbose = False)",
    "parameters": [
      {
        "name": "mesh0",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh1",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarm0",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarmVarList",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "proxy",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Warning [NSFW] - this uses EXPLICIT message passing calls to handle the\nsituation where a swarm cell_dm cannot find particles after mesh redistribution.\nThis occurs when particles are moved accross non-neighbouring processes or if the\nmesh neighbours are redistricted. This should be fixed at the DMSwarm / DMPlex level\nso this code is just a placeholder. Or maybe it's just user error !\n\nNotes 1: This copies a swarm from one mesh to another allowing for completely incommensurate\npartitionings. Warning: this is not always a 1->1 mapping. There may be some duplication and\nparticles may go missing along curved boundaries where the meshes do not necessarily overlap.\nThe same is true in the shadow spaces.\n\nNote 2: The swarm is \"adapted\" to the original mesh and will need\nto be repopulated on the new one, or data can be mapped to a purpose-built swarm.\n\nNote 3: We pass the data around as floats for the time being. Be careful when converting back.\n\nNote 4: set proxy=True to automatically generate proxy variables on mesh1 but consider skipping\nif the returned swarm is ephemeral",
    "harvested_comments": [
      "f\"{uw.mpi.rank} - A/local found: {n_found} v. not found: {n_not_found}\",",
      "flush=False,",
      "Let's sync the number of missing points by rank",
      "print(f\"rank: {uw.mpi.rank}, local_array size: {n_not_found}\")",
      "f\"{uw.mpi.rank} Sizes are: {global_sizes} Buffer size: {global_size}\","
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mesh2mesh_meshVariable",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 790,
    "signature": "(meshVar0, meshVar1, verbose = False)",
    "parameters": [
      {
        "name": "meshVar0",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "meshVar1",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Map a meshVar on mesh0 to a meshVar on mesh1 using\nan intermediary (temporary) swarm",
    "harvested_comments": [
      "1 Create a temporary swarm with a variable that matches meshVar0",
      "Maybe 3+ if var is higher order ??",
      "Set data on the swarmVar",
      "print(f\"Map data to swarm (rbf) - points = {tmp_swarm.dm.getSize()}\", flush=True)",
      "print(f\"Distribute swarm\", flush=True)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "build_index",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 155,
    "signature": "def build_index(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Build the kd-tree index.\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate_parameters",
    "kind": "function",
    "file": "src/underworld3/constitutive_models.py",
    "line": 60,
    "signature": "(symbol, input, default = None, allow_number = True, allow_expression = True)",
    "parameters": [
      {
        "name": "symbol",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "input",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "default",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "allow_number",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "allow_expression",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert input to a UWexpression for use in constitutive models.\n\nParameters\n----------\nsymbol : str\n    LaTeX symbol for display (e.g., r\"\\eta\" for viscosity).\ninput : various\n    Value to convert (UWexpression, UWQuantity, float, int, sympy expr).\ndefault : optional\n    Default value if input is None.\nallow_number : bool\n    If True, accept plain numbers (int/float).\nallow_expression : bool\n    If True, accept raw sympy expressions.\n\nReturns\n-------\nUWexpression or None\n    Wrapped expression, or None if conversion failed.",
    "harvested_comments": [
      "CRITICAL: Check for UWexpression FIRST, before checking sympy.Basic",
      "UWexpression inherits from sympy.Symbol, so it would match the Basic check",
      "and cause double-wrapping, losing unit information",
      "Already a UWexpression - return as-is, no wrapping needed",
      "Convert UWQuantity to UWexpression - this is the beautiful symmetry!"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_unique_symbol",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 229,
    "signature": "(self, base_symbol, value, description)",
    "parameters": [
      {
        "name": "base_symbol",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "description",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a unique symbol name for constitutive model parameters.\n\nSymbol naming priority:\n1. If material_name is set: \u03b7 \u2192 \u03b7_{material_name}\n2. Else if multiple instances of same class: \u03b7 \u2192 \u03b7^{(n)}\n3. Else: use base symbol as-is\n\nParameters\n----------\nbase_symbol : str\n    The base LaTeX symbol name (e.g., r\"\\eta\", r\"\\kappa\")\nvalue : float or expression\n    The initial value for the symbol\ndescription : str\n    Description of the parameter\n\nReturns\n-------\nUWexpression\n    Expression with unique symbol name",
    "harvested_comments": [
      "Priority 1: User-specified material name (subscript notation)",
      "Priority 2: Multiple instances of same class (superscript notation)",
      "Priority 3: First/only instance - clean symbol"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "Unknowns",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 275,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Reference to the solver's unknown fields.\n\nReturns\n-------\nUnknowns\n    Container holding the primary unknown field(s) (e.g., velocity,\n    pressure, temperature) that this constitutive model operates on.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "Unknowns",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 288,
    "signature": "(self, unknowns)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the solver unknowns (invalidates setup).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 295,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Primary constitutive property (viscosity, diffusivity, etc.).\n\nReturns\n-------\nUWexpression\n    The material property defining the flux-gradient relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 306,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The primary unknown field from the solver.\n\nReturns\n-------\nMeshVariable\n    The unknown field (velocity, temperature, etc.).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 317,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Gradient of the unknown field.\n\nFor scalar fields, this is a vector. For vector fields (velocity),\nthis is the velocity gradient tensor :math:`\\nabla \\mathbf{u}`.\n\nReturns\n-------\nsympy.Matrix\n    Gradient/Jacobian of the unknown field.",
    "harvested_comments": [
      "return mesh.vector.gradient(self.Unknowns.u.sym)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 333,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Material derivative operator for the unknown field.\n\nUsed in time-dependent problems to track Lagrangian or\nsemi-Lagrangian derivatives.\n\nReturns\n-------\nSemiLagrangian_DDt or Lagrangian_DDt or None\n    The material derivative operator, or None if not set.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 347,
    "signature": "(self, DuDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DuDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the material derivative operator for the unknown.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 357,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Material derivative operator for the flux history.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 363,
    "signature": "(self, DFDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DFDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the material derivative operator for flux history.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "C",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 375,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The matrix form of the constitutive model (the `c` property)\nthat relates fluxes to gradients.\nFor scalar problem, this is the matrix representation of the rank 2 tensor.\nFor vector problems, the Mandel form of the rank 4 tensor is returned.\nNOTE: this is an immutable object that is _a view_ of the underlying tensor",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "c",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 394,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The tensor form of the constitutive model that relates fluxes to gradients. In scalar\nproblems, `c` and `C` are equivalent (matrices), but in vector problems, `c` is a\nrank 4 tensor. NOTE: `c` is the canonical form of the constitutive relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 408,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux_1d",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 439,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. Returns the Voigt form that is flattened so as to\nmatch the PETSc field storage pattern for symmetric tensors.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 605,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 612,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective stiffness parameter (viscosity for viscous flow)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 617,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscous stress tensor: :math:`\\boldsymbol{\\tau} = 2\\eta\\dot{\\varepsilon}`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 646,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symmetric strain rate tensor (with 1/2 factor).\n\n.. math::\n    \\dot{\\varepsilon}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 851,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective viscosity with plastic yielding.\n\n.. math::\n    \\eta_{\\mathrm{eff}} = \\min\\left(\\eta_0, \\frac{\\tau_y}{2\\dot{\\varepsilon}_{II}}\\right)\n\nwhere :math:`\\dot{\\varepsilon}_{II}` is the second invariant of strain rate.",
    "harvested_comments": [
      "detect if values we need are defined or are placeholder symbols",
      "Don't put conditional behaviour in the constitutive law",
      "when it is not needed",
      "# Question is, will sympy reliably differentiate something",
      "# with so many Max / Min statements. The smooth version would"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "plastic_correction",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 901,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "Scaling factor to reduce stress to yield surface.\n\n.. math::\n    f = \\frac{\\tau_y}{\\tau_{II}}\n\nwhere :math:`\\tau_{II}` is the second invariant of deviatoric stress.\nReturns 1 if no yield stress is set.",
    "harvested_comments": [
      "The yield criterion in this case is assumed to be a bound on the second invariant of the stress"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "ve_effective_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1110,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Visco-elastic effective viscosity: :math:`\\eta_{\\mathrm{eff}} = \\frac{\\eta G \\Delta t}{\\eta + G \\Delta t}`.",
    "harvested_comments": [
      "the dt_elastic defaults to infinity, t_relax to zero,",
      "so this should be well behaved in the viscous limit",
      "Note, 1st order only here but we should add higher order versions of this",
      "1st Order version (default)",
      "2nd Order version (need to ask for this one)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "t_relax",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1150,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Maxwell relaxation time: :math:`t_{\\mathrm{relax}} = \\eta / G`.",
    "harvested_comments": [
      "shear modulus defaults to infinity so t_relax goes to zero",
      "in the viscous limit"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "order",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1161,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Time integration order (1 or 2).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "order",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1166,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the time integration order.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1174,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Previous timestep stress :math:`\\boldsymbol{\\sigma}^*` from history.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_2star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1182,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Second-order stress history :math:`\\boldsymbol{\\sigma}^{**}` (for 2nd order integration).",
    "harvested_comments": [
      "Check if we have enough information in DFDt to update _stress_star,",
      "otherwise it will be defined as zero"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "E_eff",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1196,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective strain rate including elastic contribution.\n\n.. math::\n    \\dot{\\varepsilon}_{\\mathrm{eff}} = \\dot{\\varepsilon} + \\frac{\\boldsymbol{\\sigma}^*}{2 G \\Delta t}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "E_eff_inv_II",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1227,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Second invariant of effective strain rate: :math:`\\dot{\\varepsilon}_{II} = \\sqrt{\\frac{1}{2}\\dot{\\varepsilon}_{ij}\\dot{\\varepsilon}_{ij}}`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1235,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective stiffness parameter (viscosity for visco-elastic-plastic flow).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1240,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective viscosity combining visco-elastic and plastic limits.\n\nReturns :math:`\\min(\\eta_{\\mathrm{ve}}, \\tau_y / 2\\dot{\\varepsilon}_{II})`.",
    "harvested_comments": [
      "detect if values we need are defined or are placeholder symbols",
      "# Do we want this to be an expression of its own ? If so, define above in __init__() and",
      "# make sure it is updated in this call, rather than being replaced.",
      "# Why is it p**2 here ?",
      "p = self.plastic_correction()"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "plastic_correction",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1318,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Scaling factor to reduce stress to yield surface: :math:`f = \\tau_y / \\tau_{II}`.",
    "harvested_comments": [
      "The yield criterion in this case is assumed to be a bound on the second invariant of the stress"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1376,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. For viscoelasticity, the",
    "harvested_comments": [
      "if self.is_viscoplastic:",
      "plastic_scale_factor = sympy.Max(1, self.plastic_overshoot())",
      "stress /= plastic_scale_factor"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_projection",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1392,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "viscoelastic stress projection (no plastic response)",
    "harvested_comments": [
      "This is a scalar viscosity ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1416,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "viscoelastic stress projection (no plastic response)",
    "harvested_comments": [
      "This is a scalar viscosity ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "is_elastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1513,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "True if elastic behavior is active (finite dt_elastic and shear_modulus).",
    "harvested_comments": [
      "If any of these is not defined, elasticity is switched off"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "is_viscoplastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1526,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "True if plastic yielding is active (finite yield_stress).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1610,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusivity :math:`\\kappa` (alias for ``diffusivity``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1615,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Scalar or tensor diffusivity :math:`\\kappa`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1684,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Diagonal diffusivity tensor.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1689,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set diffusivity from a vector of per-direction values.",
    "harvested_comments": [
      "Accept shape (dim, 1) or (1, dim)",
      "Validate each component using validate_parameters",
      "Store the validated diffusivity as a diagonal matrix"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1759,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "User-defined flux expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1764,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the flux expression (must be a vector of length dim).",
    "harvested_comments": [
      "Accept shape (dim, 1) or (1, dim)",
      "Flatten and validate"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1788,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The user-defined flux expression.",
    "harvested_comments": [
      "if self._flux is None:",
      "raise RuntimeError(\"Flux expression has not been set.\")"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GenericFluxModel",
    "is_public": true
  },
  {
    "name": "s",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1890,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Body force vector (e.g., gravitational source term :math:`\\rho \\mathbf{g}`).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "s",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1895,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the body force vector.",
    "harvested_comments": [
      "Update expression content in-place to preserve object identity",
      "Cannot use validate_parameters() as it doesn't handle matrices",
      "UWexpression.sym setter handles sympy.Matrix directly"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1904,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Permeability :math:`\\kappa` [m\u00b2] - the primary constitutive parameter.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1947,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2052,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2059,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2066,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symmetric strain rate tensor (with 1/2 factor).\n\n.. math::\n    \\dot{\\varepsilon}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2265,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Compute level-set weighted average of constituent model fluxes.\n\nCRITICAL: This composite flux becomes the stress history that\nall constituent models (including elastic ones) will read via\n``DFDt.psi_star[0]`` in the next time step.",
    "harvested_comments": [
      "Get reference flux shape from first model",
      "Compute normalization factor to ensure partition of unity",
      "Get normalized level-set function for material i",
      "Get flux contribution from constituent model i",
      "Add weighted contribution to composite flux"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2305,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective stiffness using level-set weighted harmonic average.\n\nFor composite materials, harmonic averaging gives the correct effective\nstiffness for preconditioning: 1/K_eff = \u03a3(\u03c6\u1d62 * (1/K\u1d62)) / \u03a3(\u03c6\u1d62)",
    "harvested_comments": [
      "Harmonic average: 1/K_eff = \u03a3(\u03c6\u1d62 * (1/K\u1d62)) / \u03a3(\u03c6\u1d62)",
      "Compute normalization factor to ensure partition of unity",
      "Get normalized level-set function for material i",
      "Get stiffness from constituent model i",
      "Add weighted contribution to inverse stiffness"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": true
  },
  {
    "name": "solver",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 144,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Each constitutive relationship can, optionally, be associated with one solver object.\nand a solver object _requires_ a constitive relationship to be defined.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "C",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 159,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The matrix form of the constitutive model (the `c` property)\nthat relates fluxes to gradients.\nFor scalar problem, this is the matrix representation of the rank 2 tensor.\nFor vector problems, the Mandel form of the rank 4 tensor is returned.\nNOTE: this is an immutable object that is _a view_ of the underlying tensor",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "c",
    "kind": "property",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 176,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The tensor form of the constitutive model that relates fluxes to gradients. In scalar\nproblems, `c` and `C` are equivalent (matrices), but in vector problems, `c` is a\nrank 4 tensor. NOTE: `c` is the canonical form of the constitutive relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 184,
    "signature": "(self, ddu: sympy.Matrix = None, ddu_dt: sympy.Matrix = None, u: sympy.Matrix = None, u_dt: sympy.Matrix = None)",
    "parameters": [
      {
        "name": "ddu",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "ddu_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [
      "may be needed in the case of cylindrical / spherical",
      "tensor multiplication"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux_1d",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 210,
    "signature": "(self, ddu: sympy.Matrix = None, ddu_dt: sympy.Matrix = None, u: sympy.Matrix = None, u_dt: sympy.Matrix = None)",
    "parameters": [
      {
        "name": "ddu",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "ddu_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. Returns the Voigt form that is flattened so as to\nmatch the PETSc field storage pattern for symmetric tensors.",
    "harvested_comments": [
      "may be needed in the case of cylindrical / spherical"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1328,
    "signature": "(self, ddu: sympy.Matrix = None, ddu_dt: sympy.Matrix = None, u: sympy.Matrix = None, u_dt: sympy.Matrix = None)",
    "parameters": [
      {
        "name": "ddu",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "ddu_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      },
      {
        "name": "u_dt",
        "type_hint": "sympy.Matrix",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. For viscoelasticity, the",
    "harvested_comments": [
      "may be needed in the case of cylindrical / spherical",
      "tensor multiplication",
      "Now add in the stress history. In the",
      "viscous limit, this term is not well behaved",
      "and we need to check that"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 166,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic representation for JIT/symbolic operations.\n\nFor UWCoordinate (which IS a BaseScalar), this returns self.\nThis maintains API compatibility with code that accesses .sym",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 176,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate values from mesh.\n\nReturns dimensional values if mesh has units, ND otherwise.\nMirrors MeshVariable.data pattern.\n\nReturns\n-------\nnumpy.ndarray\n    Coordinate values for this axis at all mesh nodes",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 193,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Parent mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": true
  },
  {
    "name": "axis",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 198,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Axis index (0=x, 1=y, 2=z).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 208,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Units of this coordinate, delegated from the original BaseScalar.\n\nThe mesh's patch_coordinate_units() sets ._units on mesh.N.x, mesh.N.y, etc.\nUWCoordinate wraps these, so we delegate to get the units.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": true
  },
  {
    "name": "uwdiff",
    "kind": "function",
    "file": "src/underworld3/coordinates.py",
    "line": 260,
    "signature": "(expr, *symbols)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "*symbols",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Differentiate an expression with respect to coordinates.\n\n.. deprecated:: December 2025\n    Since UWCoordinate now subclasses BaseScalar with proper __eq__/__hash__,\n    you can use ``sympy.diff(expr, y)`` directly. This function is kept for\n    backward compatibility but simply delegates to sympy.diff().\n\nParameters\n----------\nexpr : sympy.Expr\n    The expression to differentiate\nsymbols : UWCoordinate or sympy.Symbol\n    The variables to differentiate with respect to\n\nReturns\n-------\nsympy.Expr\n    The derivative\n\nExamples\n--------\n>>> x, y = mesh.X  # UWCoordinates\n>>> v = mesh_variable  # MeshVariable\n>>> # Both now work identically:\n>>> dv_dy = sympy.diff(v.sym[0], y)  # Preferred\n>>> dv_dy = uw.uwdiff(v.sym[0], y)   # Backward compatible",
    "harvested_comments": [
      "UWCoordinates",
      "MeshVariable",
      "Both now work identically:",
      "Backward compatible"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "geographic_to_cartesian",
    "kind": "function",
    "file": "src/underworld3/coordinates.py",
    "line": 385,
    "signature": "(lon_deg, lat_deg, depth_km, a, b)",
    "parameters": [
      {
        "name": "lon_deg",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "lat_deg",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "depth_km",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "a",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "b",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert geographic coordinates to Cartesian coordinates.\n\nUses geodetic latitude (perpendicular to ellipsoid surface).\n\nParameters\n----------\nlon_deg : float or array\n    Longitude in degrees East (-180 to 180 or 0 to 360)\nlat_deg : float or array\n    Latitude in degrees North (-90 to 90), geodetic\ndepth_km : float or array\n    Depth below ellipsoid surface in km (positive downward)\na : float\n    Semi-major axis (equatorial radius) in km\nb : float\n    Semi-minor axis (polar radius) in km\n\nReturns\n-------\nx, y, z : float or array\n    Cartesian coordinates in km",
    "harvested_comments": [
      "Convert to radians",
      "Eccentricity squared",
      "Prime vertical radius of curvature at this latitude",
      "Height above ellipsoid (negative of depth)",
      "Cartesian coordinates"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "cartesian_to_geographic",
    "kind": "function",
    "file": "src/underworld3/coordinates.py",
    "line": 430,
    "signature": "(x, y, z, a, b, max_iterations = 10, tolerance = 1e-12)",
    "parameters": [
      {
        "name": "x",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "y",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "z",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "a",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "b",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "max_iterations",
        "type_hint": null,
        "default": "10",
        "description": ""
      },
      {
        "name": "tolerance",
        "type_hint": null,
        "default": "1e-12",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Cartesian coordinates to geographic coordinates.\n\nUses iterative algorithm (Bowring's method) for geodetic latitude.\n\nParameters\n----------\nx, y, z : float or array\n    Cartesian coordinates in km\na : float\n    Semi-major axis (equatorial radius) in km\nb : float\n    Semi-minor axis (polar radius) in km\nmax_iterations : int, optional\n    Maximum iterations for latitude convergence (default: 10)\ntolerance : float, optional\n    Convergence tolerance in radians (default: 1e-12)\n\nReturns\n-------\nlon_deg, lat_deg, depth_km : float or array\n    Geographic coordinates:\n    - lon_deg: Longitude in degrees East\n    - lat_deg: Latitude in degrees North (geodetic)\n    - depth_km: Depth below ellipsoid surface in km",
    "harvested_comments": [
      "Longitude is straightforward",
      "Latitude requires iteration (Bowring's method for geodetic latitude)",
      "Initial guess for latitude (geocentric)",
      "Iterate to converge on geodetic latitude",
      "Check convergence"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "lon",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 585,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Longitude in degrees East (-180 to 180).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "lat",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 591,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Geodetic latitude in degrees North (-90 to 90).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "depth",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 597,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Depth below ellipsoid surface (positive downward).\n\nReturns nondimensional values when units are active, km otherwise.\nUse with units system for proper dimensional output.",
    "harvested_comments": [
      "Return with units if available",
      "Check if units system is active for wrapping",
      "Get reference length to dimensionalize",
      "Depth in km = nondimensional * L_ref"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 624,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Geographic coordinates as (N, 3) array: [lon, lat, depth].\n\nReturns mesh node coordinates in geographic form, matching the\nlayout of `mesh.X.coords` but in (longitude, latitude, depth) format.\n\nReturns\n-------\nnumpy.ndarray\n    Shape (N, 3) array where columns are:\n    - Column 0: Longitude (degrees East, -180 to 180)\n    - Column 1: Latitude (degrees North, -90 to 90)\n    - Column 2: Depth (km below ellipsoid surface, positive down)\n\nExamples\n--------\n>>> geo_coords = mesh.CoordinateSystem.geo.coords\n>>> print(f\"Node 0: lon={geo_coords[0,0]:.2f}\u00b0, lat={geo_coords[0,1]:.2f}\u00b0\")\n\nSee Also\n--------\nmesh.X.coords : Cartesian coordinates (x, y, z)\nlon, lat, depth : Individual coordinate arrays",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_WE",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 668,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "West to East unit vector (primary name, positive East).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_SN",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 673,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "South to North unit vector (primary name, positive North).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_down",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 678,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Downward unit vector (primary name, positive into planet).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_east",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 685,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Eastward unit vector (directional alias for unit_WE).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_west",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 690,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Westward unit vector (opposite of unit_WE).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_north",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 695,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Northward unit vector (directional alias for unit_SN).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_south",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 700,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Southward unit vector (opposite of unit_SN).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_up",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 705,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Upward unit vector (opposite of unit_down).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_lon",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 712,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Longitude direction unit vector (coordinate alias for unit_WE).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_lat",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 717,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Latitude direction unit vector (coordinate alias for unit_SN).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_depth",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 722,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Depth direction unit vector (coordinate alias for unit_down).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "to_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 728,
    "signature": "(self, lon, lat, depth)",
    "parameters": [
      {
        "name": "lon",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "lat",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "depth",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert geographic coordinates to Cartesian (x, y, z).\n\nUses the mesh's ellipsoid parameters automatically.\nWhen units are active, depth should be nondimensional and returns\nnondimensional Cartesian coordinates.\n\nParameters\n----------\nlon : float or array_like\n    Longitude in degrees East (-180 to 180)\nlat : float or array_like\n    Geodetic latitude in degrees North (-90 to 90)\ndepth : float or array_like\n    Depth below ellipsoid surface (nondimensional if units active, km otherwise)\n\nReturns\n-------\ntuple\n    (x, y, z) coordinates (nondimensional if units active, km otherwise)\n\nExamples\n--------\n>>> # Import external data in geographic coordinates\n>>> tomo_lon = np.array([136.0, 136.5, 137.0])\n>>> tomo_lat = np.array([-34.0, -33.5, -33.0])\n>>> tomo_depth = np.array([10.0, 20.0, 30.0])  # km or nondimensional\n>>> x, y, z = mesh.geo.to_cartesian(tomo_lon, tomo_lat, tomo_depth)",
    "harvested_comments": [
      "Import external data in geographic coordinates",
      "km or nondimensional",
      "Use nondimensional ellipsoid if available"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "from_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 768,
    "signature": "(self, x, y, z)",
    "parameters": [
      {
        "name": "x",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "y",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "z",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Cartesian coordinates to geographic (lon, lat, depth).\n\nUses the mesh's ellipsoid parameters automatically.\nWhen units are active, coordinates should be nondimensional.\n\nParameters\n----------\nx : float or array_like\n    X coordinate (nondimensional if units active, km otherwise)\ny : float or array_like\n    Y coordinate\nz : float or array_like\n    Z coordinate\n\nReturns\n-------\ntuple\n    (lon, lat, depth) where:\n    - lon: Longitude in degrees East (-180 to 180)\n    - lat: Geodetic latitude in degrees North (-90 to 90)\n    - depth: Depth (nondimensional if units active, km otherwise)\n\nExamples\n--------\n>>> # Convert mesh points to geographic for comparison with data\n>>> x, y, z = mesh.data[:, 0], mesh.data[:, 1], mesh.data[:, 2]\n>>> lon, lat, depth = mesh.geo.from_cartesian(x, y, z)",
    "harvested_comments": [
      "Convert mesh points to geographic for comparison with data",
      "Use nondimensional ellipsoid if available"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "points_to_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 808,
    "signature": "(self, points_geo)",
    "parameters": [
      {
        "name": "points_geo",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array of geographic points to Cartesian coordinates.\n\nConvenience method for importing external data.\n\nParameters\n----------\npoints_geo : array_like\n    Array of shape (N, 3) with columns [lon, lat, depth]\n    - lon: Longitude in degrees East\n    - lat: Geodetic latitude in degrees North\n    - depth: Depth in km below surface\n\nReturns\n-------\nndarray\n    Array of shape (N, 3) with columns [x, y, z] in km\n\nExamples\n--------\n>>> # Import seismicity catalog\n>>> eq_llz = np.loadtxt(\"earthquakes.csv\", delimiter=\",\")  # [lon, lat, depth]\n>>> eq_xyz = mesh.geo.points_to_cartesian(eq_llz)\n>>> # Now use with KDTree or swarm.add_particles_with_coordinates()",
    "harvested_comments": [
      "Import seismicity catalog",
      "[lon, lat, depth]",
      "Now use with KDTree or swarm.add_particles_with_coordinates()"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "points_from_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 840,
    "signature": "(self, points_xyz)",
    "parameters": [
      {
        "name": "points_xyz",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array of Cartesian points to geographic coordinates.\n\nParameters\n----------\npoints_xyz : array_like\n    Array of shape (N, 3) with columns [x, y, z] in km\n\nReturns\n-------\nndarray\n    Array of shape (N, 3) with columns [lon, lat, depth]\n\nExamples\n--------\n>>> # Export mesh coordinates to geographic\n>>> mesh_xyz = mesh.data  # or mesh.CoordinateSystem.coords\n>>> mesh_llz = mesh.geo.points_from_cartesian(mesh_xyz)",
    "harvested_comments": [
      "Export mesh coordinates to geographic",
      "or mesh.CoordinateSystem.coords"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 881,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display a formatted summary of available properties and methods.\n\nThis method prints a helpful guide to the geographic coordinate system,\nshowing all available data arrays, symbolic coordinates, unit vectors,\nand conversion methods.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "r",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1038,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Radial distance from origin.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "theta",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1044,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Colatitude in radians (0 at north pole, \u03c0 at south pole).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "phi",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1050,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Longitude/azimuth in radians (-\u03c0 to \u03c0). Only available for 3D meshes.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1061,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Spherical/polar coordinates as array.\n\nReturns mesh node coordinates in spherical/polar form:\n- 3D: (N, 3) array [r, \u03b8, \u03c6]\n- 2D: (N, 2) array [r, \u03b8]\n\nReturns\n-------\nnumpy.ndarray\n    For 3D (spherical): Shape (N, 3) array where columns are:\n\n    - Column 0: Radius (same units as mesh)\n    - Column 1: Colatitude \u03b8 in radians (0 at north pole)\n    - Column 2: Longitude \u03c6 in radians (-\u03c0 to \u03c0)\n\n    For 2D (polar): Shape (N, 2) array where columns are:\n\n    - Column 0: Radius (same units as mesh)\n    - Column 1: Polar angle \u03b8 in radians\n\nExamples\n--------\n>>> sph_coords = mesh.X.spherical.coords\n>>> print(f\"Node 0: r={sph_coords[0,0]:.3f}, \u03b8={np.degrees(sph_coords[0,1]):.1f}\u00b0\")\n\nSee Also\n--------\nmesh.X.coords : Cartesian coordinates (x, y) or (x, y, z)\nr, theta, phi : Individual coordinate arrays",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "r_sym",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1121,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic radial coordinate.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "theta_sym",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1126,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic polar/colatitude coordinate.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "phi_sym",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1131,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic longitude coordinate (3D only).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_r",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1143,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Radial unit vector (outward from origin).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_theta",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1148,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Tangential unit vector (direction of increasing \u03b8).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_phi",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1153,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Azimuthal unit vector (eastward, direction of increasing \u03c6). 3D only.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_radial",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1165,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Alias for unit_r.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_outward",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1170,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Outward radial unit vector (alias for unit_r).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "unit_inward",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1175,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Inward radial unit vector (opposite of unit_r).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "to_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1181,
    "signature": "(self, r, theta, phi)",
    "parameters": [
      {
        "name": "r",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "phi",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert spherical coordinates to Cartesian (x, y, z).\n\nParameters\n----------\nr : float or array_like\n    Radial distance\ntheta : float or array_like\n    Colatitude in radians (0 at north pole)\nphi : float or array_like\n    Longitude in radians\n\nReturns\n-------\ntuple\n    (x, y, z) Cartesian coordinates",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "from_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1209,
    "signature": "(self, x, y, z)",
    "parameters": [
      {
        "name": "x",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "y",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "z",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Cartesian coordinates to spherical (r, \u03b8, \u03c6).\n\nParameters\n----------\nx : float or array_like\n    X coordinate\ny : float or array_like\n    Y coordinate\nz : float or array_like\n    Z coordinate\n\nReturns\n-------\ntuple\n    (r, theta, phi) where:\n\n    - r: Radial distance\n    - theta: Colatitude in radians (0 at north pole)\n    - phi: Longitude in radians (-\u03c0 to \u03c0)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "points_to_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1241,
    "signature": "(self, points_sph)",
    "parameters": [
      {
        "name": "points_sph",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array of spherical points to Cartesian coordinates.\n\nParameters\n----------\npoints_sph : array_like\n    Array of shape (N, 3) with columns [r, theta, phi]\n\nReturns\n-------\nndarray\n    Array of shape (N, 3) with columns [x, y, z]",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "points_from_cartesian",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1261,
    "signature": "(self, points_xyz)",
    "parameters": [
      {
        "name": "points_xyz",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array of Cartesian points to spherical coordinates.\n\nParameters\n----------\npoints_xyz : array_like\n    Array of shape (N, 3) with columns [x, y, z]\n\nReturns\n-------\nndarray\n    Array of shape (N, 3) with columns [r, theta, phi]",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1292,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display a formatted summary of available properties and methods.\n\nThis method prints a helpful guide to the spherical coordinate system,\nshowing all available data arrays, symbolic coordinates, unit vectors,\nand conversion methods.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1874,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate data array in physical units.\n\nReturns the mesh node coordinates, applying scaling if the mesh has\nreference quantities set. When mesh.units is specified, returns a\nUnitAwareArray.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Node coordinates",
    "harvested_comments": [
      "Apply scaling to convert model coordinates to physical coordinates",
      "Wrap with unit-aware array if units are specified",
      "Coordinates are scaled to SI base units (meters), not the reference unit",
      "The scale factor (self._length_scale) converts dimensionless (0-1) to meters",
      "So we label the result as \"meter\" regardless of the original reference unit"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1906,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate units.\n\nReturns the units for the coordinate system. This is the same as mesh.units\nand indicates what physical units the coordinates are expressed in.\n\nReturns:\n    str or None: Coordinate units (e.g., 'km', 'm', 'degrees')",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "with_units",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1919,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate symbols with unit information.\n\nDEPRECATED (2025-11-26): Following the Transparent Container Principle,\nthis now returns raw coordinate symbols. Units are derived on demand via\nuw.get_units() which finds the _units attribute on coordinate atoms.\n\nExamples:\n    >>> x, y = mesh.X.with_units  # Same as mesh.X[0], mesh.X[1]\n    >>> area = x * y  # Raw SymPy Mul; uw.get_units(area) \u2192 km**2\n    >>> uw.get_units(x)  # \u2192 kilometer (derived from _units attribute)\n\nReturns:\n    tuple: Coordinate symbols (x, y) or (x, y, z)",
    "harvested_comments": [
      "Same as mesh.X[0], mesh.X[1]",
      "Raw SymPy Mul; uw.get_units(area) \u2192 km**2",
      "\u2192 kilometer (derived from _units attribute)",
      "TRANSPARENT CONTAINER PRINCIPLE (2025-11-26):",
      "Just return raw coordinates. They have _units attributes from patching,"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "shape",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1941,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Shape of the symbolic coordinate matrix.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "is_symbol",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1967,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy type check - CoordinateSystem contains symbols but is not itself a symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "is_Matrix",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1972,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy type check - CoordinateSystem behaves like a Matrix.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "is_scalar",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1977,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy type check - CoordinateSystem is a Matrix, not a scalar.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "is_number",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1982,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy type check - CoordinateSystem is not a number.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "is_commutative",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 1987,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy type check - delegate to underlying matrix.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "X",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2067,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Cartesian coordinates as UWCoordinate objects (user-facing symbolic).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "x",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2072,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Alias for natural coordinates (lowercase convention).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "N",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2077,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Raw BaseScalar coordinates for derivatives and JIT compilation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "R",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2082,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Natural (curvilinear) coordinates :math:`(r, \\theta, \\phi)` or geographic.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "r",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2087,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Symbolic natural coordinate variables (for mathematical expressions).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "xR",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2092,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Alias for ``R`` (backward compatibility).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "geo",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2097,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Geographic coordinates for GEOGRAPHIC meshes.\n\nProvides access to longitude, latitude, depth coordinates\nand geographic basis vectors on ellipsoidal (WGS84) meshes.\n\nReturns\n-------\nGeographicCoordinateAccessor\n    Object with .lon, .lat, .depth, .coords, unit vectors, etc.\n    Use .view() for a complete summary of available properties.\n\nRaises\n------\nAttributeError\n    If coordinate system is not GEOGRAPHIC. The error message\n    indicates what coordinate system IS available for this mesh.\n\nExamples\n--------\n>>> lon = mesh.X.geo.lon         # Longitude data array\n>>> geo_coords = mesh.X.geo.coords  # (N, 3) array [lon, lat, depth]\n>>> mesh.X.geo.view()            # Show all available properties",
    "harvested_comments": [
      "Longitude data array",
      "(N, 3) array [lon, lat, depth]",
      "Show all available properties",
      "Provide helpful error message indicating what IS available"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "spherical",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2148,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Spherical/polar coordinates for SPHERICAL and CYLINDRICAL2D meshes.\n\nProvides access to radius and angle coordinates, plus basis vectors:\n- 3D (SPHERICAL): r, \u03b8 (colatitude), \u03c6 (longitude)\n- 2D (CYLINDRICAL2D/Annulus): r, \u03b8 (polar angle)\n\nReturns\n-------\nSphericalCoordinateAccessor\n    Object with .r, .theta, .coords, unit vectors, etc.\n    For 3D also .phi. Use .view() for a complete summary.\n\nRaises\n------\nAttributeError\n    If coordinate system is not SPHERICAL or CYLINDRICAL2D.\n    The error message indicates what IS available for this mesh.\n\nExamples\n--------\n>>> r = mesh.X.spherical.r           # Radius data array\n>>> sph_coords = mesh.X.spherical.coords  # (N, 2) or (N, 3) array\n>>> mesh.X.spherical.view()          # Show all available properties",
    "harvested_comments": [
      "Radius data array",
      "(N, 2) or (N, 3) array",
      "Show all available properties",
      "Provide helpful error message indicating what IS available"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "rRotN",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2200,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Rotation matrix from Cartesian (N) to natural (R) coordinates.\n\nTransforms vectors from Cartesian basis to the local curvilinear basis.\nFor spherical: rows are :math:`(\\hat{r}, \\hat{\\theta}, \\hat{\\phi})`.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "xRotN",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2209,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Rotation matrix from Cartesian (N) to Cartesian (X) - typically identity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "geoRotN",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2214,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Ellipsoidal rotation matrix for GEOGRAPHIC coordinate systems.\n\nTransforms Cartesian vectors to the local geographic frame:\n- Row 0: geodetic up (perpendicular to ellipsoid surface)\n- Row 1: north (meridional, along ellipsoid surface)\n- Row 2: east (azimuthal, along ellipsoid surface)\n\nThis is the ellipsoidal equivalent of ``rRotN`` for spherical coordinates.\nFor a sphere (a=b), this reduces to the spherical rotation matrix.\n\nFor an ellipsoid, the geodetic normal differs from the radial direction\nby up to ~10 arcminutes at mid-latitudes, which is significant for\nregional models at scales of 10-100 km.\n\nReturns\n-------\nsympy.Matrix\n    3\u00d73 rotation matrix, or None if not GEOGRAPHIC coordinate system.\n\nExamples\n--------\nTransform a Cartesian velocity to geographic components:\n\n>>> v_cartesian = sympy.Matrix([[vx, vy, vz]])\n>>> v_geo = mesh.CoordinateSystem.geoRotN * v_cartesian.T\n>>> v_up, v_north, v_east = v_geo[0], v_geo[1], v_geo[2]",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_e_0",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2248,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "First natural basis vector (radial :math:`\\hat{r}` for curvilinear).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_e_1",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2253,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Second natural basis vector (:math:`\\hat{\\theta}` for curvilinear).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_e_2",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2258,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Third natural basis vector (:math:`\\hat{\\phi}` for spherical, None for 2D).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_i",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2266,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Cartesian unit vector :math:`\\hat{i}` (x-direction).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_j",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2271,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Cartesian unit vector :math:`\\hat{j}` (y-direction).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_k",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2276,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Cartesian unit vector :math:`\\hat{k}` (z-direction, None for 2D).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_ijk",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2283,
    "signature": "(self, dirn) -> sympy.Matrix",
    "parameters": [
      {
        "name": "dirn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "sympy.Matrix",
    "existing_docstring": "Return Cartesian unit vector for direction index (0=i, 1=j, 2=k).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_vertical",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2292,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Primary vertical direction for this coordinate system",
    "harvested_comments": [
      "In Cartesian, vertical is the last coordinate direction",
      "y-direction in 2D",
      "z-direction in 3D",
      "In cylindrical 2D, \"vertical\" is ambiguous but typically means Cartesian y",
      "In spherical, \"vertical\" typically means radial outward"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_horizontal",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2312,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Primary horizontal direction for this coordinate system",
    "harvested_comments": [
      "x-direction",
      "In cylindrical, horizontal could be radial or tangential - choose radial as primary",
      "radial direction",
      "In spherical, horizontal is typically tangential (theta direction)",
      "meridional direction"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_horizontal_0",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2328,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "First horizontal direction (alias for unit_horizontal)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_horizontal_1",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2333,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Second horizontal direction (for 3D systems)",
    "harvested_comments": [
      "y-direction in 3D Cartesian",
      "tangential direction",
      "azimuthal direction"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_radial",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2350,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Radial direction (for cylindrical/spherical coordinate systems)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_tangential",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2365,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Tangential direction (for cylindrical coordinate systems)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_meridional",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2378,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Meridional direction (for spherical coordinate systems)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "unit_azimuthal",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2388,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Azimuthal direction (for spherical coordinate systems)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "geometric_dimension_names",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2398,
    "signature": "(self) -> list",
    "parameters": [],
    "returns": "list",
    "existing_docstring": "Names of geometric dimensions for this coordinate system",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "primary_directions",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 2415,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Dictionary of all available geometric directions for this mesh type",
    "harvested_comments": [
      "Add coordinate-system-specific directions"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "create_line_sample",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2463,
    "signature": "(self, start_point, direction_vector, length, num_points = 50)",
    "parameters": [
      {
        "name": "start_point",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "direction_vector",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "length",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "num_points",
        "type_hint": null,
        "default": "50",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create sample points along a line defined by sympy expressions.\n\nParameters\n----------\nstart_point : list or numpy.ndarray\n    Starting point coordinates in Cartesian space\ndirection_vector : sympy.Matrix\n    Direction vector (should be unit vector for accurate length)\nlength : float\n    Length of the line to sample\nnum_points : int, optional\n    Number of sample points to generate\n\nReturns\n-------\ndict\n    Dictionary containing:\n    - 'cartesian_coords': numpy array of Cartesian coordinates for global_evaluate()\n    - 'natural_coords': numpy array of natural coordinates for plotting\n    - 'parameters': numpy array of parameter values along the line (0 to length)",
    "harvested_comments": [
      "Create parameter values along the line",
      "Convert start point to numpy array",
      "Generate Cartesian coordinates by evaluating the direction vector",
      "Get coordinate symbols",
      "Current point = start + t * direction"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "create_profile_sample",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2588,
    "signature": "(self, profile_type, **params)",
    "parameters": [
      {
        "name": "profile_type",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**params",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create sample points for common profile types in this coordinate system.\n\nParameters\n----------\nprofile_type : str\n    Type of profile to create. Options depend on coordinate system:\n    - Cartesian: 'horizontal', 'vertical', 'diagonal'\n    - Cylindrical: 'radial', 'tangential', 'vertical'\n    - Spherical: 'radial', 'meridional', 'azimuthal'\n**params\n    Profile-specific parameters (see individual profile documentation)\n\nReturns\n-------\ndict\n    Dictionary containing:\n    - 'cartesian_coords': numpy array of Cartesian coordinates for global_evaluate()\n    - 'natural_coords': numpy array of natural coordinates for plotting\n    - 'parameters': numpy array of parameter values along the profile",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "zero_matrix",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2847,
    "signature": "(self, shape)",
    "parameters": [
      {
        "name": "shape",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Matrix of spatial coordinates equivalent to zeros (but still dependent on X) -\nAdd this when you have a matrix with a mix of constants and functions - sympy / numpy\ncan become upset if the constants are not specific functions too.",
    "harvested_comments": [
      "Direct construction to avoid SymPy Matrix scalar multiplication issues"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": true
  },
  {
    "name": "evaluate",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 55,
    "signature": "def evaluate(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Evaluate the integral and return the result with units (if applicable).\n\n        Returns\n        -------\n        float or UWQuantity\n            The integral value. If the integrand has units AND the mesh coordinates\n            have units, returns a UWQuantity with proper dimensional analysis\n            (integrand_units * volume_units). Otherwise returns a plain float.\n",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "dim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 735,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Topological dimension of the mesh.\n\nReturns\n-------\nint\n    The mesh dimension (2 for 2D, 3 for 3D).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "cdim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 746,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Coordinate dimension (embedding space dimension).\n\nFor most meshes, ``cdim == dim``. For surface meshes embedded in 3D\n(e.g., a 2D spherical shell), ``dim=2`` but ``cdim=3``.\n\nReturns\n-------\nint\n    The coordinate dimension.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "element",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 760,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Element type information for the mesh.\n\nContains details about the finite element discretization including\ncell type, polynomial degree, and quadrature order.\n\nReturns\n-------\ndict\n    Element information dictionary.\n\nNotes\n-----\nUW3 does not support mixed-element meshes; this applies uniformly\nto all cells.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_scale",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 780,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "Length scale for non-dimensionalization.\n\nThis property is IMMUTABLE after mesh creation to ensure synchronization\nwith all spatial operators (gradient, divergence, curl, etc.).\n\nThe length scale is derived from model reference quantities at mesh creation:\n- Priority 1: `domain_depth` from `model.set_reference_quantities()`\n- Priority 2: `length` from `model.set_reference_quantities()`\n- Default: 1.0 (no scaling)\n\nReturns\n-------\nfloat\n    Length scale value for non-dimensionalization\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_depth=uw.quantity(100, \"km\"))\n>>> mesh = uw.meshing.UnstructuredSimplexBox(...)\n>>> mesh.length_scale\n100000.0  # meters\n\nSee Also\n--------\nlength_units : Units string for length scale",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 811,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Unit string for the length scale.\n\nReturns\n-------\nstr\n    Units for the length scale (e.g., \"meter\", \"kilometer\")\n\nExamples\n--------\n>>> mesh.length_units\n'kilometer'",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 827,
    "signature": "(self, level = 0)",
    "parameters": [
      {
        "name": "level",
        "type_hint": null,
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Displays mesh information at different levels.\n\nParameters\n----------\nlevel : int (0 default)\n    The display level.\n    0, for basic mesh information (variables and boundaries), while level=1 displays detailed mesh information (including PETSc information)",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "Display coordinate units if set",
      "Display length scale for non-dimensionalization",
      "Display coordinate system information",
      "Show available coordinate accessors"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view_parallel",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1020,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "returns the break down of boundary labels from each processor",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "# Boundary information on each proc",
      "## goes through each processor and gets the label size"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "clone_dm_hierarchy",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1071,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Clone the dm hierarchy on the mesh",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "update_lvec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1189,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This method creates and/or updates the mesh variable local vector.\nIf the local vector is already up to date, this method will do nothing.",
    "harvested_comments": [
      "create the local vector (memory chunk) and attach to original dm",
      "push avar arrays into the parent dm array",
      "The field decomposition seems to fail if coarse DMs are present",
      "traverse subdms, taking user generated data in the subdm",
      "local vec, pushing it into a global sub vec"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "lvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1228,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "Returns a local Petsc vector containing the flattened array\nof all the mesh variables.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1371,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Dummy access manager that provides deferred sync for backward compatibility.\nUses NDArray_With_Callback.delay_callbacks_global() internally.\n\nThis is a compatibility wrapper that allows existing code using the access()\ncontext manager to work with the new direct-access variable interfaces.\nAll variable modifications are deferred and synchronized at context exit.\n\nParameters\n----------\nwriteable_vars\n    Variables that will be modified (ignored - all variables are writable\n    with the new interface, this parameter is kept for API compatibility)\n\nReturns\n-------\nContext manager that defers variable synchronization until exit\n\nNotes\n-----\nThis method is deprecated. New code should access variable.data or\nvariable.array directly without requiring an access context.",
    "harvested_comments": [
      "Use NDArray_With_Callback global delay context for deferred sync",
      "This triggers all accumulated callbacks from all variables"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1421,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "SymPy coordinate system for symbolic calculus.\n\nThe base coordinate system used for gradient, divergence, and\ncurl operations. Access base scalars via ``mesh.N.x``, ``mesh.N.y``,\n``mesh.N.z`` and base vectors via ``mesh.N.i``, ``mesh.N.j``, ``mesh.N.k``.\n\nReturns\n-------\nsympy.vector.CoordSys3D\n    The SymPy coordinate system object.\n\nSee Also\n--------\nX : Coordinate system with data access.\nr : Tuple of coordinate scalars.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma_N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1441,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "SymPy coordinate system for boundary/surface coordinates.\n\nReturns\n-------\nsympy.vector.CoordSys3D\n    The boundary coordinate system object.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1452,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "Boundary coordinate scalars as a row matrix.\n\nReturns\n-------\nsympy.Matrix\n    Row matrix of boundary coordinate scalars.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "X",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1463,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate system with symbolic coordinates and data access.\n\nThe primary interface for mesh coordinates, providing both symbolic\nexpressions for equations and numerical data for evaluation.\n\nReturns\n-------\nCoordinateSystem\n    Coordinate system object with:\n\n    - ``mesh.X[0]``, ``mesh.X[1]``: Symbolic coordinate functions\n    - ``mesh.X.coords``: Coordinate data array (vertex positions)\n    - ``mesh.X.units``: Coordinate units\n    - ``x, y = mesh.X``: Unpack symbolic coordinates\n\nExamples\n--------\n>>> x, y = mesh.X  # Symbolic coordinates for equations\n>>> coords = mesh.X.coords  # Numerical vertex positions\n\nSee Also\n--------\nN : SymPy coordinate system for vector calculus.",
    "harvested_comments": [
      "Symbolic coordinates for equations",
      "Numerical vertex positions"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "CoordinateSystem",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1491,
    "signature": "(self) -> CoordinateSystem",
    "parameters": [],
    "returns": "CoordinateSystem",
    "existing_docstring": "Alias for :attr:`X` (the coordinate system object).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "r",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1496,
    "signature": "(self) -> Tuple[sympy.vector.BaseScalar]",
    "parameters": [],
    "returns": "Tuple[sympy.vector.BaseScalar]",
    "existing_docstring": "Tuple of coordinate scalars :math:`(x, y)` or :math:`(x, y, z)`.\n\nReturns\n-------\ntuple\n    Tuple of SymPy base scalars ``(N.x, N.y[, N.z])``.\n\nSee Also\n--------\nrvec : Position vector form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "rvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1511,
    "signature": "(self) -> sympy.vector.Vector",
    "parameters": [],
    "returns": "sympy.vector.Vector",
    "existing_docstring": "Position vector :math:`\\mathbf{r} = x\\hat{i} + y\\hat{j} [+ z\\hat{k}]`.\n\nReturns\n-------\nsympy.vector.Vector\n    The position vector in the mesh coordinate system.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1531,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of mesh element vertex coordinates.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.data`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nThis is an alias for mesh.points (which is also deprecated).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1550,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh node coordinates in physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.points`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from internal model coordinates\nto physical coordinates for user access.\n\nWhen the mesh has coordinate units specified, returns a unit-aware array.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Node coordinates (with units if specified)",
    "harvested_comments": [
      "Apply scaling to convert model coordinates to physical coordinates",
      "Wrap with unit-aware array if units are specified"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1592,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set mesh node coordinates from physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from physical coordinates\nto internal model coordinates for PETSc storage.\n\nArgs:\n    value (numpy.ndarray or UnitAwareArray): Node coordinates in physical units",
    "harvested_comments": [
      "PRINCIPLE (2025-11-27): When units are active, require unit-aware input",
      "to avoid ambiguity about whether values are dimensional or non-dimensional.",
      "Plain array assigned when units are active - ambiguous",
      "Handle unit-aware input",
      "Extract numerical value from unit-aware object"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_coordinates",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1661,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh coordinates in physical units.\n\nReturns the mesh coordinate array scaled to physical units using\nthe model's length scale. Requires the mesh to be associated with\na model that has reference quantities set.\n\nReturns\n-------\nUWQuantity or None\n    Coordinates in physical units, or None if no model scaling available\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_length=1000*uw.units.km, ...)\n>>> mesh = uw.meshing.StructuredQuadBox(...)\n>>> physical_coords = mesh.physical_coordinates  # In kilometers",
    "harvested_comments": [
      "In kilometers"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_bounds",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1686,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh bounds in physical units.\n\nReturns the mesh bounding box scaled to physical units using\nthe model's length scale.\n\nReturns\n-------\ntuple of UWQuantity or None\n    (min_coords, max_coords) in physical units, or None if no model scaling\n\nExamples\n--------\n>>> physical_min, physical_max = mesh.physical_bounds\n>>> print(f\"Domain: {physical_min} to {physical_max}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_extent",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1717,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh spatial extent in physical units.\n\nReturns the mesh size (max - min) in each dimension scaled to physical units.\n\nReturns\n-------\nUWQuantity or None\n    Extent in physical units, or None if no model scaling\n\nExamples\n--------\n>>> extent = mesh.physical_extent\n>>> print(f\"Domain size: {extent}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1745,
    "signature": "(self, filename: str, index: int, outputPath: Optional[str] = '', meshVars: Optional[list] = [], swarmVars: Optional[list] = [], meshUpdates: bool = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write the selected mesh, variables and swarm variables (as proxies) for later visualisation.\nAn xdmf file is generated and the overall package can then be read by paraview or pyvista.\nVertex values (on the mesh points) are stored for all variables regardless of their interpolation order",
    "harvested_comments": [
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists",
      "easier to debug abs",
      "check if we have write access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1816,
    "signature": "(self, index: int, meshVars: Optional[list] = [], outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the mesh and mesh vars in a h5 and xdmf file.\n\nParameters\n----------\nmeshVars:\n    List of UW mesh variables to save. If left empty then just the mesh is saved.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [
      "## save mesh vars",
      "### create petsc viewer",
      "## Empty meshVars will save just the mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1862,
    "signature": "(self, filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0, unique_id: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      },
      {
        "name": "unique_id",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write data in a format that can be restored for restarting the simulation\nThe difference between this and the visualisation is 1) the parallel section needs\nto be stored to reload the data correctly, and 2) the visualisation information (vertex form of fields)\nis not stored. This routines uses dmplex *VectorView and *VectorLoad functionality",
    "harvested_comments": [
      "The mesh checkpoint is the same as the one required for visualisation",
      "Checkpoint file",
      "Store the parallel-mesh section information for restoring the checkpoint.",
      "v._gvec.view(viewer) # would add viz information plus a duplicate of the data",
      "should not be required"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1924,
    "signature": "(self, filename: str, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh data to the specified hdf5 file.\n\n\nParameters\n----------\nfilename :\n    The filename for the mesh checkpoint file.\nindex :\n    Not yet implemented. An optional index which might\n    correspond to the timestep (for example).",
    "harvested_comments": [
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "viewer.pushTimestepping(viewer)",
      "viewer.setTimestep(index)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vtk",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1989,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh to the specified file",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "generate_xdmf",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1998,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method generates an xdmf schema for the specified file.\n\nThe filename of the generated file will be the same as the hdf5 file\nbut with the `xmf` extension.\n\nParameters\n----------\nfilename :\n    File name of the checkpointed hdf5 file for which the\n    xdmf schema will be written.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2020,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "block_vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2029,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points_in_domain",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2475,
    "signature": "(self, points, strict_validation = True)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "strict_validation",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in this domain.\nUses a mesh-boundary skeletonization array to determine whether the point is\ninside the boundary or outside. If close to the boundary, it checks if points\nare in a cell.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\nstrict_validation : bool\n    Whether to perform strict validation near boundaries",
    "harvested_comments": [
      "Convert points to model coordinates using the unified conversion function",
      "This handles all coordinate formats: plain numbers, unit-aware coordinates, lists, tuples, arrays",
      "_convert_coords_to_si now converts to model coordinates (despite the name)",
      "and handles all the complexity of extracting values from unit-aware coordinates",
      "# This choice of distance needs some more thought"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2529,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Note, the nearest point may not be all\nthat close by - use get_closest_local_cells to filter out points\nthat are (probably) not within any local cell.\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model coordinates",
      "Simply extract raw values - np.asarray handles unit-aware objects correctly",
      "## returns an empty 1D array if no coords are provided",
      "CRITICAL: Must return 1D array, not 2D, for Cython buffer compatibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "test_if_points_in_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2646,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test\n\nReturns\n-------\nnumpy.ndarray\n    Boolean array indicating if points are in cells",
    "harvested_comments": [
      "Convert points to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_local_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2681,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius_old",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2779,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2796,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_max_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2812,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global maximum distance from any cell centroid to a face.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2827,
    "signature": "(self, uw_function, uw_meshVariable, basis = None)",
    "parameters": [
      {
        "name": "uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "uw_meshVariable",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "basis",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Returns various norms on the mesh for the provided function.\n  - size\n  - mean\n  - min\n  - max\n  - sum\n  - L2 norm\n  - rms\n\n  NOTE: this currently assumes scalar variables !",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_mask_from_label",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2863,
    "signature": "(self, label_name, label_value)",
    "parameters": [
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract single label value and make a point mask - note: this produces a mask on the mesh points and\nassumes a 1st order mesh. Cell labels are not respected in this function.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "register_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2889,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register swarm as dependent on this mesh for coordinate change notifications",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "unregister_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2893,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unregister swarm (called during swarm cleanup)",
    "harvested_comments": [
      "WeakSet handles weak references internally, just remove the swarm directly"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "register_surface",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2898,
    "signature": "(self, surface)",
    "parameters": [
      {
        "name": "surface",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register surface as dependent on this mesh for adaptation notifications.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "unregister_surface",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2902,
    "signature": "(self, surface)",
    "parameters": [
      {
        "name": "surface",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unregister surface (called during surface cleanup).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "adapt",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2917,
    "signature": "(self, metric_field, verbose = False)",
    "parameters": [
      {
        "name": "metric_field",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adapt the mesh discretization based on a metric field.\n\nThis method refines or coarsens the mesh in place, automatically\ntransferring all attached MeshVariables, updating Surfaces, and\nmarking Solvers for rebuild on their next solve() call.\n\nParameters\n----------\nmetric_field : MeshVariable\n    A scalar MeshVariable containing target edge lengths (H field).\n    Smaller values mean finer mesh, larger values mean coarser.\nverbose : bool, optional\n    If True, print progress and statistics during adaptation.\n\nNotes\n-----\nThe adaptation uses PETSc's mesh adaptation with MMG/pragmatic backend.\n\n**What happens automatically:**\n\n- MeshVariables are interpolated to the new mesh\n- Surfaces recompute their distance fields\n- Swarms are marked as stale (particle-element associations invalidated)\n- Solvers are marked for rebuild (happens lazily on next solve())\n\nExamples\n--------\n>>> # Define metric from fault distance\n>>> metric = uw.discretisation.MeshVariable(\"H\", mesh, 1)\n>>> with mesh.access(metric):\n...     # Smaller H near fault, larger far away\n...     metric.data[:, 0] = 0.01 + 0.09 * fault.distance_from(mesh.data)\n>>> mesh.adapt(metric, verbose=True)\n>>> stokes.solve()  # Solver rebuilds automatically",
    "harvested_comments": [
      "Define metric from fault distance",
      "Smaller H near fault, larger far away",
      "Solver rebuilds automatically",
      "Store old state for transfer",
      "Notify surfaces to mark their distance fields as stale"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_lookup_by_symbol",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3342,
    "signature": "(mesh, sympy_object)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sympy_object",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Given a sympy object, scan the mesh variables in `mesh` to find the\nlocation (meshvariable, component in the data array) corresponding to the symbol\nor return None if not found",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_find_labeled_points_local",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3359,
    "signature": "(dm, label_name, label_value, sectionIndex = False, verbose = False)",
    "parameters": [
      {
        "name": "dm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sectionIndex",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Identify local points associated with \"Label\"\n\ndm -> expects a petscDM object\nlabel_name -> \"String Name for Label\"\nsectionIndex -> False: leave points as indexed by the relevant section on the dm\n                True: index into the local coordinate array\n\nNOTE: Assumes uniform element types",
    "harvested_comments": [
      "print(f\"Label: {label_name} / {label_value}\")",
      "print(f\"points: {pStart}: {pEnd}\")",
      "print(f\"edges : {eStart}: {eEnd}\")",
      "print(f\"faces : {fStart}: {fEnd}\")",
      "print(f\"\", flush=True)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 428,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the units associated with this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 433,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the units for this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 438,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 443,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the dimensionality of this variable.",
    "harvested_comments": [
      "Use Pint directly to get dimensionality"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "clone",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 609,
    "signature": "(self, name, varsymbol)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a copy of this variable with new name and symbol.\n\nCreates a new mesh variable with the same mesh, shape, type,\ndegree, and continuity as this variable, but with a different\nname and symbolic representation.\n\nParameters\n----------\nname : str\n    Name for the new variable.\nvarsymbol : str\n    LaTeX symbol for the new variable.\n\nReturns\n-------\nMeshVariable\n    New mesh variable with copied structure but independent data.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 640,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data array to PETSc using traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data in traditional flat format (-1, num_components)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Convert to expected shape: (-1, num_components)",
      "Direct PETSc access (following mesh.access pattern)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Direct assignment to PETSc vec (like mesh.access does at line 1156)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 694,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced pack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nCRITICAL: This is the entry point where dimensional data enters PETSc storage.\nAll unit conversion and non-dimensionalization must happen here.\n\nParameters\n----------\ndata_array : numpy.ndarray or UWQuantity or UnitAwareArray\n    Array data to pack into mesh field. Can have units (will be converted).\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "STEP 1: Handle unit conversion for incoming data",
      "This is CRITICAL for the array setter to work correctly with units",
      "Check if data has units (UWQuantity or UnitAwareArray)",
      "Data has units - need to convert and extract magnitude",
      "Convert incoming units to variable's units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 797,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc in traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in traditional flat format (-1, num_components)",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Sync parallel operations if requested"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 846,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced unpack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in correct shape for the variable",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Unpack data using same layout as original method"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 905,
    "signature": "(self, new_coords, meth = 0, p = 2, verbose = False, nnn = None, rubbish = None)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "meth",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "p",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "rubbish",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Interpolate variable data to new coordinates using RBF.\n\nUses inverse distance weighting with k-nearest neighbors to\ninterpolate values from mesh nodes to arbitrary coordinates.\n\nParameters\n----------\nnew_coords : numpy.ndarray\n    Target coordinates of shape ``(n_points, dim)``.\nmeth : int, optional\n    Interpolation method (reserved, currently unused).\np : float, optional\n    Power parameter for inverse distance weighting (default: 2).\nverbose : bool, optional\n    Print progress information.\nnnn : int, optional\n    Number of nearest neighbors (default: 4 for 3D, 3 for 2D).\n\nReturns\n-------\nnumpy.ndarray\n    Interpolated values at new coordinates.",
    "harvested_comments": [
      "An inverse-distance mapping is quite robust here ... as long",
      "as long we take care of the case where some nodes coincide (likely if used mesh2mesh)",
      "Use non-dimensional coordinates for internal RBF interpolation KDTree"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 953,
    "signature": "(self, filename: str, name: Optional[str] = None, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Append variable data to the specified mesh hdf5\ndata file. The file must already exist.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file. It\n    must already exist.\nname :\n    Textual name for dataset. In particular, this\n    will be used for XDMF generation. If not\n    provided, the variable name will be used.\nindex :\n    Not currently supported. An optional index which\n    might correspond to the timestep (for example).",
    "harvested_comments": [
      "Keep vector available for future access",
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "PetscViewerHDF5PushTimestepping(cviewer)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1031,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write variable data to the specified mesh hdf5\ndata file. The file will be over-written.\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file",
    "harvested_comments": [
      "Keep vector available for future access",
      "Variable coordinates - let's put those in the file to",
      "make it a standalone \"swarm\"",
      "# Add variable unit metadata to standalone file",
      "Use preferred selective_ranks pattern for unit metadata"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1125,
    "signature": "(self, data_filename, data_name, index, outputPath = '', verbose = False)",
    "parameters": [
      {
        "name": "data_filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": null,
        "default": "''",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a mesh variable from an arbitrary vertex-based checkpoint file\nand reconstruct/interpolate the data field accordingly. The data sizes / meshes can be\ndifferent and will be matched using a kd-tree / inverse-distance weighting\nto the new mesh.",
    "harvested_comments": [
      "Fix this to match the write_timestep function",
      "mesh.write_timestep( \"test\", meshUpdates=False, meshVars=[X], outputPath=\"\", index=0)",
      "swarm.write_timestep(\"test\", \"swarm\", swarmVars=[var], outputPath=\"\", index=0)",
      "check if data_file exists",
      "Keep vector available for future access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "fn",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1247,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists (deprecated)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "ijk",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1254,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1261,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the sympy.Matrix view of this variable",
    "harvested_comments": [
      "Note: Scaling is applied during unwrap(), not here"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1269,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to a flattened version of the sympy.Matrix view of this variable.\nAssume components are stored in the same order that sympy iterates entries in\na matrix except for the symmetric tensor case where we store in a Voigt form",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1537,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this variable belongs to (accessed via weak reference).\nRaises RuntimeError if the mesh has been garbage collected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "vec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1554,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "The corresponding PETSc local vector for this variable.",
    "harvested_comments": [
      "Ensure vector is initialized when accessed"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1568,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "TESTING: Original data property implementation.\nNumpy proxy array to underlying variable data.\nNote that the returned array is a proxy for all the *local* nodal\ndata, and is provided as 1d list.\n\nFor both read and write, this array can only be accessed via the\nmesh `access()` context manager.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1583,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view of canonical data with automatic format conversion.\nShape: (N, a, b) for tensor shape (a, b).\n\nThis property is ALWAYS a view of the canonical .data property.\nNo direct PETSc access - all changes delegate back to canonical storage.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2253,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Canonical data storage with PETSc synchronization.\nShape: (-1, num_components) - flat format for backward compatibility.\n\nThis is the ONLY property that handles PETSc synchronization to avoid conflicts.\nThe .array property uses this as its underlying storage with format conversion.\n\nReturns\n-------\nNDArray_With_Callback\n    Array with shape (-1, num_components) with automatic PETSc synchronization",
    "harvested_comments": [
      "Cache and reuse canonical data object to avoid field access conflicts",
      "Use direct __dict__ check to avoid potential attribute access issues",
      "Create the single canonical data array with PETSc sync"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2341,
    "signature": "(self, array_value)",
    "parameters": [
      {
        "name": "array_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set variable data using pack method to handle shape transformation.",
    "harvested_comments": [
      "Use pack method to handle proper data transformation and shape conversion"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "min",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2395,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable minimum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of minimum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "max",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2423,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable maximum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of maximum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sum",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2451,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable sum value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "norm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2479,
    "signature": "(self, norm_type) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "norm_type",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable norm value.\n\nnorm_type: type of norm, one of\n    - 0: NORM 1 ||v|| = sum_i | v_i |. ||A|| = max_j || v_*j ||\n    - 1: NORM 2 ||v|| = sqrt(sum_i |v_i|^2) (vectors only)\n    - 3: NORM INFINITY ||v|| = max_i |v_i|. ||A|| = max_i || v_i* ||, maximum row sum\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mean",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2512,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable mean value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "std",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2539,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable standard deviation value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw values from PETSc",
      "For scalar: std = sqrt((sum(x^2)/n) - (sum(x)/n)^2)",
      "Create a temporary vector for x^2 computation",
      "Calculate variance: E[x^2] - (E[x])^2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2595,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Universal statistics method for all variable types.\n\nReturns various statistical measures appropriate for the variable type.\nFor scalars: standard statistical measures.\nFor vectors: magnitude-based statistics.\nFor tensors: Frobenius norm and invariant-based measures.\n\nReturns\n-------\ndict\n    Dictionary containing statistical measures:\n    - 'type': Variable type ('scalar', 'vector', 'tensor')\n    - 'components': Number of components\n    - 'size': Number of elements\n    - 'mean': Mean value (scalar) or magnitude mean (vector/tensor)\n    - 'min': Minimum value (scalar) or magnitude min (vector/tensor)\n    - 'max': Maximum value (scalar) or magnitude max (vector/tensor)\n    - 'sum': Sum of all values\n    - 'norm2': L2 norm\n    - 'rms': Root mean square\n\n    Additional keys for vectors/tensors:\n    - 'magnitude_*': Statistics on vector magnitude\n    - 'frobenius_*': Statistics on tensor Frobenius norm (for tensors)\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2761,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of variable vertex coordinates for this variable's DOF locations.\n\nReturns coordinates for this variable's specific degree-of-freedom locations,\nwhich may differ from mesh coordinate variable locations if the degrees differ.\n\nWhen mesh has reference quantities set, returns unit-aware coordinates in meters.",
    "harvested_comments": [
      "Get non-dimensional [0-1] model coordinates for this variable's specific DOF locations",
      "If mesh has units, dimensionalise to physical coordinates",
      "Dimensionalise using the proper units system",
      "Specify length dimensionality since coords have dimension [length]",
      "No units - return non-dimensional coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords_nd",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2791,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "Non-dimensional [0-1] coordinates for this variable's DOF locations.\n\nReturns raw model coordinates from PETSc without any unit wrapping.\nThis is the coordinate system used by internal KDTree indexing, evaluation,\nand other algorithmic operations.\n\nFor user-facing operations with physical units, use `.coords` which returns\ndimensional coordinates when the model has reference quantities set.\n\nReturns\n-------\nndarray\n    Non-dimensional [0-1] coordinates, shape (N, dim)\n\nExamples\n--------\n>>> # Internal algorithmic use - KDTree indexing\n>>> kd_tree = uw.kdtree.KDTree(var.coords_nd)\n>>>\n>>> # User-facing display with dimensional units\n>>> print(f\"Positions: {var.coords}\")  # Shows meters, km, etc.\n\nNotes\n-----\nThis is a zero-copy operation that returns a view of the cached coordinate\narray directly from the mesh. No memory allocation or copying occurs.\n\nSee Also\n--------\ncoords : Dimensional coordinates with unit wrapping (user-facing)",
    "harvested_comments": [
      "Internal algorithmic use - KDTree indexing",
      "User-facing display with dimensional units",
      "Shows meters, km, etc.",
      "Direct access to non-dimensional coordinates from mesh cache",
      "This is a ZERO-COPY operation - returns cached array directly"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2831,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Divergence of this variable: :math:`\\nabla \\cdot \\mathbf{v}`.\n\nUses the mesh's coordinate-aware vector calculus operators,\nwhich correctly handle cylindrical, spherical, or other\nnon-Cartesian coordinate systems.\n\nReturns\n-------\nsympy.Expr or None\n    Scalar divergence expression, or None if the operation fails.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2848,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Gradient of this variable: :math:`\\nabla u`.\n\nUses the mesh's coordinate-aware vector calculus operators.\n\nReturns\n-------\nsympy.Matrix or None\n    Gradient vector as row matrix, or None if the operation fails.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2863,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Curl of this variable: :math:`\\nabla \\times \\mathbf{v}`.\n\nUses the mesh's coordinate-aware vector calculus operators.\n\nReturns\n-------\nsympy.Matrix, sympy.Expr, or None\n    Curl vector (3D) or scalar vorticity (2D), or None if fails.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "jacobian",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2878,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Jacobian matrix of this variable.\n\nComputes partial derivatives with respect to mesh coordinates:\n:math:`J_{ij} = \\partial v_i / \\partial x_j`.\n\nReturns\n-------\nsympy.Matrix\n    Jacobian matrix of shape (var_dim, mesh_dim).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 244,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Direct access to data array (supports += and other assignment ops).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 249,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Direct access to array (delegates to base variable).\n\nThe base variable's array implementation now handles units and\nnon-dimensional scaling correctly, so we just delegate to it.\nThis eliminates code duplication and ensures consistency.",
    "harvested_comments": [
      "Simply delegate to the base variable's array property",
      "The base variable now has the complete, working implementation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 262,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set array values.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "name",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 269,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Variable name.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "clean_name",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 274,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Cleaned variable name for PETSc.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 279,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this variable is defined on.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 287,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate array from base variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "coords_nd",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 292,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Non-dimensional coordinates from base variable (for internal KDTree operations).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "num_components",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 297,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Number of components.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "shape",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 302,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable shape.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "vtype",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 307,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable type.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "degree",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 312,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Polynomial degree.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 319,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Units for this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 324,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 329,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get dimensionality (delegates to DimensionalityMixin or base variable).",
    "harvested_comments": [
      "DimensionalityMixin.dimensionality uses self.units, which now delegates to _base_var",
      "This ensures consistency"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "units_repr",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 335,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return string representation with units information.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "non_dimensional_value",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 342,
    "signature": "(self, model = None)",
    "parameters": [
      {
        "name": "model",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get non-dimensionalized values of the variable.\n\nReturns the variable's data array in non-dimensional form based on\nthe model's reference quantities.",
    "harvested_comments": [
      "Use provided model or get default",
      "Just return the data divided by scaling coefficient",
      "No scaling, return data as-is"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "continuous",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 363,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Whether variable is continuous.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "symbol",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 368,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable symbol for LaTeX representation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "vec",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 375,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "PETSc vector (for solver integration).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 392,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Enhanced mathematical symbol.",
    "harvested_comments": [
      "Get base symbol from underlying variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 404,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data to PETSc format.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 408,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc format.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 414,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector divergence calculation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 418,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector gradient calculation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 422,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector curl calculation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "jacobian",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 426,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector jacobian calculation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "clone",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 432,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Clone the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "max",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 436,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Maximum value of the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "mean",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 440,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mean value of the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "min",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 444,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Minimum value of the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "norm",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 448,
    "signature": "(self, norm_type = None)",
    "parameters": [
      {
        "name": "norm_type",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute the norm of the variable.",
    "harvested_comments": [
      "Mathematical usage: use SymPy Matrix norm from MathematicalMixin",
      "Computational usage: delegate to PETSc norm"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "load_from_h5_plex_vector",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 457,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Load from HDF5 plex vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 461,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write variable data to HDF5 file.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 466,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flattened sympy view of the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 470,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save variable data.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 474,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read timestep data.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 478,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get statistics for the variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "sum",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 482,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Sum of variable values.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 486,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "RBF interpolation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 490,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack raw data to PETSc format.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 494,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack raw data from PETSc format.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "field_id",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 501,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Field ID in the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "fn",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 506,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Function representation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "ijk",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 511,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "IJK coordinates.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "instance_number",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 516,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Instance number.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 521,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Legacy data property (for testing).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "uw_object_counter",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 526,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Object counter from API tools.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "transfer_data_from",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 532,
    "signature": "(self, source_var)",
    "parameters": [
      {
        "name": "source_var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Transfer data from another variable using global_evaluate.\n\nThis enables persistent variable identity across mesh changes.\n\nNote on Symbol Disambiguation (2025-12-15):\n    This method transfers DATA, not symbolic expressions.\n    The source and target variables have distinct symbolic identities\n    (source_var.sym != self.sym) even if they share the same name.\n\n    For transferring expressions containing coordinates, use explicit\n    substitution: expr.subs({old_mesh.N.x: new_mesh.N.x, ...})\n\n    See: docs/developer/design/SYMBOL_DISAMBIGUATION_2025-12.md\n\nArgs:\n    source_var: Source variable to transfer data from\n\nReturns:\n    bool: True if transfer successful",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "qualified_name",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 563,
    "signature": "(self) -> Optional[str]",
    "parameters": [],
    "returns": "Optional[str]",
    "existing_docstring": "Qualified name for collision resolution.\n\nReturns the fully qualified name used in the model registry\nto resolve namespace collisions (e.g., 'velocity_mesh123456').",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "is_persistent",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 573,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Whether this variable has persistence capabilities.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 597,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display detailed information about the enhanced variable including units.\n\nShows variable name, dimensions, shape, units information, and sample data.",
    "harvested_comments": [
      "Units information",
      "Persistence information",
      "Sample data (first few elements)",
      "Mathematical capabilities",
      "Allow chaining"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": true
  },
  {
    "name": "create_enhanced_mesh_variable",
    "kind": "function",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 638,
    "signature": "(varname: Union[str, list], mesh: 'Mesh', num_components: Union[int, tuple] = None, persistent: bool = True, units: Optional[str] = None, **kwargs) -> EnhancedMeshVariable",
    "parameters": [
      {
        "name": "varname",
        "type_hint": "Union[str, list]",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": "Union[int, tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "persistent",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "EnhancedMeshVariable",
    "existing_docstring": "Factory function to create an enhanced mesh variable.\n\nThis is a convenience function that creates an EnhancedMeshVariable\nwith persistence enabled by default.\n\nArgs:\n    varname: Variable name\n    mesh: Mesh object\n    num_components: Number of components\n    persistent: Enable persistence (default True)\n    units: Units specification\n    **kwargs: Additional arguments\n\nReturns:\n    EnhancedMeshVariable instance",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "demonstrate_enhanced_variables",
    "kind": "function",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 702,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Demonstration of enhanced variables with units and mathematical operations.\n\nThis function shows how the enhanced variables integrate mathematical\noperations with units checking and dimensional analysis.",
    "harvested_comments": [
      "Create a simple mesh",
      "Create enhanced mesh variables with units",
      "Test mathematical operations",
      "Component access",
      "Vector operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "with_units",
    "kind": "function",
    "file": "src/underworld3/function/__init__.py",
    "line": 94,
    "signature": "(sympy_expr, name = None, units = None)",
    "parameters": [
      {
        "name": "sympy_expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Wrap a SymPy expression in a unit-aware object with .units and .to() methods.\n\nThis is particularly useful for derivatives and other SymPy operations that\nreturn plain SymPy expressions instead of unit-aware objects.\n\nParameters\n----------\nsympy_expr : sympy expression\n    The SymPy expression to wrap (e.g., from temperature.diff(y))\nname : str, optional\n    Optional name for the expression (auto-generated if not provided)\nunits : str, optional\n    Explicit units for the expression. If provided, these units are used\n    instead of trying to extract units from the expression. This is useful\n    for derivatives where units are known from the derivative operation.\n\nReturns\n-------\nUWexpression\n    Unit-aware expression with .units and .to() methods\n\nExamples\n--------\n>>> # Derivative returns plain SymPy\n>>> dTdy_sympy = temperature.diff(y)[0]\n>>>\n>>> # Wrap it to get unit-aware object\n>>> dTdy = uw.with_units(dTdy_sympy)\n>>> dTdy.units  # kelvin / kilometer\n>>> dTdy.to(\"K/mm\")  # Unit conversion works!\n\n>>> # Also works with other SymPy operations\n>>> combined = uw.with_units(2 * temperature.sym + pressure.sym)\n\n>>> # Explicit units for derivatives\n>>> dTdy_elem = uw.with_units(derivative_expr, units=\"kelvin / kilometer\")",
    "harvested_comments": [
      "Derivative returns plain SymPy",
      "Wrap it to get unit-aware object",
      "kelvin / kilometer",
      "Unit conversion works!",
      "Also works with other SymPy operations"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "derivative",
    "kind": "function",
    "file": "src/underworld3/function/__init__.py",
    "line": 162,
    "signature": "(expression, variable, evaluate = True)",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "variable",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "evaluate",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Obtain symbolic derivatives of any underworld function, correctly handling sub-expressions / constants.\n\nUWCoordinates from mesh.X work transparently with this function and with\nsympy.diff() directly - both approaches now produce identical results:\n\n    x, y = mesh.X\n    result = uw.function.derivative(expr, y)  # This function\n    result = sympy.diff(expr, y)              # Also works (since Dec 2025)\n\nArgs:\n    expression: The expression to differentiate\n    variable: The variable to differentiate with respect to (UWCoordinate or BaseScalar)\n    evaluate (bool): If True, evaluate immediately. If False, return deferred derivative.\n\nReturns:\n    The derivative (evaluated SymPy expression or UWDerivativeExpression)",
    "harvested_comments": [
      "This function",
      "Also works (since Dec 2025)",
      "Note: Since December 2025, UWCoordinate subclasses BaseScalar with __eq__/__hash__",
      "that match the original N.x/N.y/N.z, so no conversion is needed anymore.",
      "sympy.diff() works directly with UWCoordinates."
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "fdiff",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 56,
    "signature": "def fdiff(self, argindex):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        We provide an explicit derivative function.\n        This allows us to control the way derivative objects are printed,\n        but in the user interface, but more critically it allows us to\n        patch in code printing implementation for derivatives objects,\n        as utilised in `_jitextension.py`.\n",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_structure",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 53,
    "signature": "(self, coords: np.ndarray, dofcount: int)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "dofcount",
        "type_hint": "int",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get cached CachedDMInterpolationInfo or None.\n\nParameters\n----------\ncoords : ndarray\n    Evaluation coordinates\ndofcount : int\n    Total DOF count for current variables\n\nReturns\n-------\ncached_info : CachedDMInterpolationInfo or None\n    Cached structure object, or None if not cached or disabled",
    "harvested_comments": [
      "Caching disabled",
      "Compute cache key",
      "Check cache"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "store_structure",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 88,
    "signature": "(self, coords: np.ndarray, dofcount: int, cached_info)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "dofcount",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "cached_info",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Store CachedDMInterpolationInfo in cache.\n\nParameters\n----------\ncoords : ndarray\n    Evaluation coordinates\ndofcount : int\n    Total DOF count\ncached_info : CachedDMInterpolationInfo\n    Cython wrapper object containing DMInterpolation structure",
    "harvested_comments": [
      "Don't cache if disabled",
      "Python GC keeps it alive"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "invalidate_all",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 120,
    "signature": "(self, reason: str = 'manual')",
    "parameters": [
      {
        "name": "reason",
        "type_hint": "str",
        "default": "'manual'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Clear entire cache and destroy all DMInterpolation structures.\n\nIMPORTANT: Must be called from Cython to properly destroy C structures!\nThis method only clears the Python-side tracking.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "invalidate_coords",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 133,
    "signature": "(self, coords: np.ndarray)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Invalidate all cache entries for specific coordinates.",
    "harvested_comments": [
      "Remove all entries with this coord hash (different dofcounts)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "get_stats",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 144,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Get cache performance statistics.\n\nReturns\n-------\ndict with metrics:\n    - requests: Total get() calls\n    - hits: Cache hits\n    - misses: Cache misses\n    - hit_rate: Percentage of hits\n    - entries: Current cache size\n    - invalidations: Total invalidation events",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "print_stats",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 169,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Print cache statistics (user-facing).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "reset_stats",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 183,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Reset statistics (but keep cached entries).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": true
  },
  {
    "name": "simplify_units",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 31,
    "signature": "(units)",
    "parameters": [
      {
        "name": "units",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Simplify combined units to human-readable form.\n\nConverts complex unit expressions (e.g., megayear * centimeter / year)\nto compact, human-friendly forms (e.g., kilometer) using Pint's\n:meth:`to_compact` method.\n\nParameters\n----------\nunits : pint.Unit or None\n    The units to simplify.\n\nReturns\n-------\npint.Unit or None\n    Simplified units with appropriate prefixes, or None if input is None.",
    "harvested_comments": [
      "Create a quantity with value 1 and these units, then simplify",
      "If simplification fails, return original units"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "unwrap_expression",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 176,
    "signature": "(expr, mode = 'nondimensional', depth = None)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mode",
        "type_hint": null,
        "default": "'nondimensional'",
        "description": ""
      },
      {
        "name": "depth",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unified unwrapping of UW expressions.\n\nThis is the single entry point for all expression unwrapping needs.\n\nArgs:\n    expr: Expression to unwrap (UWexpression, SymPy expr, or value)\n    mode: 'nondimensional' - for JIT compilation and evaluation (uses .data)\n          'dimensional' - for user display (uses .value)\n          'symbolic' - just expand .sym structure\n    depth: Maximum expansion depth (None = complete expansion)\n\nReturns:\n    Pure SymPy expression with all UW atoms expanded",
    "harvested_comments": [
      "Extract sym if needed",
      "Fixed-point iteration (or depth-limited)",
      "Safety limit"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_constant_expr",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 227,
    "signature": "(fn)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Check if expression has no mesh variable dependencies.\n\nAn expression is \"constant\" in the Underworld sense if it doesn't\ndepend on mesh coordinates, mesh variables, or applied functions.\n\nParameters\n----------\nfn : sympy.Expr or UWexpression\n    Expression to check.\n\nReturns\n-------\nbool\n    True if the expression has no spatial dependencies.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extract_expressions",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 247,
    "signature": "(fn)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract all UWexpression atoms from a SymPy expression.\n\nParameters\n----------\nfn : sympy.Expr or UWexpression\n    Expression to search.\n\nReturns\n-------\nset\n    Set of :class:`UWexpression` objects found in the expression tree.",
    "harvested_comments": [
      "exhaustion criterion"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extract_expressions_and_functions",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 282,
    "signature": "(fn)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract all UWexpression, Function, and coordinate atoms.\n\nRecursively searches an expression tree for Underworld-specific\natoms including expressions, applied functions, and coordinate\nbase scalars.\n\nParameters\n----------\nfn : sympy.Expr or UWexpression\n    Expression to search.\n\nReturns\n-------\nset\n    Set of UWexpression, Function, and BaseScalar objects.",
    "harvested_comments": [
      "Handle UWQuantity objects - they don't have atoms() method",
      "exhaustion criterion"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "expand",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 358,
    "signature": "(expr, depth = None, simplify_result = False)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "depth",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "simplify_result",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Expand UW expression to reveal SymPy structure for inspection.\n\nThis function recursively expands nested UW expressions to reveal their\nunderlying SymPy representation. It's designed for user inspection and\ndebugging - use dimensional values (not scaled).\n\nArgs:\n    expr: UW expression to expand\n    depth (int, optional): Maximum expansion depth. None = full expansion\n    simplify_result (bool): If True, apply SymPy simplification\n\nReturns:\n    Pure SymPy expression with all UW wrappers removed (dimensional values)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "unwrap",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 382,
    "signature": "(fn, depth = None, keep_constants = True, return_self = True)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "depth",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keep_constants",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "return_self",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Expand UW expression to reveal SymPy structure.\n\nArgs:\n    fn: Expression to unwrap\n    depth: Maximum expansion depth (None = complete)\n    keep_constants: If False, use nondimensional mode (for JIT)\n    return_self: If False, use nondimensional mode (for JIT)\n\nReturns:\n    Unwrapped SymPy expression",
    "harvested_comments": [
      "JIT compilation path - use nondimensional mode",
      "Display path - use dimensional mode"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "unwrap_for_evaluate",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 403,
    "signature": "(expr, scaling_active = None)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "scaling_active",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unwrap expression for evaluate/lambdify path with proper unit handling.\n\nType-based dispatch (2025-12 UWCoordinate design):\n- UWCoordinate: unwrap to BaseScalar (placeholder, NO scaling)\n- UWexpression with units: nondimensionalize via .data\n- UWexpression without units: recursively unwrap .sym\n- UWQuantity: nondimensionalize via .data\n- BaseScalar/MeshVariable.sym: pass through unchanged\n\nReturns:\n    tuple: (unwrapped_expr, result_dimensionality)",
    "harvested_comments": [
      "Step 1: Get expression dimensionality",
      "IMPORTANT: For UWexpression, try the wrapper FIRST because it stores units",
      "via ._value_with_units. The raw .sym expression has no unit metadata.",
      "Try wrapper first (has unit info from arithmetic)",
      "If wrapper has no units, try the .sym expression (may contain unit-aware variables)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "substitute_expr",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 518,
    "signature": "(fn, sub_expr, keep_constants = True, return_self = True)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sub_expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "keep_constants",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "return_self",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Substitute a specific expression throughout.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rename",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 664,
    "signature": "(self, new_display_name: str) -> 'UWexpression'",
    "parameters": [
      {
        "name": "new_display_name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWexpression'",
    "existing_docstring": "Change the display name of this expression without changing its identity.\n\nThis allows customizing how the expression appears in LaTeX output\nand string representations while preserving its symbolic identity\n(hash and equality remain based on the original name and _uw_id).\n\nParameters\n----------\nnew_display_name : str\n    The new name to use for display purposes (typically LaTeX).\n\nReturns\n-------\nUWexpression\n    Returns self to allow method chaining.\n\nExamples\n--------\n>>> viscosity = uw.expression(\"eta\", 1e21)\n>>> viscosity.rename(r\"\\eta_{\\mathrm{mantle}}\")\n>>> print(viscosity)  # Shows renamed version\n\nNotes\n-----\nThe original symbol name (self.name) is preserved for:\n- SymPy identity (hash, equality)\n- Pickling/serialization\n- Expression matching in solvers\n\nOnly the display representation changes via _latex() and _sympystr().",
    "harvested_comments": [
      "Shows renamed version"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 802,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the symbolic/numeric value.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 807,
    "signature": "(self, new_value)",
    "parameters": [
      {
        "name": "new_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update the wrapped value.",
    "harvested_comments": [
      "TRANSPARENT CONTAINER PRINCIPLE: Store the object directly",
      "Keep the full UWQuantity!"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "copy",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 819,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Copy the symbolic value and metadata from another expression.\n\nThis method updates this expression's content while preserving its identity\n(same Python id). Used by constitutive model parameter setters to enable\nlazy evaluation - the expression container stays the same, but its content\ncan be updated.\n\nParameters\n----------\nother : UWexpression or UWQuantity or sympy.Basic or number\n    The source to copy from. If UWexpression, copies both ._sym and\n    any unit metadata. Otherwise, updates .sym directly.\n\nNotes\n-----\nThis follows the same pattern as ExpressionDescriptor.__set__ in _api_tools.py\nto ensure consistent behavior for expression updates.",
    "harvested_comments": [
      "Copy the symbolic value",
      "Copy unit metadata for compatibility with older patterns",
      "(though Transparent Container principle derives these from _sym)",
      "For UWQuantity, numbers, sympy expressions - use .sym setter"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "value",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 855,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the dimensional value of the wrapped thing.",
    "harvested_comments": [
      "TRANSPARENT CONTAINER: Always derive from _sym (the wrapped object)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 863,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the non-dimensional value for computation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 881,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get units from the wrapped thing (if it has units).",
    "harvested_comments": [
      "TRANSPARENT CONTAINER: Always derive from _sym"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 889,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if the wrapped thing has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 894,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get dimensionality from the wrapped thing.",
    "harvested_comments": [
      "TRANSPARENT CONTAINER: Always derive from _sym"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "expression",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 902,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the unwrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "expression_number",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 915,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unique number of the expression instance.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "quantity",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 924,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the wrapped quantity for numeric arithmetic with units.\n\nReturns the underlying UWQuantity if one was provided, or creates\none from the value.",
    "harvested_comments": [
      "TRANSPARENT CONTAINER: Derive from _sym (the wrapped object)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "to",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 941,
    "signature": "(self, target_units: str) -> 'UWexpression'",
    "parameters": [
      {
        "name": "target_units",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWexpression'",
    "existing_docstring": "Convert to different units.\n\nDelegates to uw.convert_units() for the actual conversion.\n\nParameters\n----------\ntarget_units : str\n    Target units (e.g., \"m/s\", \"km\", \"degC\")\n\nReturns\n-------\nUWexpression\n    New expression with converted value and units\n\nExamples\n--------\n>>> radius = uw.expression(\"r\", uw.quantity(6370, \"km\"))\n>>> radius_m = radius.to(\"m\")\n>>> print(radius_m.value)  # 6370000.0",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "to_base_units",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 966,
    "signature": "(self) -> 'UWexpression'",
    "parameters": [],
    "returns": "'UWexpression'",
    "existing_docstring": "Convert to SI base units.\n\nDelegates to uw.to_base_units() for the actual conversion.\n\nReturns\n-------\nUWexpression\n    New expression with value in SI base units\n\nExamples\n--------\n>>> velocity = uw.expression(\"v\", uw.quantity(100, \"km/h\"))\n>>> velocity_si = velocity.to_base_units()\n>>> print(velocity_si.value)  # 27.78 (m/s)",
    "harvested_comments": [
      "27.78 (m/s)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "to_reduced_units",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 986,
    "signature": "(self) -> 'UWexpression'",
    "parameters": [],
    "returns": "'UWexpression'",
    "existing_docstring": "Simplify units by canceling common factors.\n\nDelegates to uw.to_reduced_units() for the actual simplification.\n\nReturns\n-------\nUWexpression\n    New expression with simplified units",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "to_compact",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1000,
    "signature": "(self) -> 'UWexpression'",
    "parameters": [],
    "returns": "'UWexpression'",
    "existing_docstring": "Convert to most human-readable unit representation.\n\nAutomatically chooses unit prefixes (kilo, mega, micro, etc.)\nto make the number more readable.\n\nDelegates to uw.to_compact() for the actual conversion.\n\nReturns\n-------\nUWexpression\n    New expression with compact units\n\nExamples\n--------\n>>> length = uw.expression(\"L\", uw.quantity(0.001, \"km\"))\n>>> length_compact = length.to_compact()\n>>> print(length_compact)  # 1.0 [meter]",
    "harvested_comments": [
      "1.0 [meter]"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "atoms",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1035,
    "signature": "(self, *types)",
    "parameters": [
      {
        "name": "*types",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use Symbol's atoms() method.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_number",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1056,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "UWexpression is a Symbol, not a number.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_comparable",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1061,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_extended_real",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1068,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_positive",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1075,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_negative",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1082,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_zero",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1089,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_finite",
    "kind": "property",
    "file": "src/underworld3/function/expressions.py",
    "line": 1096,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to wrapped expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_constant",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1102,
    "signature": "(self, *wrt, **flags)",
    "parameters": [
      {
        "name": "*wrt",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**flags",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "SymPy-compatible is_constant - delegate to Symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "is_uw_constant",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1106,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "UW-specific: does this have no mesh variable dependencies?",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "constant",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1110,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deprecated - use is_uw_constant().",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "diff",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1114,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Differentiation - delegate to Symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": true
  },
  {
    "name": "doit",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1684,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Evaluate the derivative.\n\nReturns\n-------\nsympy.Basic\n    The result of differentiating the expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWDerivativeExpression",
    "is_public": true
  },
  {
    "name": "mesh_vars_in_expression",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 1702,
    "signature": "(expr)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Find all mesh variables and derivatives in an expression.\n\nTraverses the expression tree to find:\n- Regular mesh variable functions (UnderworldAppliedFunction)\n- Derivative functions (UnderworldAppliedFunctionDeriv), grouped by source variable\n\nReturns:\n    tuple: (mesh, regular_vars, derivative_vars)\n    - mesh: Common mesh for all variables (None if no mesh vars)\n    - regular_vars: set of UnderworldAppliedFunction objects\n    - derivative_vars: dict mapping source MeshVariable -> list of (deriv_expr, diffindex)\n      where diffindex is 0=x, 1=y, 2=z derivative direction",
    "harvested_comments": [
      "source_meshvar -> [(deriv_expr, diffindex), ...]",
      "Check for derivative functions - collect instead of raising error",
      "Don't recurse into derivative args - they are just coordinates",
      "Check derivatives FIRST - they inherit from UnderworldAppliedFunction",
      "so must be checked before the parent class"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate",
    "kind": "function",
    "file": "src/underworld3/function/functions_unit_system.py",
    "line": 33,
    "signature": "(expr, coords, coord_sys = None, other_arguments = None, simplify = True, verbose = False, evalf = False, mode = 'default', data_layout = None, check_extrapolated = False, smoothing = 1e-06, rbf = None, force_l2 = None)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coord_sys",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "other_arguments",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "simplify",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "mode",
        "type_hint": null,
        "default": "'default'",
        "description": ""
      },
      {
        "name": "data_layout",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "check_extrapolated",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "1e-06",
        "description": ""
      },
      {
        "name": "rbf",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "force_l2",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate expression at coordinates with automatic unit handling.\n\nThis function wraps the Cython evaluate_nd implementation to automatically\nhandle unit conversions and return unit-aware results.\n\nParameters\n----------\nexpr : sympy expression or UWexpression\n    Expression to evaluate\ncoords : array-like\n    Coordinates at which to evaluate. Can be:\n    - numpy array of doubles (shape: n_points x n_dims) in non-dimensional form\n    - UnitAwareArray with dimensional coordinates (e.g., from mesh.X.coords)\n    - Both work transparently - dimensional coords are auto-converted\ncoord_sys : mesh.N vector coordinate system, optional\n    Coordinate system to use (default: None)\nother_arguments : dict, optional\n    Additional arguments for evaluation (default: None)\nsimplify : bool, optional\n    Whether to simplify expression (default: True)\nverbose : bool, optional\n    Verbose output (default: False)\nevalf : bool, optional\n    Force numerical evaluation via sympy evalf (default: False)\nmode : str, optional\n    Evaluation mode controlling accuracy vs speed tradeoff:\n    - \"default\": Accurate evaluation. Projection for derivatives (O(h\u00b2)),\n      direct calculation otherwise. DMInterpolation inside mesh, RBF outside.\n    - \"fast\": Quick visualization mode. Clement gradient recovery for\n      derivatives (O(h), no solve), RBF interpolation everywhere.\n    - \"projection\": Always use L2 projection (even without derivatives),\n      DMInterpolation inside mesh, RBF outside.\n    Default: \"default\"\ndata_layout : callable, optional\n    Data layout specification (default: None)\ncheck_extrapolated : bool, optional\n    Check for extrapolated values (default: False)\nsmoothing : float, optional\n    Smoothing parameter for L2 projection (dimensionless).\n    Only used when projection is active. Default: 1e-6\nrbf : bool, optional\n    Expert override: Force RBF interpolation everywhere. Overrides mode.\nforce_l2 : bool, optional\n    Expert override: Force L2 projection path. Overrides mode.\n\nReturns\n-------\nUWQuantity, UnitAwareArray, or ndarray\n    - If non-dimensional scaling is active: plain ndarray (non-dimensional)\n    - If expression has units and result is scalar: UWQuantity\n    - If expression has units and result is array: UnitAwareArray\n    - If expression has no units: plain ndarray (as before)\n\nNotes\n-----\n**Evaluation Modes:**\n\n| Mode | Derivatives | No Derivatives | Interpolation |\n|------|-------------|----------------|---------------|\n| \"fast\" | Clement (no solve) | Calculation | RBF everywhere |\n| \"default\" | Projection (solve) | Calculation | DMInterp + RBF |\n| \"projection\" | Projection (solve) | Projection | DMInterp + RBF |\n\nThe `rbf` and `force_l2` parameters are expert overrides that take\nprecedence over the mode setting when explicitly provided.\n\nExamples\n--------\n>>> # Works with both dimensional and non-dimensional coords\n>>> result = uw.function.evaluate(T.sym, T.coords)  # dimensional coords\n>>> result = uw.function.evaluate(T.sym, mesh.data[:, :2])  # non-dimensional\n>>> if hasattr(result, 'to'):\n...     result_K = result.to('K')  # Unit conversion",
    "harvested_comments": [
      "Expert overrides (override mode settings)",
      "Works with both dimensional and non-dimensional coords",
      "dimensional coords",
      "non-dimensional",
      "Unit conversion"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "global_evaluate",
    "kind": "function",
    "file": "src/underworld3/function/functions_unit_system.py",
    "line": 368,
    "signature": "(expr, coords = None, coord_sys = None, other_arguments = None, simplify = True, verbose = False, evalf = False, mode = 'default', data_layout = None, check_extrapolated = False, smoothing = 1e-06, rbf = None, force_l2 = None)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coord_sys",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "other_arguments",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "simplify",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "mode",
        "type_hint": null,
        "default": "'default'",
        "description": ""
      },
      {
        "name": "data_layout",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "check_extrapolated",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "1e-06",
        "description": ""
      },
      {
        "name": "rbf",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "force_l2",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Global evaluate with automatic unit-aware results.\n\nSimilar to evaluate() but performs global evaluation across all processes.\nReturns unit-aware objects when expression has units.\n\nParameters\n----------\nexpr : sympy expression or UWexpression\n    Expression to evaluate\ncoords : array-like, optional\n    Coordinates at which to evaluate (default: None)\ncoord_sys : CoordinateSystem, optional\n    Coordinate system to use (default: None)\nother_arguments : dict, optional\n    Additional arguments for evaluation (default: None)\nsimplify : bool, optional\n    Whether to simplify expression (default: True)\nverbose : bool, optional\n    Verbose output (default: False)\nevalf : bool, optional\n    Force numerical evaluation via sympy evalf (default: False)\nmode : str, optional\n    Evaluation mode controlling accuracy vs speed tradeoff:\n    - \"default\": Accurate evaluation. Projection for derivatives (O(h\u00b2)),\n      direct calculation otherwise. DMInterpolation inside mesh, RBF outside.\n    - \"fast\": Quick visualization mode. Clement gradient recovery for\n      derivatives (O(h), no solve), RBF interpolation everywhere.\n    - \"projection\": Always use L2 projection (even without derivatives),\n      DMInterpolation inside mesh, RBF outside.\n    Default: \"default\"\ndata_layout : callable, optional\n    Data layout specification (default: None)\ncheck_extrapolated : bool, optional\n    Check for extrapolated values (default: False)\nsmoothing : float, optional\n    Smoothing parameter for L2 projection (dimensionless).\n    Only used when projection is active. Default: 1e-6\nrbf : bool, optional\n    Expert override: Force RBF interpolation everywhere. Overrides mode.\nforce_l2 : bool, optional\n    Expert override: Force L2 projection path. Overrides mode.\n\nReturns\n-------\nUWQuantity, UnitAwareArray, or ndarray\n    - If non-dimensional scaling is active: plain ndarray (non-dimensional)\n    - Otherwise: result with appropriate unit tracking\n\nNotes\n-----\nSee :func:`evaluate` for details on evaluation modes.",
    "harvested_comments": [
      "Expert overrides (override mode settings)",
      "Map mode to internal flags (rbf, force_l2)",
      "Expert overrides take precedence when explicitly provided",
      "Use mode settings",
      "Expert overrides - use provided values or defaults"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate_gradient",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 48,
    "signature": "(scalar_var, coords, method = 'interpolant', component = None)",
    "parameters": [
      {
        "name": "scalar_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "method",
        "type_hint": null,
        "default": "'interpolant'",
        "description": ""
      },
      {
        "name": "component",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate gradient of a mesh variable at arbitrary coordinates.\n\nComputes the gradient of a MeshVariable (or one of its components) and\nevaluates it at the specified coordinates.\n\nParameters\n----------\nscalar_var : MeshVariable\n    Field to compute gradient of. Can be scalar (num_components=1) or\n    vector/tensor field. For multi-component fields, use `component`\n    parameter to specify which component's gradient to compute.\ncoords : array-like\n    Coordinates at which to evaluate gradient, shape (n_points, dim).\n    Can be numpy array or UnitAwareArray.\nmethod : str, optional\n    Gradient computation method:\n    - \"interpolant\": Clement interpolant (O(h) accurate, no solve). Default.\n    - \"projection\": L2 projection (O(h\u00b2) accurate, requires solve).\ncomponent : int or None, optional\n    For multi-component fields, which component to compute gradient of.\n    If None and field has multiple components, raises ValueError.\n    For scalar fields, this parameter is ignored.\n\nReturns\n-------\nndarray\n    Gradient values at requested coordinates, shape (n_points, dim).\n    gradient[i, j] = \u2202f/\u2202x\u2c7c at coords[i].\n\nNotes\n-----\n**Interpolant (Clement) Method**: Uses PETSc's\n`DMPlexComputeGradientClementInterpolant` which averages cell-wise gradients\nat vertices. This is O(h) accurate - error halves when mesh resolution doubles.\nFast but limited to first-order accuracy.\n\n**Projection (L2) Method**: Solves a mass matrix system to find the optimal\nL2 projection of the gradient onto the finite element space. This is O(h\u00b2)\naccurate for smooth solutions. The projection is cached on the mesh for\nrepeated calls, using the previous solution as initial guess.\n\nExamples\n--------\n>>> mesh = uw.meshing.StructuredQuadBox(elementRes=(16, 16))\n>>> T = uw.discretisation.MeshVariable('T', mesh, 1)\n>>> T.array[:, 0, 0] = T.coords[:, 0]**2  # T = x\u00b2\n>>>\n>>> # Fast gradient (O(h))\n>>> grad_fast = evaluate_gradient(T, coords, method=\"interpolant\")\n>>>\n>>> # Accurate gradient (O(h\u00b2))\n>>> grad_accurate = evaluate_gradient(T, coords, method=\"projection\")\n\nSee Also\n--------\nuw.systems.Projection : Direct L2 projection for explicit control\nuw.function.evaluate : General function evaluation\n\nReferences\n----------\n.. [1] Cl\u00e9ment, P. (1975). \"Approximation by finite element functions\n   using local regularization\". RAIRO Analyse num\u00e9rique, 9(R-2), 77-84.",
    "harvested_comments": [
      "Fast gradient (O(h))",
      "Accurate gradient (O(h\u00b2))"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "interpolate_gradients_at_coords",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 493,
    "signature": "(source_vars, coords, mesh, method = 'interpolant')",
    "parameters": [
      {
        "name": "source_vars",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "method",
        "type_hint": null,
        "default": "'interpolant'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute gradients for multiple source variables and interpolate.\n\nComputes gradients for each source variable using the specified method\nand evaluates at the specified coordinates.\n\nParameters\n----------\nsource_vars : list of MeshVariable or list of (MeshVariable, int) tuples\n    Fields needing gradient computation. For scalar fields, just pass\n    the MeshVariable. For multi-component fields, pass tuples of\n    (MeshVariable, component_index).\ncoords : array-like\n    Coordinates at which to evaluate gradients, shape (n_points, dim).\nmesh : Mesh\n    The mesh containing the variables.\nmethod : str, optional\n    Gradient computation method:\n    - \"interpolant\": Clement interpolant (O(h) accurate, no solve). Default.\n    - \"projection\": L2 projection (O(h\u00b2) accurate, requires solve).\n\nReturns\n-------\ndict\n    Mapping from (var, component) tuple to gradient array (n_points, dim).\n    For scalar fields, component is 0.\n    result[(var, component)][i, j] = \u2202var[component]/\u2202x\u2c7c at coords[i].\n\nNotes\n-----\nFor an expression with multiple derivatives like `T.diff(x) + v[0].diff(y)`:\n- Identifies source variables and components: {(T, 0), (v, 0)}\n- Computes gradient once per (variable, component) pair\n- Each derivative component extracted from the appropriate gradient\n\nThis is called internally by evaluate_nd when derivatives are detected.",
    "harvested_comments": [
      "Normalize input: convert bare variables to (var, component) tuples",
      "Bare variable - assume scalar (component 0)",
      "For multi-component fields, caller should specify components",
      "Multi-component field passed without component spec",
      "Compute gradient for all components"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "compute_clement_gradient_at_nodes",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 570,
    "signature": "(var, component = None)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "component",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute Clement gradient at mesh nodes only (no interpolation).\n\nThis is the raw Clement interpolant without arbitrary point evaluation.\nUseful when you only need values at mesh nodes, e.g., for error estimation\nor visualization at node locations.\n\nParameters\n----------\nvar : MeshVariable\n    Field to compute gradient of. Can be scalar or multi-component.\ncomponent : int or None, optional\n    For multi-component fields, which component to compute gradient of.\n    If None and field is scalar, uses the only component.\n    If None and field is multi-component, raises ValueError.\n\nReturns\n-------\nndarray\n    Gradient at mesh nodes, shape (n_nodes, dim).\n    gradient[i, j] = \u2202f/\u2202x\u2c7c at node i.\n\nNotes\n-----\nUses PETSc's `DMPlexComputeGradientClementInterpolant` which computes\nthe L2 projection of cell-wise constant gradients onto a continuous\nP1 (linear) space by averaging at shared vertices.\n\nThis is O(h) accurate - suitable for error estimation, quick visualization,\nor when higher accuracy is not required.\n\nFor higher-degree fields (P2, etc.), the function first samples the field\nat P1 vertex locations before computing the Clement gradient.\n\nExamples\n--------\n>>> T.array[:, 0, 0] = T.coords[:, 0]**2 + T.coords[:, 1]**2\n>>> grad = compute_clement_gradient_at_nodes(T)\n>>> # grad[i] \u2248 [2*x_i, 2*y_i] at each node\n\n>>> # For vector field, specify component\n>>> grad_vx = compute_clement_gradient_at_nodes(v, component=0)",
    "harvested_comments": [
      "grad[i] \u2248 [2*x_i, 2*y_i] at each node",
      "For vector field, specify component",
      "Handle multi-component fields",
      "Get vertex coordinates",
      "Get field values at P1 vertex locations"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_pure_sympy_expression",
    "kind": "function",
    "file": "src/underworld3/function/pure_sympy_evaluator.py",
    "line": 22,
    "signature": "(expr)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Detect if an expression contains only pure sympy symbols or mesh coordinates (no UW3 variable data).\n\nExpressions are considered \"pure\" (lambdifiable) if they contain:\n- Only sympy.Symbol objects\n- Only mesh coordinate BaseScalars (mesh.X[0], mesh.X[1], etc.)\n- Mix of Symbols and BaseScalars\n- No UW3 MeshVariable or SwarmVariable data\n\nParameters\n----------\nexpr : sympy expression\n    Expression to check\n\nReturns\n-------\nbool\n    True if expression can be lambdified without mesh data interpolation\nsymbols : set or None\n    Set of free symbols if pure, None otherwise\nsymbol_type : str or None\n    'symbol', 'coordinate', or 'mixed' indicating what symbols were found\n\nExamples\n--------\n>>> import sympy\n>>> x = sympy.Symbol('x')\n>>> t = sympy.Symbol('t')\n>>> is_pure_sympy_expression(x**2 + t)\n(True, {x, t}, 'symbol')\n\n>>> # With mesh coordinates\n>>> x_mesh = mesh.X[0]\n>>> is_pure_sympy_expression(sympy.erf(x_mesh - 0.5))\n(True, {N.x}, 'coordinate')\n\n>>> # With UW3 variable data - NOT pure\n>>> T = uw.discretisation.MeshVariable(\"T\", mesh, 1)\n>>> is_pure_sympy_expression(T.sym[0] + x)\n(False, None, None)",
    "harvested_comments": [
      "With mesh coordinates",
      "With UW3 variable data - NOT pure",
      "Get all free symbols",
      "Not a sympy expression",
      "Constant expression - can be handled efficiently"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_cached_lambdified",
    "kind": "function",
    "file": "src/underworld3/function/pure_sympy_evaluator.py",
    "line": 145,
    "signature": "(expr, symbols, modules = ('scipy', 'numpy'))",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "symbols",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "modules",
        "type_hint": null,
        "default": "('scipy', 'numpy')",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get a cached lambdified function for an expression.\n\nUses an LRU cache to avoid recompiling the same expression multiple times.\n\nParameters\n----------\nexpr : sympy expression\n    Expression to lambdify\nsymbols : tuple of sympy.Symbol\n    Symbols in order for lambdify\nmodules : tuple of str, optional\n    Modules to use for lambdify. Default: ('scipy', 'numpy')\n    scipy is required for special functions like erf, gamma, etc.\n\nReturns\n-------\ncallable\n    Lambdified function\n\nNotes\n-----\nCache key is based on:\n- Expression structure (hash of srepr)\n- Symbol names and order\n- Modules used",
    "harvested_comments": [
      "Create cache key",
      "Check cache",
      "Lambdify with scipy for special functions",
      "Fallback to numpy only if scipy fails"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "evaluate_pure_sympy",
    "kind": "function",
    "file": "src/underworld3/function/pure_sympy_evaluator.py",
    "line": 199,
    "signature": "(expr, coords, coord_symbols = None)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coord_symbols",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Fast evaluation of pure sympy expressions using cached lambdified functions.\n\nThis function provides optimized evaluation for expressions containing only\npure sympy symbols (no UW3 MeshVariable symbols). It automatically:\n1. Detects the free symbols in the expression\n2. Maps coordinate columns to symbols\n3. Uses cached lambdified functions for efficiency\n\nParameters\n----------\nexpr : sympy expression\n    Pure sympy expression to evaluate\ncoords : np.ndarray\n    Coordinates at which to evaluate, shape (n_points, n_dims)\n    For 2D: coords[:, 0] are x values, coords[:, 1] are y values\n    For 3D: coords[:, 0] are x, coords[:, 1] are y, coords[:, 2] are z\ncoord_symbols : tuple of sympy.Symbol, optional\n    Symbols representing coordinates in order (x, y, z)\n    If None, will try to infer from expression's free symbols\n\nReturns\n-------\nnp.ndarray\n    Evaluated expression values, shape depends on expression:\n    - Scalar expr: (n_points,) or (n_points, 1, 1)\n    - Vector expr: (n_points, n_components)\n    - Matrix expr: (n_points, n_rows, n_cols)\n\nExamples\n--------\n>>> import sympy\n>>> import numpy as np\n>>> x, y = sympy.symbols('x y')\n>>> expr = sympy.sqrt(x**2 + y**2)  # Distance from origin\n>>> coords = np.array([[1.0, 0.0], [0.0, 1.0], [3.0, 4.0]])\n>>> result = evaluate_pure_sympy(expr, coords, coord_symbols=(x, y))\n>>> # result = [1.0, 1.0, 5.0]\n\nNotes\n-----\n- Uses scipy for special functions (erf, gamma, etc.)\n- Caches lambdified functions for repeated evaluations\n- ~10,000x faster than sympy.subs() for many points",
    "harvested_comments": [
      "Distance from origin",
      "result = [1.0, 1.0, 5.0]",
      "Ensure coords is 2D numpy array",
      "Handle Matrix expressions",
      "For matrices, we'll evaluate element-wise and reshape"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "clear_lambdify_cache",
    "kind": "function",
    "file": "src/underworld3/function/pure_sympy_evaluator.py",
    "line": 426,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Clear the cached lambdified functions.\n\nUseful for testing or if memory usage becomes a concern.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "value",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 128,
    "signature": "(self) -> Union[float, np.ndarray]",
    "parameters": [],
    "returns": "Union[float, np.ndarray]",
    "existing_docstring": "Dimensional value (what the user sees).\n\nReturns\n-------\nfloat or np.ndarray\n    The value in the quantity's units",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 140,
    "signature": "(self) -> Union[float, np.ndarray]",
    "parameters": [],
    "returns": "Union[float, np.ndarray]",
    "existing_docstring": "Non-dimensional value (what the solver sees).\n\nReturns the value scaled by the model's reference quantities.\nIf no model is registered or no scaling is active, returns the\ndimensional value.\n\nReturns\n-------\nfloat or np.ndarray\n    Non-dimensional value for solver use",
    "harvested_comments": [
      "Compute non-dimensional value"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "magnitude",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 193,
    "signature": "(self) -> Union[float, np.ndarray]",
    "parameters": [],
    "returns": "Union[float, np.ndarray]",
    "existing_docstring": "Alias for .value (Pint compatibility).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 198,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the Pint Unit object.\n\nReturns\n-------\npint.Unit or None\n    The unit, or None if dimensionless",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 210,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Check if this quantity has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/function/quantities.py",
    "line": 215,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Get the Pint dimensionality dictionary.\n\nReturns\n-------\ndict\n    e.g., {'[length]': 1, '[time]': -1} for velocity",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "to",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 232,
    "signature": "(self, target_units: str) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "target_units",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Convert to different units.\n\nParameters\n----------\ntarget_units : str\n    Target units (e.g., \"m/s\", \"km\", \"degC\")\n\nReturns\n-------\nUWQuantity\n    New quantity with converted value and units",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "to_base_units",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 252,
    "signature": "(self) -> 'UWQuantity'",
    "parameters": [],
    "returns": "'UWQuantity'",
    "existing_docstring": "Convert to SI base units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "to_reduced_units",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 260,
    "signature": "(self) -> 'UWQuantity'",
    "parameters": [],
    "returns": "'UWQuantity'",
    "existing_docstring": "Simplify units by canceling common factors.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "to_compact",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 268,
    "signature": "(self) -> 'UWQuantity'",
    "parameters": [],
    "returns": "'UWQuantity'",
    "existing_docstring": "Convert to most readable unit representation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "diff",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 751,
    "signature": "(self, *args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Derivative of a constant is zero.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": true
  },
  {
    "name": "quantity",
    "kind": "function",
    "file": "src/underworld3/function/quantities.py",
    "line": 834,
    "signature": "(value: Union[float, int, np.ndarray], units: Optional[str] = None) -> UWQuantity",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Union[float, int, np.ndarray]",
        "default": null,
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "UWQuantity",
    "existing_docstring": "Create a unit-aware quantity.\n\nParameters\n----------\nvalue : float, int, or array-like\n    The numerical value\nunits : str, optional\n    Units specification (e.g., \"Pa*s\", \"cm/year\", \"K\")\n\nReturns\n-------\nUWQuantity\n    Unit-aware quantity\n\nExamples\n--------\n>>> viscosity = uw.quantity(1e21, \"Pa*s\")\n>>> velocity = uw.quantity(5, \"cm/year\")\n>>> dT = uw.quantity(1000, \"K\") - uw.quantity(273, \"K\")",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 95,
    "signature": "(obj)",
    "parameters": [
      {
        "name": "obj",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Check if an object has unit information.\n\nParameters\n----------\nobj : any\n    Object to check for unit information\n\nReturns\n-------\nbool\n    True if object has detectable units",
    "harvested_comments": [
      "Check for UWQuantity",
      "Check for Pint quantity",
      "Check for array with unit metadata",
      "Check for NDArray with unit information"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "compute_expression_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 133,
    "signature": "(expr)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute units for compound SymPy expressions using dimensional analysis.\n\nThis function traverses the expression tree and uses Pint to perform\ndimensional arithmetic on the units of sub-expressions.\n\nParameters\n----------\nexpr : sympy expression\n    Expression to analyze (e.g., temperature / y)\n\nReturns\n-------\npint.Unit or None\n    Computed unit object, or None if cannot determine\n\nExamples\n--------\n>>> # T.sym has units 'kelvin', y has units 'kilometer'\n>>> compute_expression_units(T.sym / y)\n<Unit('kelvin / kilometer')>\n\n>>> # velocity has units 'm/s', time has units 's'\n>>> compute_expression_units(velocity * time)\n<Unit('meter')>\n\n>>> # Derivative: dT/dx\n>>> compute_expression_units(T.sym.diff(mesh.N.x))\n<Unit('kelvin / kilometer')>\n\nChanged in 2025-10-16: Now returns pint.Unit objects instead of strings.",
    "harvested_comments": [
      "T.sym has units 'kelvin', y has units 'kilometer'",
      "velocity has units 'm/s', time has units 's'",
      "Derivative: dT/dx",
      "Helper to check if a pint.Unit is dimensionless",
      "Priority -1: Check for DERIVATIVES first (before general UnderworldFunction)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_mesh_coordinate_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 379,
    "signature": "(mesh_or_expr)",
    "parameters": [
      {
        "name": "mesh_or_expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get the coordinate units expected by a mesh or expression.\n\nParameters\n----------\nmesh_or_expr : Mesh or sympy expression\n    Mesh object or expression containing mesh variables\n\nReturns\n-------\ndict or None\n    Dictionary with coordinate unit information, or None if not available",
    "harvested_comments": [
      "Try to extract mesh from expression",
      "Get coordinate system information",
      "Check if mesh has coordinate scaling (units applied)",
      "Return unit information - internal units are what the mesh expects",
      "Mesh expects internal model units"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_coordinates_to_mesh_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 421,
    "signature": "(coords, mesh_info, coord_units = None)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh_info",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coord_units",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert coordinate array to mesh unit system with explicit unit specification.\n\nFollowing UW3 policy: no implicit unit conversions. Coordinates must have\nexplicit units or are assumed to be in model units.\n\nParameters\n----------\ncoords : array-like\n    Coordinate array\nmesh_info : dict\n    Mesh coordinate unit information from get_mesh_coordinate_units()\ncoord_units : str, optional\n    Explicit coordinate units. If None, assumes model coordinates.\n\nReturns\n-------\nnumpy.ndarray\n    Coordinates converted to mesh unit system\n\nRaises\n------\nValueError\n    If coordinate units are specified but mesh has no scaling context",
    "harvested_comments": [
      "Extract coordinate values and ensure float64",
      "If no mesh info or mesh is not scaled, coordinates must be model units",
      "For scaled meshes with explicit coordinate units",
      "Convert physical coordinates to model coordinates",
      "Create a temporary quantity for proper unit conversion"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "detect_coordinate_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 494,
    "signature": "(coords)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Detect what unit system coordinates are in.\n\nParameters\n----------\ncoords : array-like\n    Coordinate array\n\nReturns\n-------\ndict\n    Information about coordinate units",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_expression_units_to_result",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 515,
    "signature": "(result, expression, mesh_info)",
    "parameters": [
      {
        "name": "result",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh_info",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add appropriate units to evaluation result based on expression analysis.\n\nAnalyzes the expression to determine its physical units and converts\nthe model-unit result back to appropriate physical units.\n\nParameters\n----------\nresult : numpy.ndarray\n    Raw evaluation result in model units from PETSc\nexpression : sympy expression\n    Expression that was evaluated\nmesh_info : dict\n    Mesh coordinate unit information\n\nReturns\n-------\narray or UWQuantity\n    Result with appropriate units if detectable, otherwise plain array",
    "harvested_comments": [
      "Try to determine the units of the expression",
      "Convert result from model units to physical units",
      "No units detectable - return plain array (likely dimensionless)",
      "If unit analysis fails, return plain result"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "determine_expression_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 554,
    "signature": "(expression, mesh_info)",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh_info",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine the physical units of a SymPy expression.\n\nAnalyzes the expression to infer what units the result should have\nbased on the constituent variables and operations. This now uses\ndimensional arithmetic for compound expressions.\n\nParameters\n----------\nexpression : sympy expression\n    Expression to analyze\nmesh_info : dict\n    Mesh coordinate unit information (optional, can be None)\n\nReturns\n-------\nstr or None\n    Unit string if determinable, None if dimensionless or unknown\n\nNotes\n-----\nThis function now delegates to compute_expression_units() which performs\ndimensional arithmetic using Pint. This ensures consistent behavior between\nget_units() and determine_expression_units().",
    "harvested_comments": [
      "Use the unified dimensional analysis function",
      "If analysis fails, assume dimensionless"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_units_to_result",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 588,
    "signature": "(result, expression)",
    "parameters": [
      {
        "name": "result",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add appropriate units to evaluation result based on expression.\n\nParameters\n----------\nresult : numpy.ndarray\n    Raw evaluation result\nexpression : sympy expression\n    Expression that was evaluated\n\nReturns\n-------\narray or UWQuantity\n    Result with appropriate units if detectable",
    "harvested_comments": [
      "This is the old function - kept for backward compatibility",
      "New function is add_expression_units_to_result"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_quantity_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 609,
    "signature": "(quantity, target_units)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_units",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert UWQuantity or Pint quantity to target units.\n\nParameters\n----------\nquantity : UWQuantity, Pint quantity, or array-like\n    The quantity to convert\ntarget_units : str or Pint unit\n    Target units to convert to\n\nReturns\n-------\nconverted quantity\n    Quantity converted to target units",
    "harvested_comments": [
      "Handle UWQuantity",
      "Convert using Pint",
      "Return new UWQuantity",
      "Handle direct Pint quantity",
      "Handle plain arrays - assume they're already in target units"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "detect_quantity_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 643,
    "signature": "(obj)",
    "parameters": [
      {
        "name": "obj",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Detect units of any object (UWQuantity, Pint, array with metadata).\n\nParameters\n----------\nobj : any\n    Object to detect units from\n\nReturns\n-------\ndict\n    Dictionary with unit information:\n    - 'has_units': bool\n    - 'units': str or None\n    - 'is_dimensionless': bool\n    - 'unit_type': str ('UWQuantity', 'Pint', 'metadata', 'none')",
    "harvested_comments": [
      "Check for UWQuantity",
      "Check for Pint quantity",
      "Check for array with unit metadata",
      "Check for NDArray with unit information",
      "No units detected"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "make_dimensionless",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 706,
    "signature": "(quantity, reference_scales)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "reference_scales",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert physical quantity to dimensionless using reference scales.\n\nParameters\n----------\nquantity : UWQuantity or Pint quantity\n    Physical quantity to make dimensionless\nreference_scales : dict or Model\n    Dictionary of reference scales or Model with reference quantities\n\nReturns\n-------\nUWQuantity\n    Dimensionless quantity",
    "harvested_comments": [
      "Handle Model object",
      "Get quantity info",
      "Already dimensionless",
      "Extract Pint quantity",
      "Determine appropriate scale based on quantity dimensions"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_array_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 795,
    "signature": "(array, from_units, to_units)",
    "parameters": [
      {
        "name": "array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "from_units",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "to_units",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array from one unit system to another.\n\nParameters\n----------\narray : array-like\n    Array values to convert\nfrom_units : str or Pint unit\n    Source units\nto_units : str or Pint unit\n    Target units\n\nReturns\n-------\nnumpy.ndarray\n    Converted array values",
    "harvested_comments": [
      "Create a temporary quantity for conversion",
      "Extract the magnitude"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "auto_convert_to_mesh_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 828,
    "signature": "(array, mesh)",
    "parameters": [
      {
        "name": "array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array coordinates to mesh unit system.\n\nParameters\n----------\narray : array-like\n    Coordinate array that may have units\nmesh : Mesh\n    Mesh to get unit system from\n\nReturns\n-------\nnumpy.ndarray\n    Coordinates converted to mesh unit system",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_evaluation_result",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 848,
    "signature": "(result, target_units)",
    "parameters": [
      {
        "name": "result",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_units",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert evaluation results to target unit system.\n\nParameters\n----------\nresult : array-like or UWQuantity\n    Evaluation result to convert\ntarget_units : str or Pint unit\n    Target units to convert to\n\nReturns\n-------\nconverted result\n    Result converted to target units",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_units",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 867,
    "signature": "(array, units_str)",
    "parameters": [
      {
        "name": "array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "units_str",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add unit metadata to plain array.\n\nParameters\n----------\narray : array-like\n    Plain array to add units to\nunits_str : str\n    Unit string to associate with array\n\nReturns\n-------\nUWQuantity\n    Array wrapped with unit information",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "make_evaluate_unit_aware",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 888,
    "signature": "(original_evaluate_func)",
    "parameters": [
      {
        "name": "original_evaluate_func",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Decorator to make evaluate functions unit-aware with explicit unit specification.\n\nThis wraps the original evaluate function to:\n1. Accept explicit coordinate units parameter\n2. Convert coordinates to mesh units if units are specified\n3. Assume model coordinates if no units specified\n4. Convert results back to appropriate physical units\n\nFollowing UW3 policy: no implicit unit detection or conversion.\n\nParameters\n----------\noriginal_evaluate_func : callable\n    Original evaluate function to wrap\n\nReturns\n-------\ncallable\n    Unit-aware version of the function",
    "harvested_comments": [
      "Auto-extract .sym from MeshVariable for user convenience",
      "This is likely a MeshVariable - extract the symbolic representation",
      "Handle the case where no coordinates are provided",
      "Get mesh coordinate unit information",
      "Approach 1: Use coord_sys if provided"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "query",
    "kind": "method",
    "file": "src/underworld3/kdtree.py",
    "line": 149,
    "signature": "(self, coords, k = 1, sqr_dists = True)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "k",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "sqr_dists",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Find the n points closest to the provided coordinates.\n\nThis method is unit-aware: if the KD-tree was built with unit-aware coordinates,\nit will automatically convert query coordinates to match and return distances\nwith appropriate units.\n\nParameters\n----------\ncoords : array-like\n    An array of coordinates for which the kd-tree index will be searched for nearest\n    neighbours. This should be a 2-dimensional array of size (n_coords, dim).\n    Can be unit-aware (UnitAwareArray) or plain numpy array.\n    If KD-tree has coordinate units, coords must have compatible units.\nk : int, optional\n    The number of nearest neighbour points to find for each `coords` (default 1).\nsqr_dists : bool, optional\n    Set to True to return the squared distances, set to False to return the actual\n    distances (default True).\n\nReturns\n-------\nd : array\n    A float array of the squared (sqr_dists = True) or actual distances (sqr_dists = False)\n    between the provided coords and the nearest neighbouring points.\n    If KD-tree has coordinate units and sqr_dists=False, distances will be unit-aware.\n    Shape is (n_coords,) for k=1, or (n_coords, k) for k>1.\ni : array\n    An integer array of indices into the `points` array (passed into the constructor)\n    corresponding to the nearest neighbour for the search coordinates.\n    Shape is (n_coords,) for k=1, or (n_coords, k) for k>1.",
    "harvested_comments": [
      "Convert coordinates to match tree's coordinate system",
      "Query parent KD-tree (returns actual distances, not squared)",
      "Handle distance units",
      "Squared distances - dimensionless or have squared units",
      "For now, return as plain array (squared units are complex to handle)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "KDTree",
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local_from_kdtree",
    "kind": "method",
    "file": "src/underworld3/kdtree.py",
    "line": 203,
    "signature": "(self, coords, data, nnn, p, verbose)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "data",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "p",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Performs an inverse distance (squared) mapping of data to the target `coords`.\n\nThis method is unit-aware: if the KD-tree was built with unit-aware coordinates,\nit will automatically convert query coordinates to match before interpolation.\n\nParameters\n----------\ncoords : array-like\n    The target spatial coordinates to evaluate the data from.\n    Can be unit-aware (UnitAwareArray) or plain numpy array.\n    If KD-tree has coordinate units, coords must have compatible units.\n    coords.shape[1] == self.ndim\ndata : ndarray\n    The known data to map from. Must be fully described over kd-tree.\n    i.e., data.shape[0] == self.n\nnnn : int\n    The number of neighbour points to sample from. If `1`, no distance averaging is done.\np : int\n    The power index to calculate weights, i.e., pow(distance, -p)\nverbose : bool\n    Print when mapping occurs\n\nReturns\n-------\nndarray\n    Interpolated data values at target coordinates",
    "harvested_comments": [
      "Convert coordinates to match tree's coordinate system",
      "query nnn points to the coords using wrapped query function",
      "distance_n is a list of distance to the nearest neighbours for all coords_contiguous",
      "closest_n is the index of the neighbours from ncoords for all coords_contiguous",
      "Note: We use the converted coordinates here, and query() will handle them properly"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "KDTree",
    "is_public": true
  },
  {
    "name": "set_property",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 75,
    "signature": "(self, prop: Union[MaterialProperty, str], value: Any)",
    "parameters": [
      {
        "name": "prop",
        "type_hint": "Union[MaterialProperty, str]",
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Any",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set a material property value",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialDefinition",
    "is_public": true
  },
  {
    "name": "get_property",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 80,
    "signature": "(self, prop: Union[MaterialProperty, str], default = None)",
    "parameters": [
      {
        "name": "prop",
        "type_hint": "Union[MaterialProperty, str]",
        "default": null,
        "description": ""
      },
      {
        "name": "default",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get a material property value",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialDefinition",
    "is_public": true
  },
  {
    "name": "has_property",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 85,
    "signature": "(self, prop: Union[MaterialProperty, str]) -> bool",
    "parameters": [
      {
        "name": "prop",
        "type_hint": "Union[MaterialProperty, str]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if material has a specific property",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialDefinition",
    "is_public": true
  },
  {
    "name": "evaluate_property",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 90,
    "signature": "(self, prop: Union[MaterialProperty, str], temperature = None, pressure = None)",
    "parameters": [
      {
        "name": "prop",
        "type_hint": "Union[MaterialProperty, str]",
        "default": null,
        "description": ""
      },
      {
        "name": "temperature",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "pressure",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate a material property, accounting for temperature/pressure dependence.\n\nParameters:\n-----------\nprop : MaterialProperty or str\n    Property to evaluate\ntemperature : float or array, optional\n    Temperature for evaluation\npressure : float or array, optional\n    Pressure for evaluation\n\nReturns:\n--------\nProperty value (scalar or array)",
    "harvested_comments": [
      "Get base value",
      "Apply temperature dependence",
      "Apply pressure dependence"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "MaterialDefinition",
    "is_public": true
  },
  {
    "name": "create_material",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 156,
    "signature": "(self, name: str, description: str = '', reference: str = '') -> MaterialDefinition",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "description",
        "type_hint": "str",
        "default": "''",
        "description": ""
      },
      {
        "name": "reference",
        "type_hint": "str",
        "default": "''",
        "description": ""
      }
    ],
    "returns": "MaterialDefinition",
    "existing_docstring": "Create a new material definition.\n\nParameters:\n-----------\nname : str\n    Material name\ndescription : str\n    Human-readable description\nreference : str\n    Literature reference\n\nReturns:\n--------\nMaterialDefinition\n    New material instance",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "get_material",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 186,
    "signature": "(self, name: str) -> Optional[MaterialDefinition]",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Optional[MaterialDefinition]",
    "existing_docstring": "Get a material by name",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "list_materials",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 190,
    "signature": "(self) -> List[str]",
    "parameters": [],
    "returns": "List[str]",
    "existing_docstring": "List all material names",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "delete_material",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 194,
    "signature": "(self, name: str)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Delete a material definition",
    "harvested_comments": [
      "Remove any region assignments"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "assign_to_region",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 206,
    "signature": "(self, material_name: str, region_id: int)",
    "parameters": [
      {
        "name": "material_name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "region_id",
        "type_hint": "int",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Assign a material to a mesh region.\n\nParameters:\n-----------\nmaterial_name : str\n    Name of material to assign\nregion_id : int\n    Mesh region identifier",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "get_region_material",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 223,
    "signature": "(self, region_id: int) -> Optional[str]",
    "parameters": [
      {
        "name": "region_id",
        "type_hint": "int",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Optional[str]",
    "existing_docstring": "Get the material assigned to a region",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "get_material_regions",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 227,
    "signature": "(self, material_name: str) -> List[int]",
    "parameters": [
      {
        "name": "material_name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "List[int]",
    "existing_docstring": "Get all regions assigned to a material",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "evaluate_property_field",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 235,
    "signature": "(self, prop: Union[MaterialProperty, str], region_field: np.ndarray, temperature: Optional[np.ndarray] = None, pressure: Optional[np.ndarray] = None) -> np.ndarray",
    "parameters": [
      {
        "name": "prop",
        "type_hint": "Union[MaterialProperty, str]",
        "default": null,
        "description": ""
      },
      {
        "name": "region_field",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "temperature",
        "type_hint": "Optional[np.ndarray]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressure",
        "type_hint": "Optional[np.ndarray]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "np.ndarray",
    "existing_docstring": "Evaluate a material property over a field of region IDs.\n\nParameters:\n-----------\nprop : MaterialProperty or str\n    Property to evaluate\nregion_field : array\n    Array of region IDs\ntemperature : array, optional\n    Temperature field for evaluation\npressure : array, optional\n    Pressure field for evaluation\n\nReturns:\n--------\narray\n    Property values corresponding to each region",
    "harvested_comments": [
      "Initialize output array",
      "Evaluate property for each unique region",
      "Get mask for this region",
      "Extract temperature/pressure for this region if provided",
      "Evaluate property for this region"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "add_callback",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 293,
    "signature": "(self, callback: Callable)",
    "parameters": [
      {
        "name": "callback",
        "type_hint": "Callable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add a callback function for material changes.\n\nParameters:\n-----------\ncallback : callable\n    Function called as callback(event_type, *args)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "export_config",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 312,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "Export material configuration",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "import_config",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 327,
    "signature": "(self, config: Dict[str, Any])",
    "parameters": [
      {
        "name": "config",
        "type_hint": "Dict[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Import material configuration from exported dict",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": true
  },
  {
    "name": "create_standard_mantle_material",
    "kind": "function",
    "file": "src/underworld3/materials.py",
    "line": 344,
    "signature": "(registry: MaterialRegistry) -> MaterialDefinition",
    "parameters": [
      {
        "name": "registry",
        "type_hint": "MaterialRegistry",
        "default": null,
        "description": ""
      }
    ],
    "returns": "MaterialDefinition",
    "existing_docstring": "Create a standard mantle material with typical properties",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_standard_crust_material",
    "kind": "function",
    "file": "src/underworld3/materials.py",
    "line": 361,
    "signature": "(registry: MaterialRegistry) -> MaterialDefinition",
    "parameters": [
      {
        "name": "registry",
        "type_hint": "MaterialRegistry",
        "default": null,
        "description": ""
      }
    ],
    "returns": "MaterialDefinition",
    "existing_docstring": "Create a standard crustal material with typical properties",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_high_viscosity_material",
    "kind": "function",
    "file": "src/underworld3/materials.py",
    "line": 378,
    "signature": "(registry: MaterialRegistry, name: str = 'high_visc', viscosity_contrast: float = 1000) -> MaterialDefinition",
    "parameters": [
      {
        "name": "registry",
        "type_hint": "MaterialRegistry",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "'high_visc'",
        "description": ""
      },
      {
        "name": "viscosity_contrast",
        "type_hint": "float",
        "default": "1000",
        "description": ""
      }
    ],
    "returns": "MaterialDefinition",
    "existing_docstring": "Create a high viscosity material for inclusion studies",
    "harvested_comments": [
      "Base properties similar to mantle"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "delta",
    "kind": "function",
    "file": "src/underworld3/maths/functions.py",
    "line": 21,
    "signature": "(x: sympy.Basic, epsilon: float)",
    "parameters": [
      {
        "name": "x",
        "type_hint": "sympy.Basic",
        "default": null,
        "description": ""
      },
      {
        "name": "epsilon",
        "type_hint": "float",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Smoothed (Gaussian) approximation to the Dirac delta function.\n\nReturns a Gaussian with integral 1, approximating :math:`\\delta(x)`\nas :math:`\\epsilon \\to 0`:\n\n.. math::\n\n    \\delta_\\epsilon(x) = \\frac{1}{\\epsilon\\sqrt{2\\pi}}\n    \\exp\\left(-\\frac{x^2}{2\\epsilon^2}\\right)\n\nParameters\n----------\nx : sympy.Basic\n    Symbolic expression (typically a coordinate or distance function).\nepsilon : float\n    Smoothing width. Smaller values give sharper peaks.\n\nReturns\n-------\nsympy.Expr\n    Gaussian approximation to the delta function.\n\nNotes\n-----\nUseful for representing interfaces, point sources, or boundary layers\nin a regularized form suitable for finite element integration.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "L2_norm",
    "kind": "function",
    "file": "src/underworld3/maths/functions.py",
    "line": 59,
    "signature": "(n_s, a_s, mesh)",
    "parameters": [
      {
        "name": "n_s",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "a_s",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "L2 norm of the difference between numerical and analytical solutions.\n\nComputes:\n\n.. math::\n\n    \\|n - a\\|_{L^2} = \\sqrt{\\int_\\Omega (n - a)^2 \\, d\\Omega}\n\nFor vector fields, uses the dot product:\n\n.. math::\n\n    \\|\\mathbf{n} - \\mathbf{a}\\|_{L^2} = \\sqrt{\\int_\\Omega\n    (\\mathbf{n} - \\mathbf{a}) \\cdot (\\mathbf{n} - \\mathbf{a}) \\, d\\Omega}\n\nParameters\n----------\nn_s : sympy.Expr or sympy.Matrix\n    Numerical solution (scalar or vector field).\na_s : sympy.Expr or sympy.Matrix\n    Analytical solution (scalar or vector field).\nmesh : Mesh\n    The mesh over which to integrate.\n\nReturns\n-------\nfloat\n    L2 norm of the error.",
    "harvested_comments": [
      "Check if the input is a vector (SymPy Matrix)",
      "Compute squared difference using dot product for vectors",
      "Compute squared difference for scalars",
      "Integral over the domain",
      "Compute the L2 norm"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank2_symmetric_sym",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 45,
    "signature": "(name, dim)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Rank 2 symmetric tensor (as symbolic matrix), name is a sympy latex expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank4_symmetric_sym",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 58,
    "signature": "(name, dim)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Rank 4 symmetric tensor (as symbolic matrix), name is a sympy latex expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "tensor_rotation",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 77,
    "signature": "(R, T)",
    "parameters": [
      {
        "name": "R",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "T",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Rotate tensor of any rank using matrix R",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank2_to_voigt",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 179,
    "signature": "(v_ij, dim, covariant = True)",
    "parameters": [
      {
        "name": "v_ij",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "covariant",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank-2 tensor :math:`v_{ij}` to Voigt (vector) form :math:`V_I`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "voigt_to_rank2",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 197,
    "signature": "(V_I, dim, covariant = True)",
    "parameters": [
      {
        "name": "V_I",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "covariant",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert to rank 2 tensor (v_ij) from voigt (vector) form (V_I)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank4_to_voigt",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 215,
    "signature": "(c_ijkl, dim)",
    "parameters": [
      {
        "name": "c_ijkl",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank 4 tensor (c_ijkl) to voigt (matrix) form (C_IJ)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "voigt_to_rank4",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 227,
    "signature": "(C_IJ, dim)",
    "parameters": [
      {
        "name": "C_IJ",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert to rank 4 tensor (c_ijkl) from voigt (matrix) form (C_IJ)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank2_to_mandel",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 236,
    "signature": "(v_ij, dim)",
    "parameters": [
      {
        "name": "v_ij",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank-2 tensor to Mandel vector form.\n\nMandel notation scales off-diagonal terms by :math:`\\sqrt{2}`,\npreserving inner products under vector operations.\n\nParameters\n----------\nv_ij : sympy.Matrix\n    Symmetric rank-2 tensor as (dim x dim) matrix.\ndim : int\n    Spatial dimension (2 or 3).\n\nReturns\n-------\nsympy.Matrix\n    Mandel vector (3 components for 2D, 6 for 3D).",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank4_to_mandel",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 262,
    "signature": "(c_ijkl, dim)",
    "parameters": [
      {
        "name": "c_ijkl",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank-4 tensor to Mandel matrix form.\n\nParameters\n----------\nc_ijkl : sympy.NDimArray\n    Symmetric rank-4 tensor (dim x dim x dim x dim).\ndim : int\n    Spatial dimension (2 or 3).\n\nReturns\n-------\nsympy.Matrix\n    Mandel matrix (3x3 for 2D, 6x6 for 3D).",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mandel_to_rank2",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 284,
    "signature": "(v_I, dim)",
    "parameters": [
      {
        "name": "v_I",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Mandel vector to rank-2 tensor form.\n\nParameters\n----------\nv_I : sympy.Matrix\n    Mandel vector (3 components for 2D, 6 for 3D).\ndim : int\n    Spatial dimension (2 or 3).\n\nReturns\n-------\nsympy.Matrix\n    Symmetric rank-2 tensor as (dim x dim) matrix.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "mandel_to_rank4",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 305,
    "signature": "(c_IJ, dim)",
    "parameters": [
      {
        "name": "c_IJ",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Mandel matrix to rank-4 tensor form.\n\nParameters\n----------\nc_IJ : sympy.Matrix\n    Mandel matrix (3x3 for 2D, 6x6 for 3D).\ndim : int\n    Spatial dimension (2 or 3).\n\nReturns\n-------\nsympy.NDimArray\n    Symmetric rank-4 tensor (dim x dim x dim x dim).",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank4_identity",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 326,
    "signature": "(dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Symmetric fourth-order identity tensor.\n\nConstructs the identity tensor for symmetric second-order tensors:\n\n.. math::\n\n    I_{ijkl} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})\n\nThis tensor satisfies :math:`I_{ijkl} \\sigma_{kl} = \\sigma_{ij}` for\nsymmetric :math:`\\sigma`.\n\nParameters\n----------\ndim : int\n    Spatial dimension (2 or 3).\n\nReturns\n-------\nsympy.NDimArray\n    Fourth-order identity tensor (dim x dim x dim x dim).",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rank2_inner_product",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 360,
    "signature": "(A, B)",
    "parameters": [
      {
        "name": "A",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "B",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Double contraction (inner product) of two rank-2 tensors.\n\nComputes:\n\n.. math::\n\n    p = \\sum_i \\sum_j A_{ij} B_{ij} = A : B\n\nParameters\n----------\nA : sympy.Matrix or sympy.NDimArray\n    First rank-2 tensor.\nB : sympy.Matrix or sympy.NDimArray\n    Second rank-2 tensor.\n\nReturns\n-------\nsympy.Expr\n    Scalar result of the double contraction.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "cross",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 67,
    "signature": "(self, vector1, vector2)",
    "parameters": [
      {
        "name": "vector1",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "vector2",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Cross product of two vector fields.\n\nParameters\n----------\nvector1 : sympy.Matrix\n    First vector as row matrix.\nvector2 : sympy.Matrix\n    Second vector as row matrix.\n\nReturns\n-------\nsympy.Matrix\n    Cross product :math:`\\mathbf{a} \\times \\mathbf{b}` as row matrix.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 91,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Curl of a vector field: :math:`\\nabla \\times \\mathbf{v}`.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix.\n\nReturns\n-------\nsympy.Matrix or sympy.Expr\n    In 3D: curl vector as row matrix.\n    In 2D: scalar (out-of-plane component, i.e., vorticity).",
    "harvested_comments": [
      "if 2d, the out-of-plane vector is not defined in the basis so a scalar is returned (cf. vorticity)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 116,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Divergence of a vector field: :math:`\\nabla \\cdot \\mathbf{v}`.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix.\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 134,
    "signature": "(self, scalar)",
    "parameters": [
      {
        "name": "scalar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Gradient of a scalar field: :math:`\\nabla \\phi`.\n\nParameters\n----------\nscalar : sympy.Expr or sympy.Matrix\n    Scalar field. If (1,1) matrix, extracts the scalar.\n\nReturns\n-------\nsympy.Matrix\n    Gradient vector as row matrix.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "strain_tensor",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 154,
    "signature": "(self, vector)",
    "parameters": [
      {
        "name": "vector",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Symmetric gradient (strain or strain-rate tensor).\n\nComputes the infinitesimal strain tensor from displacement,\nor strain-rate tensor from velocity:\n\n.. math::\n\n    \\varepsilon_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)\n\nParameters\n----------\nvector : sympy.Matrix or sympy.vector.Vector\n    Displacement or velocity field.\n\nReturns\n-------\nsympy.Matrix\n    Symmetric (dim x dim) strain tensor.",
    "harvested_comments": [
      "Coerce vector to sympy.Matrix form"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "to_vector",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 184,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert row matrix to SymPy vector form.\n\nParameters\n----------\nmatrix : sympy.Matrix or sympy.vector.Vector\n    Vector as row or column matrix.\n\nReturns\n-------\nsympy.vector.Vector\n    Vector in the mesh's coordinate system basis.",
    "harvested_comments": [
      "No need to convert",
      "Note, the mesh vector basis is always 3D so out-of-plane",
      "vectors are allowed."
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "to_matrix",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 216,
    "signature": "(self, vector)",
    "parameters": [
      {
        "name": "vector",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert SymPy vector to row matrix form.\n\nParameters\n----------\nvector : sympy.vector.Vector or sympy.Matrix\n    Vector to convert.\n\nReturns\n-------\nsympy.Matrix\n    Row matrix (1 x dim) representation.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "jacobian",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 247,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Jacobian matrix of a field with respect to mesh coordinates.\n\nParameters\n----------\nmatrix : sympy.Matrix or sympy.vector.Vector\n    Scalar, vector, or matrix field.\n\nReturns\n-------\nsympy.Matrix\n    Jacobian matrix of partial derivatives.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 302,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Divergence of a vector field in cylindrical coordinates.\n\nComputes :math:`\\nabla \\cdot \\mathbf{v}` with the cylindrical\nmetric terms:\n\n.. math::\n\n    \\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_r}{\\partial r}\n    + \\frac{v_r}{r} + \\frac{1}{r}\\frac{\\partial v_\\theta}{\\partial \\theta}\n    + \\frac{\\partial v_z}{\\partial z}\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_r, v_\\theta, v_z)`.\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence.",
    "harvested_comments": [
      "Or is this cdim ?"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_cylindrical",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 340,
    "signature": "(self, scalar)",
    "parameters": [
      {
        "name": "scalar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Gradient of a scalar field in cylindrical coordinates.\n\nComputes :math:`\\nabla \\phi` with the cylindrical metric:\n\n.. math::\n\n    \\nabla \\phi = \\frac{\\partial \\phi}{\\partial r}\\hat{r}\n    + \\frac{1}{r}\\frac{\\partial \\phi}{\\partial \\theta}\\hat{\\theta}\n    + \\frac{\\partial \\phi}{\\partial z}\\hat{z}\n\nParameters\n----------\nscalar : sympy.Expr or sympy.Matrix\n    Scalar field. If (1,1) matrix, extracts the scalar.\n\nReturns\n-------\nsympy.Matrix\n    Gradient vector as row matrix.",
    "harvested_comments": [
      "Or is this cdim ?"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_cylindrical",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 380,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Curl of a vector field in cylindrical coordinates.\n\nComputes :math:`\\nabla \\times \\mathbf{v}` with cylindrical metric terms.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_r, v_\\theta, v_z)`.\n\nReturns\n-------\nsympy.Matrix or sympy.Expr\n    In 3D: curl vector as row matrix.\n    In 2D: scalar (out-of-plane vorticity component).",
    "harvested_comments": [
      "if 2D, return a scalar of the out-of-plane curl"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_cylindrical",
    "is_public": true
  },
  {
    "name": "strain_tensor",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 420,
    "signature": "(self, vector)",
    "parameters": [
      {
        "name": "vector",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Strain tensor in cylindrical coordinates.\n\nComputes the symmetric gradient with cylindrical metric corrections.\nAdditional terms arise from coordinate curvature.\n\nParameters\n----------\nvector : sympy.Matrix\n    Displacement or velocity field :math:`(v_r, v_\\theta, v_z)`.\n\nReturns\n-------\nsympy.Matrix\n    Symmetric (dim x dim) strain tensor with cylindrical corrections.",
    "harvested_comments": [
      "Coerce vector to sympy.Matrix form",
      "E_00, E_22 and E_02 are unchanged from Cartesian",
      "E[0,0] = L[0,0]"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_cylindrical",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 628,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Divergence of a vector field in spherical coordinates.\n\nComputes :math:`\\nabla \\cdot \\mathbf{v}` with spherical metric terms.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_r, v_\\theta, v_\\phi)`.\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence.",
    "harvested_comments": [
      "cosecant_th = sympy.Piecewise(",
      "(1000, sympy.Abs(t) < 0.01 * sympy.pi), (1 / sympy.sin(t), True)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 667,
    "signature": "(self, scalar)",
    "parameters": [
      {
        "name": "scalar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Gradient of a scalar field in spherical coordinates.\n\nComputes :math:`\\nabla \\phi` with spherical metric terms.\n\nParameters\n----------\nscalar : sympy.Expr or sympy.Matrix\n    Scalar field. If (1,1) matrix, extracts the scalar.\n\nReturns\n-------\nsympy.Matrix\n    Gradient vector as row matrix :math:`(\\partial_r, \\partial_\\theta/r, \\partial_\\phi/(r\\sin\\theta))`.",
    "harvested_comments": [
      "grad_S[2] = sympy.Piecewise(",
      "(1000, sympy.Abs(p) < 0.01 * sympy.pi),",
      "(scalar.diff(p) / (r * sympy.sin(t)), True),"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 704,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Curl of a vector field in spherical coordinates.\n\nComputes :math:`\\nabla \\times \\mathbf{v}` with spherical metric terms.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_r, v_\\theta, v_\\phi)`.\n\nReturns\n-------\nsympy.Matrix\n    Curl vector as row matrix.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical",
    "is_public": true
  },
  {
    "name": "strain_tensor",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 739,
    "signature": "(self, vector)",
    "parameters": [
      {
        "name": "vector",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Strain tensor in spherical coordinates.\n\nComputes the symmetric gradient with spherical metric corrections\nfor :math:`(r, \\theta, \\phi)` coordinates.\n\nParameters\n----------\nvector : sympy.Matrix\n    Displacement or velocity field :math:`(v_r, v_\\theta, v_\\phi)`.\n\nReturns\n-------\nsympy.Matrix\n    Symmetric (3 x 3) strain tensor with spherical corrections.",
    "harvested_comments": [
      "Coerce vector to sympy.Matrix form"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 819,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Divergence of a vector field on a spherical surface.\n\nComputes :math:`\\nabla \\cdot \\mathbf{v}` with surface metric terms.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_\\lambda, v_\\phi)`.\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence on the surface.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 854,
    "signature": "(self, scalar)",
    "parameters": [
      {
        "name": "scalar",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Gradient of a scalar field on a spherical surface.\n\nComputes :math:`\\nabla \\phi` on the unit sphere.\n\nParameters\n----------\nscalar : sympy.Expr or sympy.Matrix\n    Scalar field. If (1,1) matrix, extracts the scalar.\n\nReturns\n-------\nsympy.Matrix\n    Gradient vector as row matrix :math:`(\\partial_\\lambda/\\cos\\phi, \\partial_\\phi)`.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 887,
    "signature": "(self, matrix)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Curl on a spherical surface.\n\nComputes the scalar vorticity (out-of-surface curl component)\non the unit sphere.\n\nParameters\n----------\nmatrix : sympy.Matrix\n    Vector field as row matrix :math:`(v_\\lambda, v_\\phi)`.\n\nReturns\n-------\nsympy.Expr\n    Scalar vorticity (radial component of curl).",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "is_public": true
  },
  {
    "name": "strain_tensor",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 920,
    "signature": "(self, vector)",
    "parameters": [
      {
        "name": "vector",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Strain tensor on a spherical surface.\n\nComputes the symmetric gradient on the unit sphere with\nsurface metric corrections.\n\nParameters\n----------\nvector : sympy.Matrix\n    Displacement or velocity field :math:`(v_\\lambda, v_\\phi)`.\n\nReturns\n-------\nsympy.Matrix\n    Symmetric (2 x 2) strain tensor on the surface.",
    "harvested_comments": [
      "Coerce vector to sympy.Matrix form",
      "E_00, E_22 and E_02 are unchanged from Cartesian"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "is_public": true
  },
  {
    "name": "QuarterAnnulus",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 33,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, angle: float = 45, cellSize: float = 0.1, centre: bool = False, degree: int = 1, qdegree: int = 2, filename = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "angle",
        "type_hint": "float",
        "default": "45",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "centre",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a quarter-annulus (wedge) mesh in 2D.\n\nGenerates a pie-slice shaped mesh bounded by inner and outer circular\narcs and two radial edges. Provides :math:`(r, \\theta)` coordinates\nfor convenient representation of radial problems.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the annulus. Supports UWQuantity objects for\n    automatic unit conversion.\nradiusInner : float, default=0.547\n    Inner radius of the annulus. Set to 0 for a disc sector\n    extending to the centre.\nangle : float, default=45\n    Angular extent of the wedge in degrees. The wedge spans from\n    ``-angle`` to ``+angle`` (total sweep = 2 * angle).\ncellSize : float, default=0.1\n    Target mesh element size.\ncentre : bool, default=False\n    If True and ``radiusInner=0``, mark the centre point as a\n    boundary for applying point constraints.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D mesh with boundaries:\n\n    - ``Lower``: Inner arc at :math:`r = r_{inner}`\n    - ``Upper``: Outer arc at :math:`r = r_{outer}`\n    - ``Left``: Left radial edge\n    - ``Right``: Right radial edge\n    - ``Centre``: Centre point (if :math:`r_{inner} = 0`)\n\nSee Also\n--------\nAnnulus : Full 360-degree annulus.\nSegmentofAnnulus : Partial annulus with arbitrary angle.\n\nExamples\n--------\nCreate a quarter-disc (no inner hole):\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.QuarterAnnulus(\n...     radiusOuter=1.0,\n...     radiusInner=0.0,\n...     angle=45,\n...     cellSize=0.05\n... )\n\nNotes\n-----\nThe mesh coordinate system provides unit vectors via\n``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: tangential direction :math:`(\\theta)`",
    "harvested_comments": [
      "Convert unit-aware quantities to non-dimensional units",
      "This enables: QuarterAnnulus(radiusOuter=uw.quantity(6370, \"km\"), ...)",
      "angle is in degrees, not a length - don't convert",
      "gmsh.model.geo.rotate([(p2, p3)], 0, 0, 0, 0, 0.3, 0, math.pi / 2)",
      "add boundary normal information to the new mesh"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Annulus",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 273,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, cellSize: float = 0.1, cellSizeOuter: float = None, cellSizeInner: float = None, centre: bool = False, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "cellSizeOuter",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSizeInner",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "centre",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a full 2D annulus mesh.\n\nGenerates a ring-shaped mesh (or disc if ``radiusInner=0``) using\ntriangular elements. Provides :math:`(r, \\theta)` coordinates with\nradial boundary normal directions.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the annulus. Supports UWQuantity objects.\nradiusInner : float, default=0.547\n    Inner radius of the annulus. Set to 0 for a full disc.\ncellSize : float, default=0.1\n    Default target mesh element size.\ncellSizeOuter : float, optional\n    Element size at the outer boundary. Defaults to ``cellSize``.\ncellSizeInner : float, optional\n    Element size at the inner boundary. Defaults to ``cellSize``.\n    Use different sizes to create graded meshes.\ncentre : bool, default=False\n    If True and ``radiusInner=0``, mark the centre point as a\n    boundary for applying point constraints.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply. Each level\n    approximately quadruples element count.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D mesh with boundaries:\n\n    - ``Lower``: Inner boundary at :math:`r = r_{inner}`\n    - ``Upper``: Outer boundary at :math:`r = r_{outer}`\n    - ``Centre``: Centre point (if :math:`r_{inner} = 0`)\n\n    The mesh includes a refinement callback that snaps boundary\n    nodes back to true circular geometry after refinement.\n\nSee Also\n--------\nQuarterAnnulus : Partial annulus with radial edges.\nAnnulusInternalBoundary : Annulus with an internal interface.\nSphericalShell : 3D equivalent for spherical geometries.\n\nExamples\n--------\nCreate a standard annulus for mantle convection:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.Annulus(\n...     radiusOuter=1.0,\n...     radiusInner=0.547,\n...     cellSize=0.05\n... )\n\nCreate a graded mesh (finer at inner boundary):\n\n>>> mesh = uw.meshing.Annulus(\n...     radiusOuter=1.0,\n...     radiusInner=0.5,\n...     cellSizeOuter=0.1,\n...     cellSizeInner=0.02\n... )\n\nNotes\n-----\nThe inner radius default of 0.547 corresponds approximately to the\nEarth's core-mantle boundary radius ratio (3480/6371).\n\nThe mesh coordinate system provides unit vectors via\n``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: tangential direction :math:`(\\theta)`\n\nFor free-slip boundary conditions on vector problems (e.g., Stokes),\nuse a penalty on the normal velocity component::\n\n    Gamma_N = mesh.Gamma  # discrete normal, or\n    Gamma_N = mesh.CoordinateSystem.unit_e_0  # analytic radial\n    stokes.add_natural_bc(\n        penalty * Gamma_N.dot(v_soln.sym) * Gamma_N, \"Upper\"\n    )",
    "harvested_comments": [
      "discrete normal, or",
      "analytic radial",
      "Convert unit-aware quantities to non-dimensional units",
      "This enables: Annulus(radiusOuter=uw.quantity(6370, \"km\"), ...)",
      "l1 = gmsh.model.geo.add_line(p5, p4)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SegmentofAnnulus",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 545,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, angleExtent: float = 45, cellSize: float = 0.1, centre: bool = False, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "angleExtent",
        "type_hint": "float",
        "default": "45",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "centre",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates a segment of an annulus using Gmsh. This function creates a 2D mesh of an annular segment defined by outer and inner radii,\nand the extent of the angle. The mesh can be customized with various parameters like cell size, element degree, and verbosity.\n\nParameters:\n-----------\nradiusOuter : float, optional\n    The outer radius of the annular segment. Default is 1.0.\n\nradiusInner : float, optional\n    The inner radius of the annular segment. Default is 0.547.\n\nangleExtent : float, optional\n    The angular extent of the segment in degrees. Default is 45.\n\ncellSize : float, optional\n    The target size for the mesh elements. This controls the density of the mesh. Default is 0.1.\n\ncentre : bool, optional\n    If True, the segment will be centered at the origin. If False, the segment is positioned based on the radii. Default is False.\n\ndegree : int, optional\n    The polynomial degree of the finite elements used in the mesh. Default is 1.\n\nqdegree : int, optional\n    The quadrature degree for integration. Higher values may improve accuracy but increase computation time. Default is 2.\n\nfilename : str, optional\n    The name of the file where the mesh will be saved. If None, a default name is generated based on the parameters. Default is None.\n\nrefinement : optional\n    Refinement level or method for the mesh. Used to increase the resolution of the mesh in certain regions. Default is None.\n\ngmsh_verbosity : int, optional\n    Controls the verbosity of Gmsh output. Set to 0 for minimal output, higher numbers for more detailed logs. Default is 0.\n\nverbose : bool, optional\n    If True, the function prints additional information during execution. Default is False.\n\nReturns:\n--------\nNone\n    The function generates and saves a mesh file according to the specified parameters.\n\nExample:\n--------\nmesh = uw.meshing.SegmentofAnnulus(\n    radiusOuter=2.0,\n    radiusInner=1.0,\n    angleExtent=90.0,\n    cellSize=0.05,\n    centre=True,\n    degree=2,\n    qdegree=3,\n    filename=\"custom_annulus_segment.msh\",\n    gmsh_verbosity=1,\n    verbose=True\n)",
    "harvested_comments": [
      "Convert unit-aware quantities to non-dimensional units",
      "angleExtent is in degrees, not a length - don't convert",
      "error checks",
      "angle Extent in radian",
      "gmsh.model.mesh.embed(0, [p0], 2, s) # not sure use of this line"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnnulusWithSpokes",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 802,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, cellSizeOuter: float = 0.1, cellSizeInner: float = None, centre: bool = False, spokes: int = 3, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSizeOuter",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "cellSizeInner",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "centre",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "spokes",
        "type_hint": "int",
        "default": "3",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create an annulus mesh divided into sectors by radial spokes.\n\nGenerates a ring-shaped mesh with radial internal boundaries (spokes)\nthat divide the annulus into equal angular sectors. Useful for problems\nrequiring sector-wise analysis or periodic boundary conditions.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the annulus.\nradiusInner : float, default=0.547\n    Inner radius of the annulus.\ncellSizeOuter : float, default=0.1\n    Element size at the outer boundary.\ncellSizeInner : float, optional\n    Element size at the inner boundary. Defaults to ``cellSizeOuter``.\ncentre : bool, default=False\n    Mark the centre point as a boundary (if radiusInner=0).\nspokes : int, default=3\n    Number of radial spokes dividing the annulus. Creates ``spokes``\n    equal angular sectors.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D mesh with boundaries:\n\n    - ``Lower``: Inner boundary at :math:`r = r_{inner}`\n    - ``LowerPlus``: Inner boundary + spokes (for BCs)\n    - ``Upper``: Outer boundary at :math:`r = r_{outer}`\n    - ``UpperPlus``: Outer boundary + spokes (for BCs)\n    - ``Spokes``: Radial spoke boundaries\n\nSee Also\n--------\nAnnulus : Standard annulus without spokes.\n\nExamples\n--------\nCreate a 6-sector annulus:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.AnnulusWithSpokes(\n...     radiusOuter=1.0,\n...     radiusInner=0.5,\n...     spokes=6,\n...     cellSizeOuter=0.05\n... )\n\nNotes\n-----\nThe ``LowerPlus`` and ``UpperPlus`` boundaries are composite labels\nthat include both the curved boundaries and the spoke edges, useful\nfor applying no-slip conditions that include radial walls.",
    "harvested_comments": [
      "Convert unit-aware quantities to non-dimensional units",
      "spokes is a count, not a length - don't convert",
      "Now copy / rotate",
      "We finally generate and save the mesh:",
      "We need to build the plex here in order to make some changes"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnnulusInternalBoundary",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 1132,
    "signature": "(radiusOuter: float = 1.5, radiusInternal: float = 1.0, radiusInner: float = 0.547, cellSize: float = 0.1, cellSize_Outer: float = None, cellSize_Inner: float = None, cellSize_Internal: float = None, centre: bool = False, degree: int = 1, qdegree: int = 2, filename = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.5",
        "description": ""
      },
      {
        "name": "radiusInternal",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "cellSize_Outer",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSize_Inner",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSize_Internal",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "centre",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create an annulus mesh with a circular internal boundary.\n\nGenerates an annular mesh with an embedded internal boundary at a\nspecified radius, useful for tracking flux across interfaces or\ndefining different material layers.\n\nParameters\n----------\nradiusOuter : float, default=1.5\n    Outer radius of the annulus.\nradiusInternal : float, default=1.0\n    Radius of the internal boundary surface.\nradiusInner : float, default=0.547\n    Inner radius of the annulus.\ncellSize : float, default=0.1\n    Default target mesh element size.\ncellSize_Outer : float, optional\n    Element size at the outer boundary.\ncellSize_Inner : float, optional\n    Element size at the inner boundary.\ncellSize_Internal : float, optional\n    Element size at the internal boundary.\ncentre : bool, default=False\n    Mark the centre point as a boundary (if radiusInner=0).\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D mesh with boundaries:\n\n    - ``Lower``: Inner boundary at :math:`r = r_{inner}`\n    - ``Internal``: Internal boundary at :math:`r = r_{internal}`\n    - ``Upper``: Outer boundary at :math:`r = r_{outer}`\n    - ``Centre``: Centre point (if radiusInner=0)\n\nSee Also\n--------\nAnnulus : Annulus without internal boundary.\nBoxInternalBoundary : Cartesian box with internal boundary.\nSphericalShellInternalBoundary : 3D spherical equivalent.\n\nExamples\n--------\nCreate an annulus with an internal tracking surface:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.AnnulusInternalBoundary(\n...     radiusOuter=1.0,\n...     radiusInternal=0.7,\n...     radiusInner=0.5,\n...     cellSize=0.03\n... )\n\nNotes\n-----\nThe internal boundary is useful for calculating radial heat or\nmass flux across a specified radius (e.g., core-mantle boundary,\nthermal boundary layer).",
    "harvested_comments": [
      "Convert unit-aware quantities to non-dimensional units",
      "## adding this curve loop results in the mesh not being generated correctly",
      "## although the internal boundary is still defined in the mesh dm",
      "loops = [cl2] + loops",
      "Outermost mesh"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DiscInternalBoundaries",
    "kind": "function",
    "file": "src/underworld3/meshing/annulus.py",
    "line": 1414,
    "signature": "(radiusUpper: float = 1.5, radiusInternal: float = 1.0, radiusLower: float = 0.547, cellSize: float = 0.1, cellSize_Upper: float = None, cellSize_Lower: float = None, cellSize_Internal: float = None, cellSize_Centre: float = None, degree: int = 1, qdegree: int = 2, filename = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusUpper",
        "type_hint": "float",
        "default": "1.5",
        "description": ""
      },
      {
        "name": "radiusInternal",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusLower",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "cellSize_Upper",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSize_Lower",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSize_Internal",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "cellSize_Centre",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a disc mesh with multiple concentric internal boundaries.\n\nGenerates a full disc (extending to centre) with two embedded\ncircular internal boundaries at specified radii. Useful for\nmulti-layer problems or tracking flux across multiple interfaces.\n\nParameters\n----------\nradiusUpper : float, default=1.5\n    Outer radius of the disc.\nradiusInternal : float, default=1.0\n    Radius of the middle internal boundary.\nradiusLower : float, default=0.547\n    Radius of the inner internal boundary.\ncellSize : float, default=0.1\n    Default target mesh element size.\ncellSize_Upper : float, optional\n    Element size at the outer boundary.\ncellSize_Lower : float, optional\n    Element size at the lower internal boundary.\ncellSize_Internal : float, optional\n    Element size at the middle internal boundary.\ncellSize_Centre : float, optional\n    Element size at the disc centre.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D mesh with boundaries:\n\n    - ``Lower``: Inner internal boundary at :math:`r = r_{lower}`\n    - ``Internal``: Middle internal boundary at :math:`r = r_{internal}`\n    - ``Upper``: Outer boundary at :math:`r = r_{upper}`\n    - ``Centre``: Centre point\n\nSee Also\n--------\nAnnulusInternalBoundary : Annulus with one internal boundary.\n\nExamples\n--------\nCreate a disc with two tracking surfaces:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.DiscInternalBoundaries(\n...     radiusUpper=1.0,\n...     radiusInternal=0.7,\n...     radiusLower=0.4,\n...     cellSize=0.03\n... )\n\nNotes\n-----\nUnlike AnnulusInternalBoundary, this mesh extends to the centre\n(no inner hole). All internal boundaries are embedded as mesh\nedges, allowing flux integration across each interface.",
    "harvested_comments": [
      "Convert unit-aware quantities to non-dimensional units",
      "loops = [cl1] + loops",
      "Outermost mesh",
      "# Now add embedded surfaces",
      "# This is the same as the simple annulus"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "UnstructuredSimplexBox",
    "kind": "function",
    "file": "src/underworld3/meshing/cartesian.py",
    "line": 33,
    "signature": "(minCoords: Tuple = (0.0, 0.0), maxCoords: Tuple = (1.0, 1.0), cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, regular: bool = False, filename = None, refinement = None, gmsh_verbosity = 0, units = None, verbose = False)",
    "parameters": [
      {
        "name": "minCoords",
        "type_hint": "Tuple",
        "default": "(0.0, 0.0)",
        "description": ""
      },
      {
        "name": "maxCoords",
        "type_hint": "Tuple",
        "default": "(1.0, 1.0)",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "regular",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create an unstructured simplex mesh on a rectangular box domain.\n\nGenerates a triangular (2D) or tetrahedral (3D) mesh using Gmsh,\nwith named boundary labels for applying boundary conditions.\n\nParameters\n----------\nminCoords : tuple of float\n    Minimum corner coordinates ``(x_min, y_min)`` for 2D or\n    ``(x_min, y_min, z_min)`` for 3D. Supports plain numbers\n    (model units) or UWQuantity objects (auto-converted).\nmaxCoords : tuple of float\n    Maximum corner coordinates ``(x_max, y_max)`` for 2D or\n    ``(x_max, y_max, z_max)`` for 3D. Supports plain numbers\n    or UWQuantity objects.\ncellSize : float\n    Target mesh element size. Controls mesh density; smaller\n    values produce finer meshes with more elements.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\n    Use ``degree=1`` for linear elements, ``degree=2`` for quadratic.\nqdegree : int, default=2\n    Quadrature degree for numerical integration. Should typically\n    be at least ``2 * degree`` for accuracy.\nregular : bool, default=False\n    If True, use transfinite meshing for a more structured layout.\n    Currently only works for 2D meshes.\nfilename : str, optional\n    Path to save the mesh file. If None, generates a unique name\n    in the ``.meshes/`` directory based on mesh parameters.\nrefinement : int, optional\n    Number of uniform refinement levels to apply after mesh\n    generation. Each level approximately quadruples element count.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level. 0 is silent, higher values\n    produce more diagnostic output.\nunits : str, optional\n    **Deprecated**. Mesh coordinates are always in model reference\n    units. This parameter is retained for backward compatibility.\nverbose : bool, default=False\n    If True, print additional diagnostic information during\n    mesh construction.\n\nReturns\n-------\nMesh\n    An Underworld mesh object with the following boundaries defined:\n\n    **2D boundaries** (accessible via ``mesh.boundaries``):\n\n    - ``Bottom``: :math:`y = y_{min}` edge\n    - ``Top``: :math:`y = y_{max}` edge\n    - ``Right``: :math:`x = x_{max}` edge\n    - ``Left``: :math:`x = x_{min}` edge\n\n    **3D boundaries**:\n\n    - ``Bottom``: :math:`z = z_{min}` face\n    - ``Top``: :math:`z = z_{max}` face\n    - ``Right``: :math:`x = x_{max}` face\n    - ``Left``: :math:`x = x_{min}` face\n    - ``Front``: :math:`y = y_{min}` face\n    - ``Back``: :math:`y = y_{max}` face\n\nSee Also\n--------\nStructuredQuadBox : For quadrilateral/hexahedral meshes.\nBoxInternalBoundary : For box meshes with an internal interface.\n\nExamples\n--------\nCreate a 2D unit square mesh:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(\n...     minCoords=(0.0, 0.0),\n...     maxCoords=(1.0, 1.0),\n...     cellSize=0.1\n... )\n>>> mesh.dim\n2\n\nCreate a 3D box with finer resolution:\n\n>>> mesh3d = uw.meshing.UnstructuredSimplexBox(\n...     minCoords=(0.0, 0.0, 0.0),\n...     maxCoords=(2.0, 1.0, 1.0),\n...     cellSize=0.05,\n...     degree=2\n... )\n\nAccess boundary labels for boundary conditions:\n\n>>> mesh.boundaries.Bottom\n<boundaries_2D.Bottom: 11>\n\nNotes\n-----\nMesh coordinates are always in non-dimensional (scaled) units (set via\n``uw.scaling.get_coefficients()``). If UWQuantity objects with\nphysical units are passed, they are automatically converted using\n``uw.scaling.non_dimensionalise()``.\n\nThe ``regular=True`` option produces a more structured mesh layout\nbut currently only works for 2D meshes.",
    "harvested_comments": [
      "Enum is not quite natural but matches the above",
      "Convert coordinates to non-dimensional units (handles UWQuantity objects)",
      "Add Physical groups for boundaries",
      "Add Physical groups",
      "Generate Mesh"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "BoxInternalBoundary",
    "kind": "function",
    "file": "src/underworld3/meshing/cartesian.py",
    "line": 360,
    "signature": "(elementRes: Optional[Tuple[int, int, int]] = (8, 8, 8), zelementRes: Optional[Tuple[int, int]] = (4, 4), cellSize: float = 0.1, minCoords: Optional[Tuple[float, float, float]] = (0, 0, 0), maxCoords: Optional[Tuple[float, float, float]] = (1, 1, 1), zintCoord: float = 0.5, simplex: bool = False, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, units = None, verbose = False)",
    "parameters": [
      {
        "name": "elementRes",
        "type_hint": "Optional[Tuple[int, int, int]]",
        "default": "(8, 8, 8)",
        "description": ""
      },
      {
        "name": "zelementRes",
        "type_hint": "Optional[Tuple[int, int]]",
        "default": "(4, 4)",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "minCoords",
        "type_hint": "Optional[Tuple[float, float, float]]",
        "default": "(0, 0, 0)",
        "description": ""
      },
      {
        "name": "maxCoords",
        "type_hint": "Optional[Tuple[float, float, float]]",
        "default": "(1, 1, 1)",
        "description": ""
      },
      {
        "name": "zintCoord",
        "type_hint": "float",
        "default": "0.5",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a box mesh with an internal horizontal boundary.\n\nGenerates a 2D or 3D mesh with an embedded internal boundary surface,\nuseful for problems with material interfaces, phase boundaries, or\nlayered domains that require flux calculations across the interface.\n\nParameters\n----------\nelementRes : tuple of int, default=(8, 8, 8)\n    Number of elements in each direction ``(nx, ny)`` for 2D or\n    ``(nx, ny, nz)`` for 3D. Used when ``simplex=False`` (structured).\nzelementRes : tuple of int, default=(4, 4)\n    Number of elements ``(n_below, n_above)`` in the vertical direction\n    below and above the internal boundary. Allows different resolution\n    in each layer.\ncellSize : float, default=0.1\n    Target element size for unstructured meshing (``simplex=True``).\n    Ignored for structured meshes.\nminCoords : tuple of float, default=(0, 0, 0)\n    Minimum corner coordinates. Length determines dimensionality:\n    2-tuple for 2D, 3-tuple for 3D.\nmaxCoords : tuple of float, default=(1, 1, 1)\n    Maximum corner coordinates.\nzintCoord : float, default=0.5\n    Vertical coordinate of the internal boundary surface.\n    In 2D this is the y-coordinate; in 3D the z-coordinate.\nsimplex : bool, default=False\n    If False, create a structured quadrilateral/hexahedral mesh.\n    If True, create an unstructured triangular/tetrahedral mesh.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file. If None, auto-generates in ``.meshes/``.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nunits : str, optional\n    Coordinate units for unit-aware arrays.\nverbose : bool, default=False\n    Print diagnostic information during mesh construction.\n\nReturns\n-------\nMesh\n    An Underworld mesh object with boundaries including an internal\n    interface:\n\n    **2D boundaries**:\n\n    - ``Bottom``: :math:`y = y_{min}` edge\n    - ``Top``: :math:`y = y_{max}` edge\n    - ``Right``: :math:`x = x_{max}` edge\n    - ``Left``: :math:`x = x_{min}` edge\n    - ``Internal``: :math:`y = z_{int}` interface\n\n    **3D boundaries**:\n\n    - ``Bottom``: :math:`z = z_{min}` face\n    - ``Top``: :math:`z = z_{max}` face\n    - ``Right``: :math:`x = x_{max}` face\n    - ``Left``: :math:`x = x_{min}` face\n    - ``Front``: :math:`y = y_{min}` face\n    - ``Back``: :math:`y = y_{max}` face\n    - ``Internal``: :math:`z = z_{int}` interface\n\nSee Also\n--------\nUnstructuredSimplexBox : Box mesh without internal boundary.\nAnnulusInternalBoundary : Annular mesh with internal boundary.\n\nExamples\n--------\nCreate a 2D layered domain with an interface at y=0.5:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.BoxInternalBoundary(\n...     minCoords=(0.0, 0.0),\n...     maxCoords=(1.0, 1.0),\n...     zintCoord=0.5,\n...     elementRes=(16, 16),\n...     zelementRes=(8, 8)\n... )\n\nAccess the internal boundary for flux calculations:\n\n>>> mesh.boundaries.Internal\n<boundaries_2D.Internal: 15>\n\nNotes\n-----\nThe internal boundary is useful for:\n\n- Calculating heat flux across a thermal boundary layer\n- Tracking mass flux between mantle and crust\n- Applying different material properties in each layer",
    "harvested_comments": [
      "structuredQuadBoxIB",
      "Add Physical groups for boundaries"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "StructuredQuadBox",
    "kind": "function",
    "file": "src/underworld3/meshing/cartesian.py",
    "line": 898,
    "signature": "(elementRes: Optional[Tuple[int, int, int]] = (16, 16), minCoords: Optional[Tuple[float, float, float]] = None, maxCoords: Optional[Tuple[float, float, float]] = None, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, units = None, verbose = False)",
    "parameters": [
      {
        "name": "elementRes",
        "type_hint": "Optional[Tuple[int, int, int]]",
        "default": "(16, 16)",
        "description": ""
      },
      {
        "name": "minCoords",
        "type_hint": "Optional[Tuple[float, float, float]]",
        "default": "None",
        "description": ""
      },
      {
        "name": "maxCoords",
        "type_hint": "Optional[Tuple[float, float, float]]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a structured quadrilateral or hexahedral box mesh.\n\nGenerates a mesh with regular rectangular (2D) or brick (3D) elements\nusing transfinite meshing. Provides precise control over element count\nin each direction.\n\nParameters\n----------\nelementRes : tuple of int, default=(16, 16)\n    Number of elements in each direction. Use ``(nx, ny)`` for 2D\n    or ``(nx, ny, nz)`` for 3D. This tuple also determines the\n    mesh dimensionality.\nminCoords : tuple of float, optional\n    Minimum corner coordinates. Defaults to ``(0.0, 0.0)`` for 2D\n    or ``(0.0, 0.0, 0.0)`` for 3D based on ``elementRes`` length.\n    Supports plain numbers or UWQuantity objects.\nmaxCoords : tuple of float, optional\n    Maximum corner coordinates. Defaults to ``(1.0, 1.0)`` for 2D\n    or ``(1.0, 1.0, 1.0)`` for 3D. Supports UWQuantity objects.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\n    Use ``degree=1`` for bilinear/trilinear elements,\n    ``degree=2`` for biquadratic/triquadratic.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file. If None, auto-generates in ``.meshes/``.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nunits : str, optional\n    **Deprecated**. Mesh coordinates are always in model reference units.\nverbose : bool, default=False\n    Print diagnostic information during mesh construction.\n\nReturns\n-------\nMesh\n    An Underworld mesh object with structured elements and boundaries:\n\n    **2D boundaries** (same as UnstructuredSimplexBox):\n\n    - ``Bottom``: :math:`y = y_{min}` edge\n    - ``Top``: :math:`y = y_{max}` edge\n    - ``Right``: :math:`x = x_{max}` edge\n    - ``Left``: :math:`x = x_{min}` edge\n\n    **3D boundaries**:\n\n    - ``Bottom``: :math:`z = z_{min}` face\n    - ``Top``: :math:`z = z_{max}` face\n    - ``Right``: :math:`x = x_{max}` face\n    - ``Left``: :math:`x = x_{min}` face\n    - ``Front``: :math:`y = y_{min}` face\n    - ``Back``: :math:`y = y_{max}` face\n\nSee Also\n--------\nUnstructuredSimplexBox : For triangular/tetrahedral meshes.\nBoxInternalBoundary : For box meshes with an internal interface.\n\nExamples\n--------\nCreate a 2D structured mesh with 32x32 elements:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.StructuredQuadBox(\n...     elementRes=(32, 32),\n...     minCoords=(0.0, 0.0),\n...     maxCoords=(1.0, 1.0)\n... )\n\nCreate a 3D mesh (note the 3-element tuple):\n\n>>> mesh3d = uw.meshing.StructuredQuadBox(\n...     elementRes=(16, 16, 8),\n...     maxCoords=(2.0, 2.0, 1.0)\n... )\n\nNotes\n-----\nStructured meshes have predictable element layouts which can be\nadvantageous for:\n\n- Consistent interpolation behaviour\n- Benchmark problems with known analytical solutions\n- Simpler mesh-to-mesh comparisons in convergence studies\n\nThe mesh dimensionality is determined by the length of ``elementRes``:\n2-tuple creates a 2D mesh, 3-tuple creates a 3D mesh.",
    "harvested_comments": [
      "boundaries = {\"Bottom\": 1, \"Top\": 2, \"Right\": 3, \"Left\": 4, \"Front\": 5, \"Back\": 6}",
      "Enum is not quite natural but matches the above",
      "Convert coordinates to non-dimensional units (handles UWQuantity objects)",
      "Detect units from UWQuantity inputs (if not explicitly specified)",
      "Try to detect units from maxCoords (most likely to have units)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 116,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(N, 3) array of surface points.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 121,
    "signature": "(self, value: np.ndarray)",
    "parameters": [
      {
        "name": "value",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set points and invalidate cached data.",
    "harvested_comments": [
      "Invalidate derived data"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "triangles",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 137,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(M, 3) array of triangle vertex indices.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "normals",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 142,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(M, 3) array of face normals.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "pv_mesh",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 147,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "PyVista PolyData mesh (None if not triangulated or pyvista unavailable).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "is_triangulated",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 152,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Whether the surface has been triangulated.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "n_points",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 157,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Number of points in the surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "n_triangles",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 162,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Number of triangles in the surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "from_vtk",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 167,
    "signature": "(cls, filename: str, name: str = None) -> 'FaultSurface'",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'FaultSurface'",
    "existing_docstring": "Load fault surface from VTK file.\n\nArgs:\n    filename: Path to VTK file (.vtk or .vtp)\n    name: Name for the fault. If None, uses filename stem.\n\nReturns:\n    FaultSurface: Loaded fault surface with triangulation and normals\n\nRaises:\n    FileNotFoundError: If file doesn't exist\n    ImportError: If pyvista not available",
    "harvested_comments": [
      "Load the VTK file",
      "Extract triangles from faces",
      "VTK faces format: [n_verts, v0, v1, v2, n_verts, v0, v1, v2, ...]",
      "Reshape to extract triangles (assumes all triangles)",
      "Extract or compute normals"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "triangulate",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 215,
    "signature": "(self, offset: float = 0.01) -> None",
    "parameters": [
      {
        "name": "offset",
        "type_hint": "float",
        "default": "0.01",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Triangulate point cloud using pyvista delaunay_2d.\n\nThis creates a triangulated surface from the point cloud by projecting\npoints onto a best-fit plane, performing 2D Delaunay triangulation,\nand mapping back to 3D.\n\nArgs:\n    offset: Height offset for delaunay_2d (controls curvature tolerance).\n           Larger values allow more curved surfaces.\n\nRaises:\n    ImportError: If pyvista not available\n    ValueError: If points too sparse for triangulation (< 3 points)\n    RuntimeError: If triangulation fails",
    "harvested_comments": [
      "Check for degenerate cases (all points nearly collinear)",
      "Compute bounding box extent",
      "If smallest extent is negligible compared to largest, points may be collinear",
      "Create PolyData from points and triangulate",
      "This runs on all ranks redundantly (pyvista doesn't work in parallel)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "compute_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 273,
    "signature": "(self, consistent_normals: bool = True) -> None",
    "parameters": [
      {
        "name": "consistent_normals",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Recompute face normals for triangulated surface.\n\nArgs:\n    consistent_normals: If True, attempt to make normals consistently oriented",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "flip_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 292,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Flip the direction of all face normals.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "to_vtk",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 299,
    "signature": "(self, filename: str) -> None",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Export triangulated surface to VTK file.\n\nArgs:\n    filename: Output path (.vtk or .vtp)\n\nRaises:\n    RuntimeError: If surface not triangulated\n    ImportError: If pyvista not available",
    "harvested_comments": [
      "Ensure we have a pyvista mesh",
      "Reconstruct from arrays"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "build_kdtree",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 328,
    "signature": "(self) -> 'uw.kdtree.KDTree'",
    "parameters": [],
    "returns": "'uw.kdtree.KDTree'",
    "existing_docstring": "Build KDTree for nearest-neighbor queries on face centers.\n\nReturns:\n    KDTree built from triangle centroids\n\nRaises:\n    RuntimeError: If surface not triangulated",
    "harvested_comments": [
      "Compute triangle centroids"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "face_centers",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 350,
    "signature": "(self) -> np.ndarray",
    "parameters": [],
    "returns": "np.ndarray",
    "existing_docstring": "(M, 3) array of triangle centroids.",
    "harvested_comments": [
      "Compute manually from triangles"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": true
  },
  {
    "name": "add",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 407,
    "signature": "(self, fault: FaultSurface) -> None",
    "parameters": [
      {
        "name": "fault",
        "type_hint": "FaultSurface",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Add a fault surface to the collection.\n\nArgs:\n    fault: FaultSurface to add\n\nRaises:\n    ValueError: If fault with same name already exists",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "add_from_vtk",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 423,
    "signature": "(self, filename: str, name: str = None) -> FaultSurface",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "FaultSurface",
    "existing_docstring": "Load and add a fault from VTK file.\n\nArgs:\n    filename: Path to VTK file\n    name: Name for the fault. If None, uses filename stem.\n\nReturns:\n    The loaded FaultSurface",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "remove",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 437,
    "signature": "(self, name: str) -> FaultSurface",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "FaultSurface",
    "existing_docstring": "Remove and return a fault from the collection.\n\nArgs:\n    name: Name of fault to remove\n\nReturns:\n    The removed FaultSurface\n\nRaises:\n    KeyError: If fault not found",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "names",
    "kind": "property",
    "file": "src/underworld3/meshing/faults.py",
    "line": 464,
    "signature": "(self) -> List[str]",
    "parameters": [],
    "returns": "List[str]",
    "existing_docstring": "List of fault names.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "compute_distance_field",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 468,
    "signature": "(self, mesh: 'Mesh', distance_var: 'MeshVariable' = None, variable_name: str = 'fault_distance') -> 'MeshVariable'",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "distance_var",
        "type_hint": "'MeshVariable'",
        "default": "None",
        "description": ""
      },
      {
        "name": "variable_name",
        "type_hint": "str",
        "default": "'fault_distance'",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Compute minimum distance from mesh points to any fault surface.\n\nUses pyvista's compute_implicit_distance for accurate signed distance\ncomputation. The returned field contains the absolute distance to the\nnearest fault surface at each mesh point.\n\nArgs:\n    mesh: The mesh to compute distances on\n    distance_var: Optional existing MeshVariable to store results.\n                 If None, creates a new variable.\n    variable_name: Name for new variable if distance_var is None\n\nReturns:\n    MeshVariable with distance values (scalar, 1 component)\n\nRaises:\n    ValueError: If collection is empty or no faults are triangulated\n    ImportError: If pyvista not available",
    "harvested_comments": [
      "Check all faults are triangulated",
      "Create or validate output variable",
      "Get mesh coordinates and create pyvista point cloud",
      "(avoids visualisation module which initializes trame)",
      "Initialize with large distance"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "transfer_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 535,
    "signature": "(self, mesh: 'Mesh', coords: np.ndarray = None, normal_var: 'MeshVariable' = None, variable_name: str = 'fault_normals') -> 'MeshVariable'",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": "None",
        "description": ""
      },
      {
        "name": "normal_var",
        "type_hint": "'MeshVariable'",
        "default": "None",
        "description": ""
      },
      {
        "name": "variable_name",
        "type_hint": "str",
        "default": "'fault_normals'",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Transfer fault normals to mesh points via nearest-neighbor lookup.\n\nFor each mesh point, finds the closest fault face (from any fault in\nthe collection) and copies that face's normal vector.\n\nArgs:\n    mesh: The mesh to transfer normals to\n    coords: Optional coordinates to query. If None, uses mesh.X.coords\n    normal_var: Optional existing MeshVariable to store results.\n               If None, creates a new variable.\n    variable_name: Name for new variable if normal_var is None\n\nReturns:\n    MeshVariable with normal vectors (3 components)\n\nRaises:\n    ValueError: If collection is empty or no faults are triangulated",
    "harvested_comments": [
      "Check all faults are triangulated",
      "Get query coordinates",
      "Handle UnitAwareArray by extracting raw values",
      "Create or validate output variable",
      "Build combined arrays of all fault face centers and normals"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "create_weakness_function",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 606,
    "signature": "(self, distance_var: 'MeshVariable', fault_width: float, eta_weak: float = 0.01, eta_background: float = 1.0) -> sympy.Expr",
    "parameters": [
      {
        "name": "distance_var",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      },
      {
        "name": "fault_width",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "eta_weak",
        "type_hint": "float",
        "default": "0.01",
        "description": ""
      },
      {
        "name": "eta_background",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      }
    ],
    "returns": "sympy.Expr",
    "existing_docstring": "Create Piecewise viscosity function for fault weakness.\n\nCreates a sympy Piecewise expression that gives:\n- eta_weak when distance < fault_width\n- eta_background otherwise\n\nThis can be used directly with TransverseIsotropicFlowModel.Parameters.eta_1\nfor creating anisotropic weakness along fault zones.\n\nArgs:\n    distance_var: MeshVariable containing fault distances\n    fault_width: Width of the weak zone around faults\n    eta_weak: Viscosity within fault zone (default 0.01)\n    eta_background: Viscosity outside fault zone (default 1.0)\n\nReturns:\n    sympy.Piecewise expression for use in constitutive models\n\nExample:\n    >>> eta_1 = faults.create_weakness_function(\n    ...     fault_distance,\n    ...     fault_width=mesh.get_min_radius() * 5,\n    ...     eta_weak=0.01,\n    ... )\n    >>> stokes.constitutive_model.Parameters.eta_1 = eta_1",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "FaultCollection",
    "is_public": true
  },
  {
    "name": "RegionalSphericalBox",
    "kind": "function",
    "file": "src/underworld3/meshing/geographic.py",
    "line": 29,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, SWcorner = [-45, -45], NEcorner = [+45, +45], numElementsLon: int = 5, numElementsLat: int = 5, numElementsDepth: int = 5, degree: int = 1, qdegree: int = 2, simplex: bool = False, filename = None, refinement = None, coarsening = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "SWcorner",
        "type_hint": null,
        "default": "[-45, -45]",
        "description": ""
      },
      {
        "name": "NEcorner",
        "type_hint": null,
        "default": "[+45, +45]",
        "description": ""
      },
      {
        "name": "numElementsLon",
        "type_hint": "int",
        "default": "5",
        "description": ""
      },
      {
        "name": "numElementsLat",
        "type_hint": "int",
        "default": "5",
        "description": ""
      },
      {
        "name": "numElementsDepth",
        "type_hint": "int",
        "default": "5",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a regional spherical box mesh (cubed-sphere section).\n\nGenerates a 3D structured mesh for a regional section of a spherical shell,\nusing a cubed-sphere projection. The domain is defined by corner coordinates\nin degrees (longitude, latitude) and radial bounds.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the spherical shell.\nradiusInner : float, default=0.547\n    Inner radius of the spherical shell.\nSWcorner : list of float, default=[-45, -45]\n    Southwest corner as [longitude, latitude] in degrees.\nNEcorner : list of float, default=[+45, +45]\n    Northeast corner as [longitude, latitude] in degrees.\nnumElementsLon : int, default=5\n    Number of elements in the longitude direction.\nnumElementsLat : int, default=5\n    Number of elements in the latitude direction.\nnumElementsDepth : int, default=5\n    Number of elements in the radial (depth) direction.\ndegree : int, default=1\n    Polynomial degree of finite elements.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nsimplex : bool, default=False\n    If True, use tetrahedral elements; if False, use hexahedral.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ncoarsening : int, optional\n    Number of coarsening levels to apply.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 3D mesh with boundaries:\n\n    - ``Lower``: Inner surface at :math:`r = r_{inner}`\n    - ``Upper``: Outer surface at :math:`r = r_{outer}`\n    - ``North``: Northern boundary at :math:`\\phi = \\phi_{max}`\n    - ``South``: Southern boundary at :math:`\\phi = \\phi_{min}`\n    - ``East``: Eastern boundary at :math:`\\lambda = \\lambda_{max}`\n    - ``West``: Western boundary at :math:`\\lambda = \\lambda_{min}`\n\n    The mesh uses a SPHERICAL coordinate system and includes a refinement\n    callback that snaps boundary nodes to true spherical geometry.\n\nSee Also\n--------\nCubedSphere : Full cubed-sphere mesh.\nRegionalGeographicBox : Geographic mesh with ellipsoidal geometry.\nSphericalShell : Unstructured spherical shell.\n\nExamples\n--------\nCreate a regional mesh for the Australian region:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.RegionalSphericalBox(\n...     radiusOuter=1.0,\n...     radiusInner=0.9,\n...     SWcorner=[110, -45],\n...     NEcorner=[155, -10],\n...     numElementsLon=10,\n...     numElementsLat=8,\n...     numElementsDepth=5\n... )\n\nNotes\n-----\nThis mesh uses a cubed-sphere projection, which provides more uniform\nelement sizes than a latitude-longitude grid. The structured mesh is\nsuitable for regional mantle convection models where boundary-aligned\nelements are beneficial.\n\nThe coordinate system provides unit vectors via ``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: colatitude direction :math:`(\\theta)`\n- ``unit_e_2``: longitude direction :math:`(\\phi)`",
    "harvested_comments": [
      "lat_south = np.radians(centralLatitude - latitudeExtent/2)",
      "lat_north = np.radians(centralLatitude + latitudeExtent/2)",
      "ss = min(longitudeExtent / 90, 1.99) * np.cos(lat_south)/np.cos(np.pi/4)",
      "sn = min(longitudeExtent / 90, 1.99) * np.cos(lat_north)/np.cos(np.pi/4)",
      "t = min(latitudeExtent / 90, 1.99)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "RegionalGeographicBox",
    "kind": "function",
    "file": "src/underworld3/meshing/geographic.py",
    "line": 410,
    "signature": "(lon_range: Tuple[float, float] = (135.0, 140.0), lat_range: Tuple[float, float] = (-35.0, -30.0), depth_range: Tuple[float, float] = (0.0, 400.0), ellipsoid = 'WGS84', numElements: Tuple[int, int, int] = (10, 10, 10), degree: int = 1, qdegree: int = 2, simplex: bool = True, filename: Optional[str] = None, refinement: Optional[int] = None, coarsening: Optional[int] = None, gmsh_verbosity: int = 0, verbose: bool = False)",
    "parameters": [
      {
        "name": "lon_range",
        "type_hint": "Tuple[float, float]",
        "default": "(135.0, 140.0)",
        "description": ""
      },
      {
        "name": "lat_range",
        "type_hint": "Tuple[float, float]",
        "default": "(-35.0, -30.0)",
        "description": ""
      },
      {
        "name": "depth_range",
        "type_hint": "Tuple[float, float]",
        "default": "(0.0, 400.0)",
        "description": ""
      },
      {
        "name": "ellipsoid",
        "type_hint": null,
        "default": "'WGS84'",
        "description": ""
      },
      {
        "name": "numElements",
        "type_hint": "Tuple[int, int, int]",
        "default": "(10, 10, 10)",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": "int",
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a regional geographic mesh with ellipsoidal geometry.\n\nThis function creates a structured 3D mesh in geographic coordinates\n(longitude, latitude, depth) on an ellipsoidal planet. The mesh uses\ngeodetic latitude (perpendicular to ellipsoid surface) and measures\ndepth below the reference ellipsoid surface.\n\nParameters\n----------\nlon_range : tuple of float, optional\n    Longitude range in degrees East (lon_min, lon_max).\n    Default: (135.0, 140.0) for southeastern Australia.\nlat_range : tuple of float, optional\n    Latitude range in degrees North (lat_min, lat_max).\n    Geodetic latitude (perpendicular to ellipsoid).\n    Default: (-35.0, -30.0) for southeastern Australia.\ndepth_range : tuple of float, optional\n    Depth range in km below ellipsoid surface (depth_min, depth_max).\n    Positive downward. depth_min=0 means surface.\n    Default: (0.0, 400.0) for 0-400 km depth.\nellipsoid : str, tuple, or bool, optional\n    Ellipsoid specification:\n    - str: Name from ELLIPSOIDS dict ('WGS84', 'Mars', 'Moon', 'Venus', 'sphere')\n    - tuple: (semi_major_axis_km, semi_minor_axis_km) for custom ellipsoid\n    - True: Use WGS84 (default)\n    - False or 'sphere': Use perfect sphere with Earth mean radius\n    Default: 'WGS84'\nnumElements : tuple of int, optional\n    Number of elements in (lon, lat, depth) directions.\n    Default: (10, 10, 10)\ndegree : int, optional\n    Polynomial degree for finite elements (1=linear, 2=quadratic).\n    Default: 1\nqdegree : int, optional\n    Quadrature degree for numerical integration.\n    Default: 2\nsimplex : bool, optional\n    If True, use tetrahedral elements. If False, use hexahedral elements.\n    Default: True\nfilename : str, optional\n    Path to save generated mesh file. If None, uses automatic naming.\n    Default: None\nrefinement : int, optional\n    Number of uniform refinement steps to apply.\n    Default: None\ncoarsening : int, optional\n    Number of coarsening steps to apply.\n    Default: None\ngmsh_verbosity : int, optional\n    Gmsh output verbosity level (0=quiet, 5=very verbose).\n    Default: 0\nverbose : bool, optional\n    If True, print mesh generation details.\n    Default: False\n\nReturns\n-------\nMesh\n    Underworld3 mesh object with GEOGRAPHIC coordinate system.\n    Access geographic coordinates via mesh.geo:\n    - mesh.geo.lon, mesh.geo.lat, mesh.geo.depth (data arrays)\n    - mesh.geo[:] for symbolic coordinates (\u03bb_lon, \u03bb_lat, \u03bb_d)\n    - mesh.geo.unit_east, mesh.geo.unit_north, mesh.geo.unit_down (basis vectors)\n\nExamples\n--------\n# Create mesh for southeastern Australia, 0-400 km depth\nmesh = uw.meshing.RegionalGeographicBox(\n    lon_range=(135, 140),\n    lat_range=(-35, -30),\n    depth_range=(0, 400),\n    ellipsoid='WGS84',\n    numElements=(20, 20, 10),\n)\n\n# Access geographic coordinates\nlon = mesh.geo.lon         # Longitude array (degrees East)\nlat = mesh.geo.lat         # Latitude array (degrees North)\ndepth = mesh.geo.depth     # Depth array (km below surface)\n\n# Use in equations\n\u03bb_lon, \u03bb_lat, \u03bb_d = mesh.geo[:]\nT = 1600 - 0.5 * \u03bb_d       # Temperature decreasing with depth\n\n# Basis vectors for boundary conditions\nv_surface = 0 * mesh.geo.unit_up     # No vertical flow at surface\nv_bottom = 10 * mesh.geo.unit_down   # Downward flow at bottom\n\n# Mars example\nmesh_mars = uw.meshing.RegionalGeographicBox(\n    lon_range=(0, 45),\n    lat_range=(-22.5, 22.5),\n    depth_range=(0, 200),\n    ellipsoid='Mars',\n    numElements=(15, 15, 8),\n)\n\nNotes\n-----\n- Uses geodetic latitude (GPS/map standard), not geocentric latitude\n- Depth is measured from reference ellipsoid surface, not from center\n- mesh.R provides spherical coordinates (r, \u03b8, \u03c6) for backward compatibility\n- mesh.geo provides geographic coordinates (lon, lat, depth) with ellipsoid geometry\n- Right-handed coordinate system: WE \u00d7 SN = down",
    "harvested_comments": [
      "Create mesh for southeastern Australia, 0-400 km depth",
      "Access geographic coordinates",
      "Longitude array (degrees East)",
      "Latitude array (degrees North)",
      "Depth array (km below surface)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SegmentedSphericalSurface2D",
    "kind": "function",
    "file": "src/underworld3/meshing/segmented.py",
    "line": 30,
    "signature": "(radius: float = 1.0, cellSize: float = 0.05, numSegments: int = 6, degree: int = 1, qdegree: int = 2, filename = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radius",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.05",
        "description": ""
      },
      {
        "name": "numSegments",
        "type_hint": "int",
        "default": "6",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a 2D spherical surface mesh using orange-peel segmentation.\n\nGenerates a mesh on the surface of a sphere by dividing it into\nlongitudinal segments (like an orange peel), with coordinates\nconverted to :math:`(\\lambda, \\phi)` (longitude, latitude).\n\nParameters\n----------\nradius : float, default=1.0\n    Radius of the sphere.\ncellSize : float, default=0.05\n    Target mesh element size.\nnumSegments : int, default=6\n    Number of longitudinal segments (orange-peel divisions).\ndegree : int, default=1\n    Polynomial degree of finite elements.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 2D surface mesh with point boundaries:\n\n    - ``NPole``: North pole point\n    - ``SPole``: South pole point\n    - ``Poles``: Both poles combined\n\n    Uses SPHERE_SURFACE_NATIVE coordinate system with\n    :math:`(\\lambda, \\phi)` coordinates.\n\nSee Also\n--------\nSegmentedSphericalShell : 3D segmented spherical shell.\nSphericalShell : Standard unstructured spherical shell.\n\nWarnings\n--------\nThis mesh uses PETSc periodicity features that may be unreliable.\nConsider using alternative mesh types for production work.\n\nNotes\n-----\nThe mesh is constructed by creating curved triangular segments from\npole to pole, then converting the Cartesian coordinates to longitude-\nlatitude representation. Periodicity is set up to handle the :math:`\\pm\\pi`\nlongitude wrap-around.",
    "harvested_comments": [
      "Mesh like an orange",
      "Curve loops:",
      "Add some physical labels etc.",
      "Generate Mesh",
      "xyz coordinates of the mesh"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SegmentedSphericalShell",
    "kind": "function",
    "file": "src/underworld3/meshing/segmented.py",
    "line": 238,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, cellSize: float = 0.1, numSegments: int = 6, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, coordinatesNative = False, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "numSegments",
        "type_hint": "int",
        "default": "6",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coordinatesNative",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a 3D spherical shell mesh using orange-peel segmentation.\n\nGenerates a spherical shell mesh by dividing the sphere into\nlongitudinal wedge segments, similar to an orange peel. Each segment\nis a 3D wedge extending from the inner to outer radius.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the shell.\nradiusInner : float, default=0.547\n    Inner radius of the shell.\ncellSize : float, default=0.1\n    Target mesh element size.\nnumSegments : int, default=6\n    Number of longitudinal segments.\ndegree : int, default=1\n    Polynomial degree of finite elements.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ncoordinatesNative : bool, default=False\n    If True, use native :math:`(r, \\theta, \\phi)` coordinates\n    with periodicity in :math:`\\phi`. If False, use Cartesian\n    coordinates with spherical coordinate system overlay.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 3D mesh with boundaries:\n\n    - ``Lower``: Inner surface at :math:`r = r_{inner}`\n    - ``LowerPlus``: Inner surface + slice boundaries\n    - ``Upper``: Outer surface at :math:`r = r_{outer}`\n    - ``UpperPlus``: Outer surface + slice boundaries\n    - ``Slices``: Radial slice boundaries between segments\n\n    The mesh provides boundary normals for free-slip conditions\n    on the radial boundaries.\n\nSee Also\n--------\nSegmentedSphericalBall : Solid ball version (no inner boundary).\nSphericalShell : Standard unstructured spherical shell.\nCubedSphere : Alternative structured spherical mesh.\n\nWarnings\n--------\nWhen ``coordinatesNative=True``, this mesh uses PETSc periodicity\nfeatures that may be unreliable. Consider using ``coordinatesNative=False``\nor alternative mesh types for production work.\n\nNotes\n-----\nThe ``LowerPlus`` and ``UpperPlus`` boundaries combine the radial\nsurfaces with the slice boundaries, useful for applying no-slip\nconditions that include the radial walls.\n\nThe coordinate system provides unit vectors via ``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: colatitude direction :math:`(\\theta)`\n- ``unit_e_2``: longitude direction :math:`(\\phi)`",
    "harvested_comments": [
      "# Follow the lead of the cubed sphere and make copies of a segment",
      "Make boundaries",
      "Make surfaces",
      "Make volume",
      "Make copies"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SegmentedSphericalBall",
    "kind": "function",
    "file": "src/underworld3/meshing/segmented.py",
    "line": 683,
    "signature": "(radius: float = 1.0, cellSize: float = 0.1, numSegments: int = 6, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, coordinatesNative = False, verbosity = 0, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radius",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "numSegments",
        "type_hint": "int",
        "default": "6",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coordinatesNative",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a 3D solid spherical ball mesh using orange-peel segmentation.\n\nGenerates a solid sphere mesh (no inner cavity) by dividing it into\nlongitudinal wedge segments extending from the centre to the surface.\n\nParameters\n----------\nradius : float, default=1.0\n    Radius of the sphere.\ncellSize : float, default=0.1\n    Target mesh element size.\nnumSegments : int, default=6\n    Number of longitudinal segments.\ndegree : int, default=1\n    Polynomial degree of finite elements.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ncoordinatesNative : bool, default=False\n    If True, use native :math:`(r, \\theta, \\phi)` coordinates\n    with periodicity in :math:`\\phi`. If False, use Cartesian\n    coordinates with spherical coordinate system overlay.\nverbosity : int, default=0\n    Deprecated. Use ``verbose`` instead.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 3D mesh with boundaries:\n\n    - ``Upper``: Outer surface at :math:`r = radius`\n    - ``UpperPlus``: Outer surface + slice boundaries\n    - ``Centre``: Central point\n    - ``Slices``: Radial slice boundaries between segments\n\n    The mesh provides boundary normals for free-slip conditions\n    on the outer surface.\n\nSee Also\n--------\nSegmentedSphericalShell : Shell version with inner boundary.\nSphericalShell : Standard unstructured spherical shell.\n\nWarnings\n--------\nWhen ``coordinatesNative=True``, this mesh uses PETSc periodicity\nfeatures that may be unreliable. Consider using ``coordinatesNative=False``\nor alternative mesh types for production work.\n\nNotes\n-----\nThis mesh is useful for modelling solid bodies (e.g., planetary cores,\nasteroids) where elements must extend to the centre. The segmented\napproach avoids the pole singularity issues of latitude-longitude grids.\n\nThe coordinate system provides unit vectors via ``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: colatitude direction :math:`(\\theta)`\n- ``unit_e_2``: longitude direction :math:`(\\phi)`",
    "harvested_comments": [
      "# Follow the lead of the cubed sphere and make copies of a segment",
      "Make boundaries",
      "faceLoopi = gmsh.model.geo.addCurveLoop(",
      "[edgeWi, edgeEqi, edgeEi], tag=-1, reorient=True",
      "Make surfaces"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SphericalShell",
    "kind": "function",
    "file": "src/underworld3/meshing/spherical.py",
    "line": 30,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a 3D spherical shell mesh.\n\nGenerates a tetrahedral mesh on a full spherical shell (or solid\nsphere if ``radiusInner=0``) using Gmsh's OpenCASCADE geometry\nkernel. Provides :math:`(r, \\theta, \\phi)` coordinates for\nconvenient representation of radial problems.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the spherical shell.\nradiusInner : float, default=0.547\n    Inner radius of the spherical shell. Set to 0 for a solid\n    sphere extending to the centre.\ncellSize : float, default=0.1\n    Target mesh element size.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply. Each level\n    approximately octruples element count.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 3D mesh with boundaries:\n\n    - ``Lower``: Inner surface at :math:`r = r_{inner}`\n    - ``Upper``: Outer surface at :math:`r = r_{outer}`\n    - ``Centre``: Centre point (if radiusInner=0)\n\n    The mesh includes a refinement callback that snaps boundary\n    nodes back to true spherical geometry after refinement.\n\nSee Also\n--------\nAnnulus : 2D equivalent.\nSphericalShellInternalBoundary : Spherical shell with internal surface.\nCubedSphere : Structured spherical shell mesh.\n\nExamples\n--------\nCreate a spherical shell for mantle convection:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.SphericalShell(\n...     radiusOuter=1.0,\n...     radiusInner=0.547,\n...     cellSize=0.1\n... )\n\nCreate a solid sphere:\n\n>>> mesh = uw.meshing.SphericalShell(\n...     radiusOuter=1.0,\n...     radiusInner=0.0,\n...     cellSize=0.1\n... )\n\nNotes\n-----\nThe inner radius default of 0.547 corresponds approximately to the\nEarth's core-mantle boundary radius ratio (3480/6371).\n\nThe mesh coordinate system provides unit vectors via\n``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: colatitude direction :math:`(\\theta)`\n- ``unit_e_2``: longitude direction :math:`(\\phi)`\n\nFor free-slip boundary conditions on vector problems (e.g., Stokes),\nuse a penalty on the normal velocity component::\n\n    Gamma_N = mesh.Gamma  # discrete normal, or\n    Gamma_N = mesh.CoordinateSystem.unit_e_0  # analytic radial\n    stokes.add_natural_bc(\n        penalty * Gamma_N.dot(v_soln.sym) * Gamma_N, \"Upper\"\n    )",
    "harvested_comments": [
      "discrete normal, or",
      "analytic radial",
      "Ensure boundaries conform (if refined)",
      "This is equivalent to a partial function because it already",
      "knows the configuration of THIS spherical mesh and"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SphericalShellInternalBoundary",
    "kind": "function",
    "file": "src/underworld3/meshing/spherical.py",
    "line": 276,
    "signature": "(radiusOuter: float = 1.0, radiusInternal: float = 0.8, radiusInner: float = 0.547, cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInternal",
        "type_hint": "float",
        "default": "0.8",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates a spherical shell with an internal boundary using Gmsh. The function creates a 3D mesh of a spherical shell\ndefined by outer, internal, and inner radii. Mesh size, polynomial degree, and Gmsh verbosity can be customized.\n\nParameters:\n-----------\nradiusOuter : float, optional\n    The outer radius of the spherical shell. Default is 1.0.\n\nradiusInternal : float, optional\n    The radius of the internal boundary within the spherical shell. Default is 0.8.\n\nradiusInner : float, optional\n    The inner radius of the spherical shell. Default is 0.547.\n\ncellSize : float, optional\n    The target size for the mesh elements. This controls the density of the mesh. Default is 0.1.\n\ndegree : int, optional\n    The polynomial degree of the finite elements used in the mesh. Default is 1.\n\nqdegree : int, optional\n    The quadrature degree for integration. Higher values may improve accuracy but increase computation time. Default is 2.\n\nfilename : str, optional\n    The name of the file where the mesh will be saved. If None, a default name is generated based on the radii and mesh size. Default is None.\n\nrefinement : optional\n    Refinement level or method for the mesh. Used to increase the resolution of the mesh in certain regions. Default is None.\n\ngmsh_verbosity : int, optional\n    Controls the verbosity of Gmsh output. Set to 0 for minimal output, higher numbers for more detailed logs. Default is 0.\n\nverbose : bool, optional\n    If True, the function prints additional information during execution. Default is False.\n\nReturns:\n--------\nNone\n    The function generates and saves a mesh file according to the specified parameters.\n\nExample:\n--------\nmesh = uw.meshing.SphericalShellInternalBoundary(\n    radiusOuter=2.0,\n    radiusInternal=1.5,\n    radiusInner=1.0,\n    cellSize=0.05,\n    degree=2,\n    qdegree=3,\n    filename=\"custom_spherical_shell.msh\",\n    gmsh_verbosity=1,\n    verbose=True\n)",
    "harvested_comments": [
      "Check if r_i is greater than 0",
      "Cut the inner sphere from the outer sphere to create a shell",
      "Create another inner sphere with radius r_i (for the internal sphere)",
      "Set the maximum characteristic length (mesh size) for the mesh elements",
      "Embed a 2D surface into a 3D volume"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SegmentofSphere",
    "kind": "function",
    "file": "src/underworld3/meshing/spherical.py",
    "line": 496,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, longitudeExtent: float = 90.0, latitudeExtent: float = 90.0, cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False, centroid: Tuple = (0.0, 0.0, 0.0))",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "longitudeExtent",
        "type_hint": "float",
        "default": "90.0",
        "description": ""
      },
      {
        "name": "latitudeExtent",
        "type_hint": "float",
        "default": "90.0",
        "description": ""
      },
      {
        "name": "cellSize",
        "type_hint": "float",
        "default": "0.1",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "centroid",
        "type_hint": "Tuple",
        "default": "(0.0, 0.0, 0.0)",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates a segment of a sphere using Gmsh. This function creates a 3D mesh of a spherical segment defined by outer and inner radii,\nand the extent in longitude and latitude. The mesh can be customized in terms of size, polynomial degree, and verbosity.\n\nParameters:\n-----------\nradiusOuter : float, optional\n    The outer radius of the spherical segment. Default is 1.0.\n\nradiusInner : float, optional\n    The inner radius of the spherical segment. Default is 0.547.\n\nlongitudeExtent : float, optional\n    The angular extent of the segment in the longitudinal direction (in degrees). Default is 90.0.\n\nlatitudeExtent : float, optional\n    The angular extent of the segment in the latitudinal direction (in degrees). Default is 90.0.\n\ncellSize : float, optional\n    The target size for the mesh elements. This controls the density of the mesh. Default is 0.1.\n\ndegree : int, optional\n    The polynomial degree of the finite elements used in the mesh. Default is 1.\n\nqdegree : int, optional\n    The quadrature degree for integration. Higher values may improve accuracy but increase computation time. Default is 2.\n\nfilename : str, optional\n    The name of the file where the mesh will be saved. If None, a default name is generated based on the parameters. Default is None.\n\nrefinement : optional\n    Refinement level or method for the mesh. Used to increase the resolution of the mesh in certain regions. Default is None.\n\ngmsh_verbosity : int, optional\n    Controls the verbosity of Gmsh output. Set to 0 for minimal output, higher numbers for more detailed logs. Default is 0.\n\nverbose : bool, optional\n    If True, the function prints additional information during execution. Default is False.\n\ncentroid : Tuple[float, float, float], optional\n    The coordinates of the centroid (center) of the sphere segment. Default is (0.0, 0.0, 0.0).\n\nReturns:\n--------\nNone\n    The function generates and saves a mesh file according to the specified parameters.\n\nExample:\n--------\nmesh = uw.meshing.SegmentofSphere(\n    radiusOuter=2.0,\n    radiusInner=1.0,\n    longitudeExtent=120.0,\n    latitudeExtent=60.0,\n    cellSize=0.05,\n    degree=2,\n    qdegree=3,\n    filename=\"custom_sphere_segment.msh\",\n    centroid=(0.0, 0.0, 0.0),\n    gmsh_verbosity=1,\n    verbose=True\n)",
    "harvested_comments": [
      "Create segment of sphere",
      "Add Physical groups",
      "Add the volume entity to a physical group with a high tag number (99999) and name it \"Elements\"",
      "Ensure boundaries conform (if refined)",
      "This is equivalent to a partial function because it already"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "CubedSphere",
    "kind": "function",
    "file": "src/underworld3/meshing/spherical.py",
    "line": 773,
    "signature": "(radiusOuter: float = 1.0, radiusInner: float = 0.547, numElements: int = 5, degree: int = 1, qdegree: int = 2, simplex: bool = False, filename = None, refinement = None, gmsh_verbosity = 0, verbose = False)",
    "parameters": [
      {
        "name": "radiusOuter",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "radiusInner",
        "type_hint": "float",
        "default": "0.547",
        "description": ""
      },
      {
        "name": "numElements",
        "type_hint": "int",
        "default": "5",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "gmsh_verbosity",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a cubed-sphere mesh with structured elements.\n\nGenerates a spherical shell mesh using the cubed-sphere projection,\nwhich maps six cube faces onto the sphere. Produces hexahedral\nelements (or tetrahedra if ``simplex=True``) with uniform resolution.\n\nParameters\n----------\nradiusOuter : float, default=1.0\n    Outer radius of the spherical shell.\nradiusInner : float, default=0.547\n    Inner radius of the spherical shell.\nnumElements : int, default=5\n    Number of elements along each edge of each cube face. Total\n    elements approximately ``6 * numElements^2`` per radial layer.\ndegree : int, default=1\n    Polynomial degree of finite element basis functions.\nqdegree : int, default=2\n    Quadrature degree for numerical integration.\nsimplex : bool, default=False\n    If False, use hexahedral elements. If True, subdivide into\n    tetrahedra (simplex elements).\nfilename : str, optional\n    Path to save the mesh file.\nrefinement : int, optional\n    Number of uniform refinement levels to apply.\ngmsh_verbosity : int, default=0\n    Gmsh output verbosity level.\nverbose : bool, default=False\n    Print diagnostic information.\n\nReturns\n-------\nMesh\n    A 3D mesh with boundaries:\n\n    - ``Lower``: Inner surface at :math:`r = r_{inner}`\n    - ``Upper``: Outer surface at :math:`r = r_{outer}`\n\nSee Also\n--------\nSphericalShell : Unstructured tetrahedral spherical mesh.\nSegmentofSphere : Partial spherical shell.\n\nExamples\n--------\nCreate a cubed-sphere mesh with 10 elements per edge:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.CubedSphere(\n...     radiusOuter=1.0,\n...     radiusInner=0.55,\n...     numElements=10\n... )\n\nNotes\n-----\nThe cubed-sphere projection avoids polar singularities present in\nlatitude-longitude grids, providing quasi-uniform element sizes\nacross the sphere. This is particularly advantageous for global\ngeodynamics simulations.\n\nThe mesh coordinate system provides unit vectors via\n``mesh.CoordinateSystem``:\n\n- ``unit_e_0``: radial direction :math:`(r)`\n- ``unit_e_1``: colatitude direction :math:`(\\theta)`\n- ``unit_e_2``: longitude direction :math:`(\\phi)`",
    "harvested_comments": [
      "Make copies",
      "if not simplex:",
      "Generate Mesh",
      "# Note these numbers should not be hard-wired",
      "print(f\"Refinement callback - spherical\", flush=True)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 142,
    "signature": "(self) -> Optional[str]",
    "parameters": [],
    "returns": "Optional[str]",
    "existing_docstring": "Units for this variable (None if dimensionless).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 147,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 152,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Direct access to vertex data with optional unit awareness.\n\nReturns:\n    UnitAwareArray if units are set, otherwise plain numpy array.\n    Shape is (n_vertices,) for size=1, or (n_vertices, size) otherwise.\n\nNote:\n    When units are set, modifications via array operations automatically\n    sync to pyvista storage and mark proxy as stale. For raw numpy arrays,\n    call mark_stale() after modifications.",
    "harvested_comments": [
      "Import here to avoid circular imports",
      "Create callback to sync changes to pyvista and mark stale"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 185,
    "signature": "(self, values) -> None",
    "parameters": [
      {
        "name": "values",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Set vertex data and mark proxy as stale.\n\nIf values have units (magnitude attribute), the magnitude is extracted\nfor storage in pyvista. Units are tracked separately.",
    "harvested_comments": [
      "Strip units if present"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "mark_stale",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 198,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Mark the proxy as stale so it will be recomputed on next .sym access.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "mask",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 203,
    "signature": "(self) -> sympy.Expr",
    "parameters": [],
    "returns": "sympy.Expr",
    "existing_docstring": "Distance-based mask: 1 near surface, 0 far away.\n\nUses the surface's signed distance field with the configured profile.\nMust be explicitly applied in expressions: use `var.sym * var.mask`.\n\nReturns:\n    sympy.Expr representing the mask (1 near, 0 far)\n\nRaises:\n    ValueError: If mask_width was not set in add_variable()\n\nExample:\n    >>> friction = surface.add_variable(\"friction\", mask_width=0.1)\n    >>> friction.data[:] = 0.6\n    >>> eta = friction.sym[0] * friction.mask  # Masked value",
    "harvested_comments": [
      "Masked value"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 234,
    "signature": "(self) -> sympy.Matrix",
    "parameters": [],
    "returns": "sympy.Matrix",
    "existing_docstring": "Symbolic representation for use in expressions.\n\nReturns:\n    sympy.Matrix that can be used in Underworld expressions.\n\nNote:\n    On first access (or after mark_stale()), this triggers interpolation\n    from surface vertices to mesh nodes. The interpolation uses inverse\n    distance weighting from nearby surface vertices.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": true
  },
  {
    "name": "dim",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 413,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Spatial dimension (2 or 3).\n\nDetected from mesh.dim if available, otherwise from control points shape.",
    "harvested_comments": [
      "Try to get from mesh",
      "Infer from control points",
      "Default to 3D"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "is_2d",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 438,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "True if this is a 2D surface (1D curve in 2D space).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "symbol",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 443,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Short LaTeX-friendly symbol for math expressions.\n\nUsed in distance field expressions like $d_F$ instead of\nthe full variable name {surf_fault_distance}.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "symbol",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 452,
    "signature": "(self, value: str) -> None",
    "parameters": [
      {
        "name": "value",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Set the math symbol. Marks distance field as stale if changed.",
    "harvested_comments": [
      "If distance var exists, it needs to be recreated with new symbol"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "control_points",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 462,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(N, 3) array of control points defining the surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "set_control_points",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 466,
    "signature": "(self, points: np.ndarray) -> None",
    "parameters": [
      {
        "name": "points",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Set control points and mark discretization as stale.\n\nArgs:\n    points: (N, 2) or (N, 3) array of points. Can include Pint units,\n           which will be converted using the model's scaling system.\n           For 2D points, z-coordinate is set to 0.",
    "harvested_comments": [
      "Handle unit conversion using standard scaling system (ndim)",
      "This works with both legacy (get_coefficients) and modern patterns",
      "Points have Pint units - convert using scaling system",
      "For 2D points, pad with z=0"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "vertices",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 502,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(N, 3) array of vertex positions.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "n_vertices",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 509,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Number of vertices in the discretized surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "n_triangles",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 516,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Number of triangles in the surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "normals",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 523,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(N, 3) array of vertex normals (point normals from pyvista).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "triangles",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 531,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(M, 3) array of triangle vertex indices.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "face_centers",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 541,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(M, 3) array of triangle centroids.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "face_normals",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 549,
    "signature": "(self) -> Optional[np.ndarray]",
    "parameters": [],
    "returns": "Optional[np.ndarray]",
    "existing_docstring": "(M, 3) array of face normals (cell normals from pyvista).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "pv_mesh",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 557,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "PyVista PolyData mesh (None if not discretized).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "is_discretized",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 562,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Whether the surface has been discretized.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "discretize",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 573,
    "signature": "(self, offset: float = 0.01, n_segments: int = None) -> None",
    "parameters": [
      {
        "name": "offset",
        "type_hint": "float",
        "default": "0.01",
        "description": ""
      },
      {
        "name": "n_segments",
        "type_hint": "int",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Discretize control points into a surface mesh.\n\nFor 3D surfaces: Uses pyvista delaunay_2d to create a triangulated mesh.\nFor 2D surfaces: Uses scipy to fit a spline and create a polyline.\n\nArgs:\n    offset: (3D only) Height offset for delaunay_2d (controls curvature tolerance).\n    n_segments: (2D only) Number of line segments. If None, uses number\n               of control points minus 1.\n\nRaises:\n    ImportError: If pyvista not available\n    ValueError: If points too sparse for discretization\n    RuntimeError: If discretization fails",
    "harvested_comments": [
      "Clear stale flags"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "deform_vertices",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 695,
    "signature": "(self, displacement: np.ndarray) -> None",
    "parameters": [
      {
        "name": "displacement",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Deform surface vertices in-place (no re-discretization).\n\nThis modifies vertex positions while keeping topology fixed.\nNormals are automatically recomputed.\n\nArgs:\n    displacement: (n_vertices, 3) array of displacements to add\n\nNote:\n    This does NOT update control points. If you want topology changes,\n    use set_control_points() instead and call discretize().",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "distance",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 728,
    "signature": "(self) -> 'uw.discretisation.MeshVariable'",
    "parameters": [],
    "returns": "'uw.discretisation.MeshVariable'",
    "existing_docstring": "Signed distance from mesh nodes to surface (lazily computed).\n\nThe signed distance is positive on one side of the surface and\nnegative on the other. Use sympy.Abs(surface.distance.sym[0]) for\nunsigned distance, or use influence_function() which does this\nautomatically.\n\nReturns:\n    MeshVariable with signed distance values at each mesh node.\n    Access .sym[0] for use in expressions.\n\nRaises:\n    RuntimeError: If mesh not set or surface not discretized\n\nExample:\n    >>> # Use signed distance for different properties on each side\n    >>> d = surface.distance.sym[0]\n    >>> prop = sympy.Piecewise((upper_value, d > 0), (lower_value, True))\n    >>>\n    >>> # Use absolute distance for symmetric influence\n    >>> mask = sympy.Piecewise((1, sympy.Abs(d) < width), (0, True))",
    "harvested_comments": [
      "Use signed distance for different properties on each side",
      "Use absolute distance for symmetric influence"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "influence_function",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 824,
    "signature": "(self, width: float, value_near: Union[float, sympy.Expr] = 1.0, value_far: Union[float, sympy.Expr] = 0.0, profile: str = 'step') -> sympy.Expr",
    "parameters": [
      {
        "name": "width",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "value_near",
        "type_hint": "Union[float, sympy.Expr]",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "value_far",
        "type_hint": "Union[float, sympy.Expr]",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "profile",
        "type_hint": "str",
        "default": "'step'",
        "description": ""
      }
    ],
    "returns": "sympy.Expr",
    "existing_docstring": "Create level-set-like influence function based on distance.\n\nCreates a sympy expression that varies from value_near (at the surface)\nto value_far (far from the surface) based on the chosen profile.\n\nUses the absolute value of the signed distance field, so the influence\nis symmetric on both sides of the surface. For asymmetric behavior,\naccess the signed distance directly via surface.distance.sym[0].\n\nArgs:\n    width: Characteristic width of the transition zone. Can include\n           Pint units (e.g., 500 * u.meter), which will be converted\n           using the model's scaling system.\n    value_near: Value at/near the surface (can be a scalar or sympy expression)\n    value_far: Value far from the surface (can be a scalar or sympy expression)\n    profile: Transition profile type:\n        - \"step\": Sharp transition at distance = width\n        - \"linear\": Linear ramp from 0 to width\n        - \"gaussian\": Smooth Gaussian decay\n        - \"smoothstep\": C1-continuous Hermite interpolation\n\nReturns:\n    sympy.Expr that can be used in Underworld expressions\n\nExample:\n    >>> # Step function for fault zone viscosity\n    >>> eta = surface.influence_function(\n    ...     width=0.05,\n    ...     value_near=0.01,\n    ...     value_far=1.0,\n    ...     profile=\"step\",\n    ... )\n    >>>\n    >>> # Gaussian decay for smooth transitions\n    >>> eta = surface.influence_function(\n    ...     width=0.1,\n    ...     value_near=friction.sym,  # Variable on surface\n    ...     value_far=1.0,\n    ...     profile=\"gaussian\",\n    ... )",
    "harvested_comments": [
      "Step function for fault zone viscosity",
      "Gaussian decay for smooth transitions",
      "Variable on surface",
      "Handle unit conversion for width using standard scaling system (ndim)",
      "This works with both legacy (get_coefficients) and modern patterns"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "add_variable",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 903,
    "signature": "(self, name: str, size: int = 1, proxy_degree: int = 1, units: Optional[str] = None, mask_width: Optional[float] = None, mask_profile: str = 'gaussian') -> SurfaceVariable",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "mask_width",
        "type_hint": "Optional[float]",
        "default": "None",
        "description": ""
      },
      {
        "name": "mask_profile",
        "type_hint": "str",
        "default": "'gaussian'",
        "description": ""
      }
    ],
    "returns": "SurfaceVariable",
    "existing_docstring": "Add a variable on surface vertices.\n\nCreates a SurfaceVariable stored in pyvista point_data with\nsymbolic access via .sym for use in expressions.\n\nArgs:\n    name: Variable name\n    size: Number of components (1 for scalar, 3 for vector)\n    proxy_degree: Degree of proxy MeshVariable for .sym access\n    units: Optional units for this variable (e.g., \"Pa\", \"m/s\")\n    mask_width: Width for distance-based mask (enables .mask property)\n    mask_profile: Profile for mask function (\"step\", \"linear\", \"gaussian\", \"smoothstep\")\n\nReturns:\n    SurfaceVariable that can be modified via .data and used via .sym\n\nExample:\n    >>> # Variable with units and mask\n    >>> friction = surface.add_variable(\"friction\", size=1, mask_width=0.1)\n    >>> friction.data[:] = 0.6\n    >>>\n    >>> # Use in expressions with explicit masking\n    >>> eta = friction.sym[0] * friction.mask",
    "harvested_comments": [
      "Variable with units and mask",
      "Use in expressions with explicit masking"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "get_variable",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 950,
    "signature": "(self, name: str) -> SurfaceVariable",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "SurfaceVariable",
    "existing_docstring": "Get an existing variable by name.\n\nArgs:\n    name: Variable name\n\nReturns:\n    SurfaceVariable\n\nRaises:\n    KeyError: If variable doesn't exist",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "variables",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 965,
    "signature": "(self) -> Dict[str, SurfaceVariable]",
    "parameters": [],
    "returns": "Dict[str, SurfaceVariable]",
    "existing_docstring": "Dictionary of all variables on this surface.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 971,
    "signature": "(self, filename: str) -> None",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Save surface with all variables to VTK file.\n\nAll SurfaceVariable data is automatically included in the VTK file\nas point_data arrays.\n\nArgs:\n    filename: Output path (.vtk or .vtp)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "refinement_metric",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1012,
    "signature": "(self, h_near: float, h_far: float, width: float = None, profile: str = 'linear', name: str = None) -> 'MeshVariable'",
    "parameters": [
      {
        "name": "h_near",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "h_far",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "width",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "profile",
        "type_hint": "str",
        "default": "'linear'",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Create a metric field for mesh adaptation based on distance from this surface.\n\nReturns a MeshVariable containing refinement metric values that can\nbe passed directly to mesh.adapt(). Higher metric values produce finer\nmesh (smaller elements).\n\nParameters\n----------\nh_near : float\n    Target edge length near the surface (smaller = finer mesh).\n    Smaller values produce more refinement near the surface.\nh_far : float\n    Target edge length far from the surface (larger = coarser mesh).\n    Larger values allow coarser mesh far from the surface.\nwidth : float, optional\n    Distance over which to transition from h_near to h_far.\n    If None, defaults to 2 * h_far.\nprofile : str, optional\n    Transition profile: \"linear\", \"smoothstep\", or \"gaussian\".\n    Default is \"linear\".\nname : str, optional\n    Name for the metric MeshVariable. Defaults to \"{surface_name}_metric\".\n\nReturns\n-------\nMeshVariable\n    Scalar MeshVariable containing refinement metric values.\n\nNotes\n-----\n**Metric Tensor Mathematics**\n\nFor isotropic mesh adaptation, MMG/PETSc uses a metric tensor:\n\n.. math::\n\n    M = h^{-2} \\cdot I\n\nwhere :math:`h` is the target edge length and :math:`I` is the identity\nmatrix. This relationship is **dimension-independent** - the same formula\napplies in 2D and 3D because the metric defines edge lengths, not areas\nor volumes.\n\nThe adaptation algorithm seeks to make all edges have unit length in the\nmetric space (i.e., :math:`\\mathbf{e}^T M \\mathbf{e} = 1` for edge vector\n:math:`\\mathbf{e}`). Higher metric values produce smaller elements.\n\n**Refinement Ratio**\n\nThe refinement ratio is ``h_far / h_near``. For example, if ``h_near=0.01``\nand ``h_far=0.1``, the mesh will be ~10\u00d7 finer near the surface.\n\n**Element Count Control**\n\nTo maintain approximately the same total element count while refining\nnear the surface, the far-field should use similar h to the original\nmesh's cell size. The refined region is small, so coarsening the far-field\nslightly can compensate.\n\nReferences\n----------\n.. [1] MMG Platform documentation: http://www.mmgtools.org/\n.. [2] Alauzet, F. \"Metric-based anisotropic mesh adaptation\" (2010)\n\nExamples\n--------\n>>> fault = uw.meshing.Surface(\"fault\", mesh, fault_points)\n>>> fault.discretize()\n>>>\n>>> # 10x refinement near fault, maintain original density far away\n>>> metric = fault.refinement_metric(h_near=0.005, h_far=0.05)\n>>> mesh.adapt(metric)",
    "harvested_comments": [
      "10x refinement near fault, maintain original density far away",
      "Create metric MeshVariable",
      "Get distance values directly from the distance MeshVariable",
      "Compute target edge lengths based on distance profile",
      "Convert to metric tensor: M = 1/h\u00b2 \u00d7 I (isotropic)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "from_vtk",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1139,
    "signature": "(cls, filename: str, mesh: 'Mesh' = None, name: str = None) -> 'Surface'",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": "None",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "'Surface'",
    "existing_docstring": "Load surface from VTK file.\n\nAll point_data arrays in the VTK file are automatically wrapped\nas SurfaceVariables.\n\nArgs:\n    filename: Path to VTK file (.vtk or .vtp)\n    mesh: Computational mesh (required for .sym access)\n    name: Name for the surface. If None, uses filename stem.\n\nReturns:\n    Surface with all variables from VTK file\n\nRaises:\n    FileNotFoundError: If file doesn't exist\n    ImportError: If pyvista not available",
    "harvested_comments": [
      "Compute normals if not present",
      "Wrap existing point_data as SurfaceVariables",
      "Skip built-in normals"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "compute_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1193,
    "signature": "(self, consistent_normals: bool = True) -> None",
    "parameters": [
      {
        "name": "consistent_normals",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Recompute vertex and face normals.\n\nArgs:\n    consistent_normals: If True, attempt to make normals consistently oriented",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "flip_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1207,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Flip the direction of all normals.\n\nThis directly negates the normal vectors. Note that pyvista's\ncompute_normals() uses consistent orientation so we can't rely\non flip_faces() to reverse normals - we must negate them explicitly.",
    "harvested_comments": [
      "Ensure normals are computed",
      "Directly negate the point normals",
      "Also negate cell normals if present"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": true
  },
  {
    "name": "add",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1281,
    "signature": "(self, surface: Surface) -> None",
    "parameters": [
      {
        "name": "surface",
        "type_hint": "Surface",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Add a surface to the collection.\n\nArgs:\n    surface: Surface to add\n\nRaises:\n    ValueError: If surface with same name already exists",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "add_from_vtk",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1298,
    "signature": "(self, filename: str, mesh: 'Mesh' = None, name: str = None) -> Surface",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": "None",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Surface",
    "existing_docstring": "Load and add a surface from VTK file.\n\nArgs:\n    filename: Path to VTK file\n    mesh: Computational mesh\n    name: Name for the surface. If None, uses filename stem.\n\nReturns:\n    The loaded Surface",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "remove",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1318,
    "signature": "(self, name: str) -> Surface",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Surface",
    "existing_docstring": "Remove and return a surface from the collection.\n\nArgs:\n    name: Name of surface to remove\n\nReturns:\n    The removed Surface\n\nRaises:\n    KeyError: If surface not found",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "names",
    "kind": "property",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1347,
    "signature": "(self) -> List[str]",
    "parameters": [],
    "returns": "List[str]",
    "existing_docstring": "List of surface names.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "compute_distance_field",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1351,
    "signature": "(self, mesh: 'Mesh', distance_var: 'MeshVariable' = None, variable_name: str = 'surface_distance') -> 'MeshVariable'",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "distance_var",
        "type_hint": "'MeshVariable'",
        "default": "None",
        "description": ""
      },
      {
        "name": "variable_name",
        "type_hint": "str",
        "default": "'surface_distance'",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Compute minimum distance from mesh points to any surface.\n\nArgs:\n    mesh: The mesh to compute distances on\n    distance_var: Optional existing MeshVariable to store results\n    variable_name: Name for new variable if distance_var is None\n\nReturns:\n    MeshVariable with distance values (scalar)",
    "harvested_comments": [
      "Ensure all surfaces are discretized",
      "Create or use existing variable",
      "Get mesh coordinates",
      "Initialize with large distance",
      "Compute unsigned distance to each surface, take minimum."
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "transfer_normals",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1414,
    "signature": "(self, mesh: 'Mesh', coords: np.ndarray = None, normal_var: 'MeshVariable' = None, variable_name: str = 'surface_normals') -> 'MeshVariable'",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": "None",
        "description": ""
      },
      {
        "name": "normal_var",
        "type_hint": "'MeshVariable'",
        "default": "None",
        "description": ""
      },
      {
        "name": "variable_name",
        "type_hint": "str",
        "default": "'surface_normals'",
        "description": ""
      }
    ],
    "returns": "'MeshVariable'",
    "existing_docstring": "Transfer surface normals to mesh points via nearest-neighbor.\n\nFor each mesh point, finds the closest surface face and copies\nthat face's normal vector.\n\nArgs:\n    mesh: The mesh to transfer normals to\n    coords: Optional coordinates to query. If None, uses mesh.data\n    normal_var: Optional existing MeshVariable\n    variable_name: Name for new variable\n\nReturns:\n    MeshVariable with normal vectors (3 components)",
    "harvested_comments": [
      "Ensure all surfaces are discretized",
      "Get query coordinates",
      "Create or validate output variable",
      "Build combined arrays of all face centers and normals",
      "Build KDTree and query"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "influence_function",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1477,
    "signature": "(self, mesh: 'Mesh', width: float, value_near: Union[float, sympy.Expr] = 1.0, value_far: Union[float, sympy.Expr] = 0.0, profile: str = 'step') -> sympy.Expr",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "width",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "value_near",
        "type_hint": "Union[float, sympy.Expr]",
        "default": "1.0",
        "description": ""
      },
      {
        "name": "value_far",
        "type_hint": "Union[float, sympy.Expr]",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "profile",
        "type_hint": "str",
        "default": "'step'",
        "description": ""
      }
    ],
    "returns": "sympy.Expr",
    "existing_docstring": "Create combined influence function from all surfaces.\n\nArgs:\n    mesh: Computational mesh\n    width: Characteristic width of the transition zone\n    value_near: Value at/near surfaces\n    value_far: Value far from surfaces\n    profile: Transition profile (step, linear, gaussian, smoothstep)\n\nReturns:\n    sympy.Expr based on combined distance field",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "create_weakness_function",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1519,
    "signature": "(self, distance_var: 'MeshVariable', fault_width: float, eta_weak: float = 0.01, eta_background: float = 1.0) -> sympy.Expr",
    "parameters": [
      {
        "name": "distance_var",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      },
      {
        "name": "fault_width",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "eta_weak",
        "type_hint": "float",
        "default": "0.01",
        "description": ""
      },
      {
        "name": "eta_background",
        "type_hint": "float",
        "default": "1.0",
        "description": ""
      }
    ],
    "returns": "sympy.Expr",
    "existing_docstring": "Create Piecewise viscosity function for fault weakness.\n\nDEPRECATED: Use influence_function() instead.\n\nArgs:\n    distance_var: MeshVariable containing distances\n    fault_width: Width of the weak zone\n    eta_weak: Viscosity within weak zone\n    eta_background: Viscosity outside weak zone\n\nReturns:\n    sympy.Piecewise expression",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SurfaceCollection",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/model.py",
    "line": 149,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The primary mesh for this model",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "list_meshes",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 174,
    "signature": "(self) -> Dict[int, Any]",
    "parameters": [],
    "returns": "Dict[int, Any]",
    "existing_docstring": "List all meshes registered with this model",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_mesh",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 178,
    "signature": "(self, mesh_id: int)",
    "parameters": [
      {
        "name": "mesh_id",
        "type_hint": "int",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get a mesh by ID from the model registry",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_primary_mesh",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 182,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set a mesh as the primary mesh for this model.\n\nParameters:\n-----------\nmesh : uw.discretisation.Mesh\n    Mesh to set as primary (must already be registered)",
    "harvested_comments": [
      "Register the mesh first",
      "Just update the primary mesh pointer"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_mesh",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 325,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set or replace the primary mesh for this model.\n\nThis method handles:\n- Registering mesh if not already registered\n- Setting as primary mesh\n- Incrementing version for change tracking\n\nParameters:\n-----------\nmesh : uw.discretisation.Mesh\n    The new mesh to use as primary for this model",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_variable",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 389,
    "signature": "(self, name: str, mesh = None, swarm = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "swarm",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get a variable by name from the model registry.\n\nParameters:\n-----------\nname : str\n    Variable name to look up\nmesh : Mesh, optional\n    If provided, look for variable specifically on this mesh\nswarm : Swarm, optional\n    If provided, look for variable specifically on this swarm\n\nReturns:\n--------\nVariable or None",
    "harvested_comments": [
      "Try exact name first",
      "If mesh/swarm specified, verify it matches",
      "Look for qualified name",
      "Look for qualified name",
      "No specific container requested, return whatever we found"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_qualified_name",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 443,
    "signature": "(self, variable)",
    "parameters": [
      {
        "name": "variable",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get the fully qualified name for a variable.\n\nReturns the name that uniquely identifies this variable in the model registry,\nwhich may include mesh/swarm ID qualifiers to resolve namespace conflicts.\n\nParameters:\n-----------\nvariable : MeshVariable or SwarmVariable\n    Variable to get qualified name for\n\nReturns:\n--------\nstr or None : Qualified name if found, None otherwise",
    "harvested_comments": [
      "Search through all registered names"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "transfer_variable_data",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 465,
    "signature": "(self, source_var, target_var)",
    "parameters": [
      {
        "name": "source_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Transfer data from source variable to target variable using global_evaluate.\n\nThis enables persistent variable identity across mesh changes by transferring\ndata from variables on old meshes to variables on new meshes.\n\nParameters:\n-----------\nsource_var : MeshVariable or SwarmVariable\n    Source variable to transfer data from\ntarget_var : MeshVariable or SwarmVariable\n    Target variable to transfer data to\n\nReturns:\n--------\nbool : True if transfer successful, False otherwise",
    "harvested_comments": [
      "Import global_evaluate for mesh-to-mesh transfer",
      "Get target coordinates based on variable type",
      "Use attribute detection for wrapper compatibility",
      "Mesh variable (direct or wrapped)",
      "Swarm variable"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "list_variables",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 514,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "List all variables registered with this model",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "list_swarms",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 518,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "List all swarms registered with this model",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "add_solver",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 522,
    "signature": "(self, name: str, solver)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "solver",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register a solver with this model",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_solver",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 527,
    "signature": "(self, name: str)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get a solver by name from the model registry",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "define_parameter",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 531,
    "signature": "(self, name: str, ptype = None, **kwargs)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "ptype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Define a new parameter with validation rules.\n\nNOTE: Parameter system not yet implemented. Use model.materials dict directly.\n\nParameters:\n-----------\nname : str\n    Parameter path (e.g., 'material.viscosity', 'solver.tolerance')\nptype : ParameterType, optional\n    Parameter type for validation (not used yet)\n**kwargs : dict\n    Additional arguments",
    "harvested_comments": [
      "TODO: Implement when parameter system is ready"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_material",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 551,
    "signature": "(self, name: str, properties: Dict[str, Any])",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "properties",
        "type_hint": "Dict[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set material properties (simple dictionary).\n\nParameters:\n-----------\nname : str\n    Material name (e.g., 'mantle', 'crust', 'plume')\nproperties : dict\n    Dictionary of property_name -> value/expression\n\nExample:\n--------\n>>> model.set_material('mantle', {'viscosity': 1e21, 'density': 3300})",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_material",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 569,
    "signature": "(self, name: str)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get material properties by name",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_reference_quantities",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 573,
    "signature": "(self, verbose = False, nondimensional_scaling = True, **quantities)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nondimensional_scaling",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "**quantities",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set reference quantities for automatic units scaling.\n\nThis method enables the hybrid SymPy+Pint units workflow by allowing users\nto specify their problem in natural units, from which the system derives\noptimal scaling for numerical conditioning.\n\nBy default, this automatically enables non-dimensionalization for solvers,\nensuring consistent behavior between user-facing units and solver internals.\n\nParameters:\n-----------\nverbose : bool, optional\n    If True, print diagnostic information about dimensional analysis\n    and scale derivation. Default: False.\nnondimensional_scaling : bool, optional\n    Enable automatic non-dimensionalization for solvers (default: True).\n    When True (recommended), solver operations work in non-dimensional\n    [0-1] space while user-facing values remain in physical units.\n    Set to False for expert mode (dimensional units only, no scaling).\n    **Warning**: Disabling this may cause numerical conditioning issues\n    and inconsistencies in unit conversions.\n**quantities : dict\n    Named reference quantities using Pint units or UWQuantity objects, e.g.:\n    - mantle_viscosity=1e21*uw.units.Pa*uw.units.s\n    - plate_velocity=5*uw.units.cm/uw.units.year\n    - domain_depth=3000*uw.units.km\n    OR using uw.quantity():\n    - domain_depth=uw.quantity(2900, \"km\")\n\nExample:\n--------\n>>> # Standard usage (recommended for most users)\n>>> model.set_reference_quantities(\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     domain_depth=3000*uw.units.km\n... )\n# \u2713 Units system active with automatic non-dimensionalization\n\n>>> # Also accepts UWQuantity objects\n>>> model.set_reference_quantities(\n...     domain_depth=uw.quantity(2900, \"km\"),\n...     mantle_viscosity=uw.quantity(1e21, \"Pa*s\")\n... )\n\n>>> # Expert mode (not recommended - dimensional units without scaling)\n>>> model.set_reference_quantities(\n...     domain_depth=uw.quantity(2900, \"km\"),\n...     nondimensional_scaling=False\n... )\n# \u26a0 Expert mode: Units active WITHOUT non-dimensionalization\n\n>>> # With diagnostic output\n>>> model.set_reference_quantities(\n...     verbose=True,\n...     domain_depth=uw.quantity(500, \"m\"),\n...     mantle_temperature=uw.quantity(1300, \"K\")\n... )\n\nNotes:\n------\nThis method creates a Pint-native registry with model-specific constants\nusing the _constants pattern for optimal numerical conditioning.\n\nThe default behavior (nondimensional_scaling=True) ensures:\n- User-facing values in physical units (km, Myr, Pa*s, etc.)\n- Solver operations in well-conditioned non-dimensional [0-1] space\n- Automatic conversions handled transparently\n\nRaises:\n-------\nRuntimeError\n    If called after a mesh has been created (units are locked)",
    "harvested_comments": [
      "Standard usage (recommended for most users)",
      "\u2713 Units system active with automatic non-dimensionalization",
      "Also accepts UWQuantity objects",
      "Expert mode (not recommended - dimensional units without scaling)",
      "\u26a0 Expert mode: Units active WITHOUT non-dimensionalization"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_reference_quantities",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 758,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the reference quantities for this model.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "fundamental_scales",
    "kind": "property",
    "file": "src/underworld3/model.py",
    "line": 763,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Access the derived fundamental scales for dimensional analysis.\n\nReturns the canonical fundamental scaling quantities [L], [M], [T], [\u03b8]\nthat were automatically derived from the reference quantities via dimensional analysis.\nThese scales are used throughout the system for automatic non-dimensionalization.\n\nThe system extracts these fundamental scales from user-provided reference quantities\n(which can have any domain-specific names) through pure dimensional analysis.\nThis provides a domain-agnostic API independent of parameter naming.\n\nReturns\n-------\ndict\n    Dictionary mapping canonical dimension names to their scaling quantities:\n    - 'length': Length scale [L] (e.g., 1000 m)\n    - 'time': Time scale [T] (e.g., 1 Myr)\n    - 'mass': Mass scale [M] (e.g., 1e24 kg)\n    - 'temperature': Temperature scale [\u03b8] (e.g., 1000 K)\n    - Plus any additional dimensions (velocity, viscosity, pressure, etc.)\n\nExample\n-------\n>>> model = uw.get_default_model()\n>>> model.set_reference_quantities(\n...     domain_depth=uw.quantity(2900, \"km\"),\n...     plate_velocity=uw.quantity(5, \"cm/year\"),\n...     mantle_viscosity=uw.quantity(1e21, \"Pa*s\"),\n...     temperature_difference=uw.quantity(3000, \"K\")\n... )\n>>> # Access derived fundamental scales (NOT the user-provided reference quantities)\n>>> L0 = model.fundamental_scales['length']      # 2900 km\n>>> T0 = model.fundamental_scales['time']        # ~1.8 Myr\n>>> eta0 = model.fundamental_scales['viscosity'] # 1e21 Pa*s\n>>> DeltaT = model.fundamental_scales['temperature']  # 3000 K\n\nNotes\n-----\n- These are the ROUNDED fundamental scales stored internally after dimensional analysis\n- The scales may have been rounded to nice values for O(1) numerical conditioning\n- Use these scales for physical interpretation of non-dimensional solutions\n- Do NOT use user-provided reference quantity names (domain-specific)",
    "harvested_comments": [
      "Access derived fundamental scales (NOT the user-provided reference quantities)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 809,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this model has units scaling enabled.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "validate_reference_quantities",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 813,
    "signature": "(self, raise_on_error = False)",
    "parameters": [
      {
        "name": "raise_on_error",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Validate that all registered variables with units have required reference quantities.\n\nThis method checks each variable and reports any missing reference quantities\nneeded to properly derive scaling coefficients.\n\nParameters:\n-----------\nraise_on_error : bool, optional\n    If True, raise ValueError on validation failure. If False (default),\n    return validation results without raising.\n\nReturns:\n--------\ndict\n    Validation results with keys:\n    - 'valid': bool - Overall validation status\n    - 'warnings': list of warning messages\n    - 'errors': list of error messages\n\nExample:\n--------\n>>> model = uw.get_default_model()\n>>> model.set_reference_quantities(domain_depth=uw.quantity(1000, \"km\"))\n>>> mesh = uw.meshing.StructuredQuadBox(...)\n>>> v = uw.discretisation.MeshVariable('v', mesh, 2, degree=2, units='m/s')\n>>> result = model.validate_reference_quantities()\n>>> if not result['valid']:\n...     print(\"\\n\".join(result['errors']))",
    "harvested_comments": [
      "Check all registered variables",
      "Skip variables without units",
      "Validate this variable",
      "Also check if scaling_coefficient is still 1.0"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_coordinate_unit",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 873,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the coordinate unit for this model.\n\nReturns the length unit from reference quantities if set,\notherwise returns None (dimensionless).\n\nReturns:\n--------\npint.Unit or None\n    Coordinate unit object (e.g., <Unit('kilometer')>) or None if no units set\n\nExample:\n--------\n>>> model.set_reference_quantities(domain_depth=uw.quantity(500, \"km\"))\n>>> model.get_coordinate_unit()\n<Unit('kilometer')>  # Or <Unit('megameter')> if using engineering rounding\n\nChanged in 2025-10-16: Now returns pint.Unit objects instead of strings\nfor consistency and to enable natural unit arithmetic (e.g., var.units / mesh.units).",
    "harvested_comments": [
      "Or <Unit('megameter')> if using engineering rounding",
      "Check if we have reference quantities with length scale",
      "Look for any length-dimensioned quantity",
      "Check if this is a Pint quantity (has _pint_qty attribute)",
      "Get the Pint unit object directly (not the string property)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_as_default",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 949,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Explicitly set this model as the default model.\n\nThis is useful when working with multiple models (e.g., loading from disk)\nand you want to explicitly control which model is active.\n\nReturns:\n--------\nModel\n    Returns self for method chaining\n\nExample:\n--------\n>>> model1 = uw.Model()\n>>> model2 = uw.Model()\n>>> model2.set_as_default()  # Make model2 the active default\n>>> assert uw.get_default_model() is model2",
    "harvested_comments": [
      "Make model2 the active default"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_unit_aliases",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1306,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Get all available unit aliases for user reference.\n\nReturns\n-------\ndict\n    Dictionary mapping dimensions to their available aliases.\n\nExamples\n--------\n>>> model.get_unit_aliases()\n{\n    'length': {\n        'ascii': ['L_ref', 'L_scale', 'L_model', 'length_scale'],\n        'unicode': '\u2112',\n        'display': '\u2112',\n        'technical': '_1000km'\n    },\n    ...\n}",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "derive_fundamental_scalings",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1680,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Derive fundamental scaling units (length, time, mass, temperature) from reference quantities.\n\nThis method analyzes the dimensional structure of reference quantities to automatically\ndetermine optimal fundamental scalings for the problem domain.\n\nReturns\n-------\ndict\n    Dictionary of fundamental scalings with keys like '[length]', '[time]', '[mass]', '[temperature]'\n\nExamples\n--------\n>>> model.set_reference_quantities(\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> scalings = model.derive_fundamental_scalings()\n>>> scalings['[length]']  # Derived from plate_velocity\n>>> scalings['[time]']    # Derived from plate_velocity\n>>> scalings['[temperature]']  # Direct from mantle_temperature",
    "harvested_comments": [
      "Derived from plate_velocity",
      "Derived from plate_velocity",
      "Direct from mantle_temperature",
      "Check for over-determined systems before proceeding",
      "Import units (Pint) for dimensional analysis"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_fundamental_scales",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1931,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Get fundamental scales in user-friendly format.\n\nReturns the derived fundamental scaling quantities (length, time, mass, temperature)\nthat the model uses for dimensional analysis. These are the base scales from which\nall other quantities are converted to model units.\n\nIMPORTANT: Returns the ROUNDED scales stored in _fundamental_scales, not re-derived.\nThe scales may have been rounded to nice values for O(1) numerical conditioning.\n\nReturns\n-------\ndict\n    Dictionary mapping dimension names to their scaling quantities:\n    - 'length': Length scale quantity (e.g., 1000 m, rounded from 500 m)\n    - 'time': Time scale quantity (e.g., 1 Myr, rounded)\n    - 'mass': Mass scale quantity (e.g., 1e11 kg, rounded)\n    - 'temperature': Temperature scale quantity (e.g., 1000 K, rounded)\n    - Plus any additional dimensions detected (current, substance, etc.)\n\nExamples\n--------\n>>> model.set_reference_quantities(\n...     domain_depth=500*uw.units.m,  # Will round to 1000 m\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> scales = model.get_fundamental_scales()\n>>> scales['length']  # 1000 meter (rounded, not 500)",
    "harvested_comments": [
      "Will round to 1000 m",
      "1000 meter (rounded, not 500)",
      "Return the ROUNDED scales, not re-derived ones!",
      "The _fundamental_scales dict contains rounded values for O(1) conditioning",
      "_fundamental_scales already has user-friendly keys ('length', 'time', etc.)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_scale_for_dimensionality",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1978,
    "signature": "(self, dimensionality: dict)",
    "parameters": [
      {
        "name": "dimensionality",
        "type_hint": "dict",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get appropriate reference scale for given dimensionality.\n\nFirst checks if user explicitly provided a reference quantity with this exact\ndimensionality (e.g., diffusivity=1e-6 m\u00b2/s). If found, uses that directly.\nOtherwise, computes from fundamental scales (length, time, mass, temperature).\n\nThis design ensures that explicit user-provided scales take precedence over\nderived scales, which is important for physical accuracy. For example, thermal\ndiffusivity (~1e-6 m\u00b2/s) is orders of magnitude different from L\u00b2/t derived\nfrom mantle convection length and time scales.\n\nParameters\n----------\ndimensionality : dict\n    Pint dimensionality dictionary, e.g., {'[length]': 1, '[time]': -1}\n    for velocity, {'[mass]': 1, '[length]': -1, '[time]': -2} for pressure\n\nReturns\n-------\npint.Quantity\n    Reference scale with appropriate dimensionality\n\nRaises\n------\nValueError\n    If dimensionality requires scales not available in fundamental scales\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_depth=uw.quantity(2900, \"km\"), ...)\n>>> velocity_dim = {'[length]': 1, '[time]': -1}\n>>> v_scale = model.get_scale_for_dimensionality(velocity_dim)\n>>> # v_scale = 2900 km / (time_scale) in m/s\n\n>>> pressure_dim = {'[mass]': 1, '[length]': -1, '[time]': -2}\n>>> p_scale = model.get_scale_for_dimensionality(pressure_dim)\n>>> # p_scale = M/(L\u00b7T\u00b2) in Pa\n\n>>> # Explicit diffusivity takes precedence over L\u00b2/t\n>>> model.set_reference_quantities(\n...     length=uw.quantity(2900, \"km\"),\n...     time=uw.quantity(1e15, \"s\"),\n...     diffusivity=uw.quantity(1e-6, \"m**2/s\")  # Explicit!\n... )\n>>> diff_dim = {'[length]': 2, '[time]': -1}\n>>> diff_scale = model.get_scale_for_dimensionality(diff_dim)\n>>> # diff_scale = 1e-6 m\u00b2/s (explicit), NOT L\u00b2/t = 8.41e-3 m\u00b2/s",
    "harvested_comments": [
      "v_scale = 2900 km / (time_scale) in m/s",
      "p_scale = M/(L\u00b7T\u00b2) in Pa",
      "Explicit diffusivity takes precedence over L\u00b2/t",
      "diff_scale = 1e-6 m\u00b2/s (explicit), NOT L\u00b2/t = 8.41e-3 m\u00b2/s",
      "PRIORITY 1: Check if user explicitly provided a reference quantity"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_model_base_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2094,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Get model base units in compact, parseable SI prefix form.\n\nReturns a dictionary mapping dimension names to their compact SI unit representations.\nUses Pint's to_compact() to automatically select readable SI prefixes (e.g., 'Mm' for\nmegameters, 'Ps' for petaseconds).\n\nReturns\n-------\ndict\n    Dictionary with dimension names as keys and compact SI unit strings as values\n\nExamples\n--------\n>>> model.set_reference_quantities(\n...     mantle_depth=2900*uw.units.km,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> base_units = model.get_model_base_units()\n>>> base_units['length']  # \"2.9 megameter\" (parseable)\n>>> base_units['time']    # \"1.83 petasecond\" (parseable)",
    "harvested_comments": [
      "\"2.9 megameter\" (parseable)",
      "\"1.83 petasecond\" (parseable)",
      "Convert to compact SI prefix form (e.g., Mm, Ps, etc.)",
      "Return as parseable string like \"2.9 megameter\"",
      "Fallback to base units if compact fails"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_scale_summary",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2212,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Get a human-readable summary of all fundamental scales.\n\nReturns a formatted string showing the fundamental scales derived from\nreference quantities, including how each scale was derived and what\nreference quantities it makes close to unity.\n\nReturns\n-------\nstr\n    Multi-line string with formatted scale summary\n\nExamples\n--------\n>>> model.set_reference_quantities(\n...     mantle_depth=2900*uw.units.km,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> print(model.get_scale_summary())\nFundamental Scales Summary:\n\nLength Scale: 2900 kilometer\n  - From: mantle_depth\n  - Makes: mantle_depth \u2248 1.0 in model units\n\nTime Scale: 580 kilometer\u00b7year/centimeter\n  - From: length_scale \u00f7 plate_velocity\n  - Makes: plate_velocity \u2248 1.0 in model units\n\nMass Scale: 1.68e+27 kg (equivalent)\n  - From: mantle_viscosity \u00d7 length_scale \u00d7 time_scale\n  - Makes: mantle_viscosity \u2248 1.0 in model units\n\nTemperature Scale: 1500 kelvin\n  - From: mantle_temperature\n  - Makes: mantle_temperature \u2248 1.0 in model units",
    "harvested_comments": [
      "Define display order and nice names",
      "Use Pint's smart formatting capabilities",
      "Show derivation source with user's terminology",
      "Show what this makes ~1.0 in model units",
      "Add any additional scales not in the standard order"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "list_derived_scales",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2380,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "List which scales were derived vs. directly specified.\n\nReturns a dictionary categorizing fundamental scales by how they were obtained:\neither directly from reference quantities or derived from compound quantities.\n\nReturns\n-------\ndict\n    Dictionary with keys:\n    - 'direct': List of (dimension, source) tuples for directly specified scales\n    - 'derived': List of (dimension, derivation) tuples for derived scales\n    - 'missing': List of standard dimensions that couldn't be determined\n\nExamples\n--------\n>>> model.set_reference_quantities(\n...     mantle_depth=2900*uw.units.km,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> derivation = model.list_derived_scales()\n>>> derivation['direct']    # [('length', 'mantle_depth'), ('temperature', 'mantle_temperature')]\n>>> derivation['derived']   # [('time', 'length_scale \u00f7 plate_velocity'), ('mass', 'mantle_viscosity \u00d7 length_scale \u00d7 time_scale')]\n>>> derivation['missing']   # []",
    "harvested_comments": [
      "[('length', 'mantle_depth'), ('temperature', 'mantle_temperature')]",
      "[('time', 'length_scale \u00f7 plate_velocity'), ('mass', 'mantle_viscosity \u00d7 length_scale \u00d7 time_scale')]",
      "Standard dimensions we expect to see",
      "Categorize each scale found",
      "Check if it's a direct mapping (starts with \"from \" and no operators)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "validate_dimensional_completeness",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2456,
    "signature": "(self, required_dimensions = None) -> dict",
    "parameters": [
      {
        "name": "required_dimensions",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": "dict",
    "existing_docstring": "Validate if reference quantities provide complete dimensional coverage.\n\nChecks whether the current reference quantities span enough dimensions\nto derive fundamental scales for all required dimensions, and provides\nsuggestions for completing under-determined systems.\n\nParameters\n----------\nrequired_dimensions : list, optional\n    List of dimensions required (e.g., ['length', 'time', 'mass', 'temperature']).\n    If None, uses the standard 4-dimension set.\n\nReturns\n-------\ndict\n    Validation result containing:\n    - 'status': 'complete', 'under_determined', or 'no_reference_quantities'\n    - 'missing_dimensions': List of missing dimensions (if any)\n    - 'suggestions': List of suggested reference quantities to add\n    - 'derivable_dimensions': List of dimensions that can be derived\n    - 'analysis': Human-readable analysis string\n\nExamples\n--------\n>>> # Under-determined system\n>>> model.set_reference_quantities(mantle_depth=2900*uw.units.km)\n>>> result = model.validate_dimensional_completeness()\n>>> result['status']  # 'under_determined'\n>>> result['missing_dimensions']  # ['time', 'mass', 'temperature']\n\n>>> # Complete system\n>>> model.set_reference_quantities(\n...     mantle_depth=2900*uw.units.km,\n...     plate_velocity=5*uw.units.cm/uw.units.year,\n...     mantle_viscosity=1e21*uw.units.Pa*uw.units.s,\n...     mantle_temperature=1500*uw.units.K\n... )\n>>> result = model.validate_dimensional_completeness()\n>>> result['status']  # 'complete'",
    "harvested_comments": [
      "Under-determined system",
      "'under_determined'",
      "['time', 'mass', 'temperature']",
      "Complete system",
      "Get what dimensions we can actually derive"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_scaling_mode",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2674,
    "signature": "(self, mode = 'exact')",
    "parameters": [
      {
        "name": "mode",
        "type_hint": null,
        "default": "'exact'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the scaling mode for fundamental scales.\n\nParameters\n----------\nmode : {'exact', 'readable'}\n    Scaling mode to use:\n    - 'exact': Reference quantities scale to exactly 1.0 (default)\n    - 'readable': Reference quantities scale to O(1) with nice round numbers\n\nExamples\n--------\n>>> # Default exact mode: reference quantities become exactly 1.0\n>>> model.set_scaling_mode('exact')\n>>> model.set_reference_quantities(mantle_depth=2900*uw.units.km)\n>>> model.to_model_units(2900*uw.units.km)  # \u2192 UWQuantity(1.0, 'model_length_units')\n\n>>> # Readable mode: reference quantities become O(1) with nice scales\n>>> model.set_scaling_mode('readable')\n>>> model.set_reference_quantities(mantle_depth=2900*uw.units.km)\n>>> model.to_model_units(2900*uw.units.km)  # \u2192 UWQuantity(2.9, 'model_length_units')\n>>> # Internal scale becomes 1000 km instead of 2900 km",
    "harvested_comments": [
      "Default exact mode: reference quantities become exactly 1.0",
      "\u2192 UWQuantity(1.0, 'model_length_units')",
      "Readable mode: reference quantities become O(1) with nice scales",
      "\u2192 UWQuantity(2.9, 'model_length_units')",
      "Internal scale becomes 1000 km instead of 2900 km"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_scaling_mode",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2707,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Get the current scaling mode.\n\nReturns\n-------\nstr\n    Current scaling mode: 'exact' or 'readable'",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "show_optimal_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2919,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display the optimal units implied by this model's reference quantities.\n\nShows fundamental scalings (length, time, mass, temperature) derived from\nreference quantities and suggests optimal units for various physical quantities.",
    "harvested_comments": [
      "# Optimal Units for Model: {self.name}\"]",
      "Show fundamental scalings",
      "## Fundamental Scalings\")",
      "Derive optimal units for common quantities",
      "## Recommended Units for This Problem\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "scale_to_physical",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3250,
    "signature": "(self, coordinates, dimension = 'length')",
    "parameters": [
      {
        "name": "coordinates",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dimension",
        "type_hint": null,
        "default": "'length'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert dimensionless model coordinates to physical units.\n\nThis method converts model-unit coordinate arrays (where the model domain\nis scaled to ~1.0) back to physical units using the model's fundamental scales.\n\nParameters\n----------\ncoordinates : array-like\n    Dimensionless coordinate array in model units\ndimension : str, default 'length'\n    Fundamental dimension to use for scaling ('length', 'time', 'mass', 'temperature')\n\nReturns\n-------\nUWQuantity\n    Coordinates in physical units with appropriate units\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_length=1000*uw.units.km, ...)\n>>> mesh = uw.meshing.StructuredQuadBox(minCoords=(-3,-3), maxCoords=(3,3), ...)\n>>> # mesh.points are in model units (dimensionless, domain spans -3 to 3)\n>>> physical_coords = model.scale_to_physical(mesh.points)\n>>> # Result: coordinates in kilometers, spanning -3000 to 3000 km\n\nRaises\n------\nValueError\n    If no reference quantities set or dimension not available",
    "harvested_comments": [
      "mesh.points are in model units (dimensionless, domain spans -3 to 3)",
      "Result: coordinates in kilometers, spanning -3000 to 3000 km",
      "Get fundamental scales",
      "Get the scale for this dimension",
      "Import here to avoid circular imports"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "to_model_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3311,
    "signature": "(self, quantity)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Safely coerce any quantity to model units using smart protocol pattern.\n\nThis method is designed to be safe to call repeatedly and handles edge cases:\n1. Does nothing if model has no units (no reference quantities set)\n2. Does nothing if the quantity is already in model units\n3. Does nothing if the quantity is dimensionless\n4. Uses protocol pattern for extensible conversion\n\nParameters\n----------\nquantity : Any\n    Quantity to convert (UWQuantity, Pint quantity, numeric, etc.)\n\nReturns\n-------\nUWQuantity or original quantity\n    Converted quantity in model units, or original if no conversion needed",
    "harvested_comments": [
      "1) Do nothing if there are no units (no reference quantities set)",
      "2) Do nothing if quantity is already in model units",
      "Check if it's a UWQuantity with model_units=True flag",
      "3) Early check for dimensionless quantities - do nothing",
      "Quick dimensionality check without full conversion"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "has_units_active",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3563,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if the units system is active (reference quantities have been set).\n\nReturns\n-------\nbool\n    True if reference quantities have been set, False otherwise.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "to_model_magnitude",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3574,
    "signature": "(self, quantity, expected_dimension = None)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expected_dimension",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert quantity to model units and extract numerical magnitude.\n\nThis is a convenience method that combines to_model_units() with magnitude\nextraction for internal use. It handles the common pattern of converting\nuser inputs (which may have units) to raw numerical values in model units\nfor internal computations.\n\nParameters\n----------\nquantity : Any\n    Quantity to convert (UWQuantity, Pint quantity, numeric, tuple, etc.)\nexpected_dimension : str, optional\n    Expected dimension like '[length]', '[time]', etc. If provided and\n    the quantity is a plain number when units are active, a warning is\n    issued to alert the user that they may have forgotten units.\n    Common values: '[length]', '[time]', '[temperature]', '[mass]'\n\nReturns\n-------\nfloat, int, or array-like\n    Raw numerical magnitude in model units (dimensionless)\n\nExamples\n--------\n>>> model.set_reference_quantities(length_scale=1000*uw.units.km)\n>>> coords_physical = [100*uw.units.km, 200*uw.units.km]\n>>> coords_model = model.to_model_magnitude(coords_physical)\n>>> coords_model\n[0.1, 0.2]  # In model units (dimensionless)\n\n>>> # Also works with plain numbers (pass-through)\n>>> model.to_model_magnitude([0.1, 0.2])\n[0.1, 0.2]\n\n>>> # With expected_dimension, warns on plain numbers when units active\n>>> model.to_model_magnitude(6370, expected_dimension='[length]')\nUserWarning: Plain number 6370 passed for [length] parameter when units\nare active. If you intended physical units, use uw.quantity(6370, 'km').\nValue is being interpreted as 6370 model units.\n\n>>> # Works with time\n>>> dt_physical = 1000 * uw.units.year\n>>> dt_model = model.to_model_magnitude(dt_physical)\n\nNotes\n-----\nThis method is intended for internal use at API boundaries where user\ninputs need to be converted to model units for computations. The conversion\nrespects dimensional analysis and reference quantities.\n\nWhen `expected_dimension` is provided, this acts as a \"gatekeeper\" to catch\npotential bugs where users forget to attach units to their values.",
    "harvested_comments": [
      "In model units (dimensionless)",
      "Also works with plain numbers (pass-through)",
      "With expected_dimension, warns on plain numbers when units active",
      "Works with time",
      "Handle tuples/lists recursively (for coordinate inputs)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "from_model_magnitude",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3693,
    "signature": "(self, magnitude, dimensions)",
    "parameters": [
      {
        "name": "magnitude",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dimensions",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert numerical magnitude in model units back to physical quantity.\n\nThis is the inverse of to_model_magnitude() - it takes a raw numerical value\nin model units and wraps it with appropriate physical units based on the\ndimensional specification.\n\nParameters\n----------\nmagnitude : float, int, or array-like\n    Numerical value(s) in model units (dimensionless)\ndimensions : str or Pint dimensionality\n    Dimensional specification like '[length]', '[time]', '[length]/[time]', etc.\n    Can also be a Pint dimensionality object from quantity.dimensionality\n\nReturns\n-------\nUWQuantity\n    Physical quantity with appropriate units based on model reference scales\n\nExamples\n--------\n>>> model.set_reference_quantities(length_scale=1000*uw.units.km)\n>>> coords_model = np.array([0.1, 0.2])  # Model coordinates\n>>> coords_physical = model.from_model_magnitude(coords_model, '[length]')\n>>> coords_physical\n[100, 200] km  # Back to physical units\n\n>>> # Works with composite dimensions\n>>> velocity_model = 1.0  # Model velocity magnitude\n>>> velocity_physical = model.from_model_magnitude(velocity_model, '[length]/[time]')\n\n>>> # If no reference quantities, returns SI base units\n>>> model_no_refs = uw.Model()\n>>> result = model_no_refs.from_model_magnitude(100, '[length]')\n>>> result\n100 m  # SI base units when no scaling defined\n\nNotes\n-----\nThis method is intended for converting internal model-unit values back to\nphysical quantities when returning results to users. It ensures consistent\nunit handling across API boundaries.",
    "harvested_comments": [
      "Model coordinates",
      "Back to physical units",
      "Works with composite dimensions",
      "Model velocity magnitude",
      "If no reference quantities, returns SI base units"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "to_dict",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3866,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "Export model configuration to dictionary for serialization.\n\nProvides enhanced serialization with SymPy expression conversion\nand PETSc state capture for complete reproducibility.\n\nReturns\n-------\ndict\n    Model configuration dictionary suitable for JSON/YAML export",
    "harvested_comments": [
      "Convert materials with SymPy expression handling"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "export_configuration",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3910,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "Alias for to_dict() for backward compatibility",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "from_dict",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3914,
    "signature": "(self, config: Dict[str, Any])",
    "parameters": [
      {
        "name": "config",
        "type_hint": "Dict[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Import model configuration from dictionary.\n\nHandles enhanced serialization format with SymPy expression reconstruction.\nNote: Only imports materials and metadata for now.\nMesh/variables/swarms must be recreated.\n\nParameters\n----------\nconfig : dict\n    Configuration dictionary from to_dict() or YAML export",
    "harvested_comments": [
      "Import materials with SymPy expression reconstruction",
      "Reconstruct SymPy expression from string",
      "Fall back to string"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "to_yaml",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3955,
    "signature": "(self, file_path: Optional[str] = None) -> str",
    "parameters": [
      {
        "name": "file_path",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "str",
    "existing_docstring": "Export model configuration to YAML format.\n\nParameters\n----------\nfile_path : str, optional\n    If provided, write YAML to this file path\n\nReturns\n-------\nstr\n    YAML string representation of model configuration",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "from_yaml",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3978,
    "signature": "(self, yaml_content: str = None, file_path: str = None)",
    "parameters": [
      {
        "name": "yaml_content",
        "type_hint": "str",
        "default": "None",
        "description": ""
      },
      {
        "name": "file_path",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Import model configuration from YAML.\n\nParameters\n----------\nyaml_content : str, optional\n    YAML string to parse\nfile_path : str, optional\n    Path to YAML file to load",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "from_yaml_file",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4001,
    "signature": "(cls, file_path: str) -> 'Model'",
    "parameters": [
      {
        "name": "file_path",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'Model'",
    "existing_docstring": "Create a new Model instance from YAML file.\n\nParameters\n----------\nfile_path : str\n    Path to YAML configuration file\n\nReturns\n-------\nModel\n    New model instance with loaded configuration",
    "harvested_comments": [
      "Extract model-specific fields"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "capture_petsc_state",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4028,
    "signature": "(self) -> Dict[str, str]",
    "parameters": [],
    "returns": "Dict[str, str]",
    "existing_docstring": "Capture current PETSc options database state.\n\nReturns all PETSc options currently set, enabling complete\nreproducibility of simulation parameters.\n\nReturns\n-------\ndict\n    Dictionary of PETSc option names and values",
    "harvested_comments": [
      "Get all currently set PETSc options",
      "PETSc doesn't provide a direct way to list all options,",
      "but we can capture commonly used ones and any that were set",
      "This is a simplified implementation - full implementation would",
      "require more sophisticated PETSc option introspection"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "restore_petsc_state",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4087,
    "signature": "(self, petsc_options: Optional[Dict[str, str]] = None)",
    "parameters": [
      {
        "name": "petsc_options",
        "type_hint": "Optional[Dict[str, str]]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Restore PETSc options database from captured state.\n\nParameters\n----------\npetsc_options : dict, optional\n    PETSc options to restore. If None, uses self.petsc_state",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "set_petsc_option",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4116,
    "signature": "(self, option: str, value: str)",
    "parameters": [
      {
        "name": "option",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set a PETSc option and track it in model state.\n\nParameters\n----------\noption : str\n    PETSc option name (without leading -)\nvalue : str\n    Option value",
    "harvested_comments": [
      "Track in model state"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4143,
    "signature": "(self, verbose: int = 0, show_materials: bool = True, show_petsc: bool = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": "int",
        "default": "0",
        "description": ""
      },
      {
        "name": "show_materials",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "show_petsc",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Display a concise summary of the model contents.\n\nParameters\n----------\nverbose : int, default 0\n    Verbosity level:\n    0 = Basic summary\n    1 = Include variable details and material properties\n    2 = Include solver information and metadata\nshow_materials : bool, default True\n    Whether to show materials summary\nshow_petsc : bool, default False\n    Whether to show PETSc options (can be lengthy)\n\nExample\n-------\n>>> model.view()                    # Basic summary\n>>> model.view(verbose=1)           # Detailed view\n>>> model.view(verbose=2, show_petsc=True)  # Full details",
    "harvested_comments": [
      "Basic summary",
      "Detailed view",
      "Full details",
      "Build markdown content",
      "Model: {self.name}\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4339,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display comprehensive model information following the established view() pattern.\n\nShows model configuration, units setup, registered components, and provides\nguidance for setting up units if not configured.",
    "harvested_comments": [
      "Build markdown content",
      "# Model: {self.name}\"]",
      "Model state and basic info",
      "Mesh information",
      "## Primary Mesh\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": true
  },
  {
    "name": "get_default_model",
    "kind": "function",
    "file": "src/underworld3/model.py",
    "line": 4491,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get or create the default model for this UW3 session.\n\nThe default model automatically registers all meshes, swarms, variables,\nand solvers created during the session, enabling serialization and\nmodel orchestration without explicit user interaction.\n\nReturns\n-------\nModel\n    The default model instance for this session\n\nExample\n-------\n>>> import underworld3 as uw\n>>> model = uw.get_default_model()\n>>> print(model)  # See all registered objects\n>>> config = model.to_dict()  # Serialize model",
    "harvested_comments": [
      "See all registered objects",
      "Serialize model"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "reset_default_model",
    "kind": "function",
    "file": "src/underworld3/model.py",
    "line": 4517,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Reset the default model to a fresh instance.\n\nUseful for testing or starting a new simulation in an interactive session.\nAll previously registered objects will be orphaned from the model registry.\n\nAlso resets global state including strict units mode to default (ON).\n\nReturns\n-------\nModel\n    New default model instance\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.reset_default_model()  # Start fresh",
    "harvested_comments": [
      "Start fresh",
      "Reset strict units mode to default (ON)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "to_petsc_options",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4586,
    "signature": "(self) -> Dict[str, str]",
    "parameters": [],
    "returns": "Dict[str, str]",
    "existing_docstring": "Convert configuration to PETSc options dictionary.\n\nReturns\n-------\ndict\n    PETSc options suitable for setting via Model.set_petsc_option()",
    "harvested_comments": [
      "Stokes solver options",
      "Advection-diffusion options"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ThermalConvectionConfig",
    "is_public": true
  },
  {
    "name": "to_materials_dict",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4621,
    "signature": "(self) -> Dict[str, Dict[str, Any]]",
    "parameters": [],
    "returns": "Dict[str, Dict[str, Any]]",
    "existing_docstring": "Convert configuration to materials dictionary format.\n\nReturns\n-------\ndict\n    Materials dictionary suitable for Model.materials",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ThermalConvectionConfig",
    "is_public": true
  },
  {
    "name": "create_model",
    "kind": "function",
    "file": "src/underworld3/model.py",
    "line": 4640,
    "signature": "(name: Optional[str] = None) -> Model",
    "parameters": [
      {
        "name": "name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Model",
    "existing_docstring": "Create a new Model instance",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_thermal_convection_model",
    "kind": "function",
    "file": "src/underworld3/model.py",
    "line": 4645,
    "signature": "(config: ThermalConvectionConfig, name: str = 'thermal_convection') -> Model",
    "parameters": [
      {
        "name": "config",
        "type_hint": "ThermalConvectionConfig",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "'thermal_convection'",
        "description": ""
      }
    ],
    "returns": "Model",
    "existing_docstring": "Create a Model instance configured for thermal convection.\n\nDemonstrates integration between specialized configs and Model infrastructure.\n\nParameters\n----------\nconfig : ThermalConvectionConfig\n    Configuration object with all simulation parameters\nname : str\n    Model name\n\nReturns\n-------\nModel\n    Configured model ready for thermal convection simulation",
    "harvested_comments": [
      "Set materials from config",
      "Set PETSc options from config",
      "Store config in metadata for reproducibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "barrier",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 50,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Creates an MPI barrier. All processes wait here for others to catch up.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "selective_ranks",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 160,
    "signature": "(ranks)",
    "parameters": [
      {
        "name": "ranks",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Execute code only on selected ranks, with collective operation detection.\n\nThis context manager allows you to selectively execute code on specific MPI ranks\nwhile protecting against deadlocks from collective operations.\n\nArgs:\n    ranks: Which ranks should execute the code block. Can be:\n        - int: Single rank (e.g., 0)\n        - slice: Range of ranks (e.g., slice(0, 4))\n        - list/tuple: Specific ranks (e.g., [0, 3, 7])\n        - str: Named patterns ('all', 'first', 'last', 'even', 'odd', '10%')\n        - callable: Function taking rank and returning bool\n        - numpy array: Boolean mask or integer indices\n\nRaises:\n    CollectiveOperationError: If a collective operation is detected within\n        the selective execution block (would cause deadlock)\n\nExample:\n    >>> with uw.mpi.selective_ranks(0):\n    ...     import matplotlib.pyplot as plt\n    ...     plt.plot(x, y)\n    ...     plt.savefig(\"output.png\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "collective_operation",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 215,
    "signature": "(func)",
    "parameters": [
      {
        "name": "func",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Decorator to mark a function as a collective operation.\n\nCollective operations must be called on ALL MPI ranks. If called inside\na selective_ranks() context where not all ranks execute, raises CollectiveOperationError.\n\nExample:\n    >>> @collective_operation\n    ... def compute_global_stats(self):\n    ...     # This requires all ranks to participate\n    ...     return self.vec.norm()",
    "harvested_comments": [
      "This requires all ranks to participate",
      "Check if all ranks are executing",
      "Not all ranks will execute - this is a collective operation error",
      "All ranks execute\\n\""
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "pprint",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 265,
    "signature": "(*args, **kwargs)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Parallel-safe print that works as a drop-in replacement for print().\n\nThis function ensures all ranks execute any collective operations in the arguments,\nbut only selected ranks actually print output. This prevents deadlocks from\ncollective operations inside rank conditionals.\n\nArgs:\n    *args: Arguments to print (same as standard print())\n    proc: Which ranks should print. Can be:\n        - int: Single rank (e.g., 0) [default: 0]\n        - slice: Range of ranks (e.g., slice(0, 4))\n        - list/tuple: Specific ranks (e.g., [0, 3, 7])\n        - str: Named patterns ('all', 'first', 'last', 'even', 'odd', '10%')\n        - callable: Function taking rank and returning bool\n        - numpy array: Boolean mask or integer indices\n    prefix: If True, prefix output with rank number. If None (default),\n        automatically enables in parallel (size > 1) and disables in serial.\n    clean_display: If True, filter out SymPy uniqueness strings for cleaner display (default: True)\n    flush: If True, forcibly flush the stream (default: False, same as print())\n    **kwargs: Additional keyword arguments passed to print() (sep, end, file)\n\nExample:\n    >>> uw.pprint(f\"Global max: {var.stats()['max']}\")  # Only rank 0 prints\n    Global max: 42.5\n\n    >>> # In parallel, automatic prefix\n    >>> uw.pprint(f\"Local max: {var.data.max()}\", proc=slice(0, 4))\n    [0] Local max: 12.3\n    [1] Local max: 15.7\n    [2] Local max: 9.8\n    [3] Local max: 11.2\n\n    >>> uw.pprint(f\"Expression: {expr}\")  # Automatically cleans symbols\n    Expression: T(x,y)",
    "harvested_comments": [
      "Only rank 0 prints",
      "In parallel, automatic prefix",
      "Automatically cleans symbols",
      "Auto-detect prefix: True in parallel, False in serial",
      "Clean up display strings by filtering out SymPy uniqueness patterns"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "pprint_old",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 341,
    "signature": "(ranks, *args, **kwargs)",
    "parameters": [
      {
        "name": "ranks",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Legacy pprint interface (deprecated). Use pprint() with proc= parameter instead.\n\nThis function maintains backward compatibility for existing code.",
    "harvested_comments": [
      "Convert to new interface"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 65,
    "signature": "(self, value: Any) -> bool",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Any",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Validate a parameter value against this definition.\n\nReturns:\n--------\nbool\n    True if value is valid, raises ValueError if not",
    "harvested_comments": [
      "Type validation",
      "Custom validation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterDefinition",
    "is_public": true
  },
  {
    "name": "define_parameter",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 148,
    "signature": "(self, name: str, ptype: ParameterType, default: Any = None, bounds: Optional[tuple] = None, choices: Optional[list] = None, description: str = '', units: str = '', validator: Optional[Callable] = None, dependencies: Optional[List[str]] = None) -> None",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "ptype",
        "type_hint": "ParameterType",
        "default": null,
        "description": ""
      },
      {
        "name": "default",
        "type_hint": "Any",
        "default": "None",
        "description": ""
      },
      {
        "name": "bounds",
        "type_hint": "Optional[tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "choices",
        "type_hint": "Optional[list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "description",
        "type_hint": "str",
        "default": "''",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "str",
        "default": "''",
        "description": ""
      },
      {
        "name": "validator",
        "type_hint": "Optional[Callable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "dependencies",
        "type_hint": "Optional[List[str]]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Define a new parameter with validation rules.\n\nParameters:\n-----------\nname : str\n    Parameter path (e.g., 'material.viscosity')\nptype : ParameterType\n    Parameter type for validation\ndefault : Any\n    Default value\nbounds : tuple, optional\n    (min, max) bounds for numerical parameters\nchoices : list, optional\n    Valid choices for enum parameters\ndescription : str\n    Human-readable description\nunits : str\n    Physical units\nvalidator : callable, optional\n    Custom validation function\ndependencies : list, optional\n    Parameters that depend on this one",
    "harvested_comments": [
      "Set default value if provided"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "set_parameter",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 202,
    "signature": "(self, name: str, value: Any, validate: bool = True) -> None",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "Any",
        "default": null,
        "description": ""
      },
      {
        "name": "validate",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Set a parameter value with validation and dependency updates.\n\nParameters:\n-----------\nname : str\n    Parameter path\nvalue : Any\n    New parameter value\nvalidate : bool\n    Whether to validate the value",
    "harvested_comments": [
      "Get definition for validation",
      "Validate value",
      "Store old value for history",
      "Set new value",
      "Record change in history"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "get_parameter",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 260,
    "signature": "(self, name: str, default = None) -> Any",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "default",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Get a parameter value by name",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "has_parameter",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 264,
    "signature": "(self, name: str) -> bool",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if a parameter is defined",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "list_parameters",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 268,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "List all parameter names and current values",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "get_definition",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 272,
    "signature": "(self, name: str) -> Optional[ParameterDefinition]",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Optional[ParameterDefinition]",
    "existing_docstring": "Get parameter definition by name",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "add_callback",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 276,
    "signature": "(self, name: str, callback: Callable) -> None",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "callback",
        "type_hint": "Callable",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Add a callback function to be called when parameter changes.\n\nParameters:\n-----------\nname : str\n    Parameter path\ncallback : callable\n    Function called as callback(param_name, new_value, old_value)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "export_config",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 291,
    "signature": "(self) -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "Export current parameter configuration",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "import_config",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 308,
    "signature": "(self, config: Dict[str, Any], validate: bool = True) -> None",
    "parameters": [
      {
        "name": "config",
        "type_hint": "Dict[str, Any]",
        "default": null,
        "description": ""
      },
      {
        "name": "validate",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Import parameter configuration from exported dict",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": true
  },
  {
    "name": "define_thermal_convection_parameters",
    "kind": "function",
    "file": "src/underworld3/parameters.py",
    "line": 322,
    "signature": "(registry: ParameterRegistry) -> None",
    "parameters": [
      {
        "name": "registry",
        "type_hint": "ParameterRegistry",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Define standard parameters for thermal convection models",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "define_stokes_flow_parameters",
    "kind": "function",
    "file": "src/underworld3/parameters.py",
    "line": 379,
    "signature": "(registry: ParameterRegistry) -> None",
    "parameters": [
      {
        "name": "registry",
        "type_hint": "ParameterRegistry",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Define standard parameters for Stokes flow models",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 360,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the units associated with this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 365,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the units for this variable.",
    "harvested_comments": [
      "Convert string units to Pint Unit objects for consistency"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 374,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "use_legacy_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 936,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deprecated: Array interface is now unified using NDArray_With_Callback",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "use_enhanced_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 940,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deprecated: Array interface is now unified using NDArray_With_Callback",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sync_disabled",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 944,
    "signature": "(self, description = 'batch operation')",
    "parameters": [
      {
        "name": "description",
        "type_hint": null,
        "default": "'batch operation'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager to disable automatic synchronization for batch operations.\nNow uses NDArray_With_Callback's delay_callback mechanism.\n\nParameters\n----------\ndescription : str\n    Description of the batch operation for debugging",
    "harvested_comments": [
      "Use NDArray_With_Callback's built-in delay mechanism"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1157,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced pack method that directly accesses PETSc field without access() context.\nDesigned for the new swarmVariable.array interface.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data to pack into PETSc field\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Direct PETSc field access without context manager",
      "Pack data using same layout as original method",
      "Increment variable state to track changes",
      "Update the proxy mesh variable if one exists (for integral calculations)",
      "Sync parallel operations if requested"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1220,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced unpack method that directly accesses PETSc field without access() context.\nDesigned for the new swarmVariable.array interface.\n\nParameters\n----------\nsqueeze : bool\n    Whether to squeeze singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Direct PETSc field access without context manager",
      "Sync parallel operations if requested",
      "TODO: Add parallel sync logic here if needed",
      "Unpack data using same layout as original method",
      "Always restore the field"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1261,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data array to PETSc using traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data in traditional flat format (-1, num_components)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Convert to expected shape: (-1, num_components)",
      "Direct PETSc field access without context manager",
      "Direct assignment in traditional flat format",
      "Increment variable state to track changes",
      "Update the proxy mesh variable if one exists (for integral calculations)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1306,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc in traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in traditional flat format (-1, num_components)",
    "harvested_comments": [
      "Check if swarm has any particles before accessing field",
      "Swarm not populated yet, return empty array",
      "Direct PETSc field access without context manager",
      "Field not properly initialized, restore and return empty array",
      "Return data in traditional flat format"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1380,
    "signature": "(self, new_coords, verbose = False, nnn = None)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Radial basis function interpolation of particle data to arbitrary points.\n\nUses inverse-distance weighting to interpolate particle values\nto new coordinate locations.\n\nParameters\n----------\nnew_coords : numpy.ndarray\n    Target coordinates of shape (N, dim) to interpolate to.\nverbose : bool, default=False\n    Print diagnostic information during interpolation.\nnnn : int, optional\n    Number of nearest neighbors to use. Defaults to ``mesh.dim + 1``.\n\nReturns\n-------\nnumpy.ndarray\n    Interpolated values at the target coordinates.",
    "harvested_comments": [
      "An inverse-distance mapping is quite robust here ... as long",
      "as we take care of the case where some nodes coincide (likely if used with mesh2mesh)",
      "We try to eliminate contributions from recently remeshed particles",
      "Get data directly from PETSc to avoid circular callback dependencies",
      "What to do if there are no particles"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "swarm",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1440,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The swarm this variable belongs to (accessed via weak reference).\nRaises RuntimeError if the swarm has been garbage collected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1457,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "TESTING: Original data property implementation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1464,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Canonical data storage with PETSc synchronization.\nShape: (-1, num_components) - flat format for backward compatibility.\n\nThis is the ONLY property that handles PETSc synchronization to avoid conflicts.\nThe .array property uses this as its underlying storage with format conversion.\n\nReturns\n-------\nNDArray_With_Callback\n    Array with shape (-1, num_components) with automatic PETSc synchronization",
    "harvested_comments": [
      "Cache and reuse canonical data object to avoid field access conflicts",
      "Use direct __dict__ check to avoid MathematicalMixin recursion",
      "Create the single canonical data array with PETSc sync"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1486,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view of canonical data with automatic format conversion.\nShape: (N, a, b) for tensor shape (a, b).\n\nThis property is ALWAYS a view of the canonical .data property.\nNo direct PETSc access - all changes delegate back to canonical storage.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1497,
    "signature": "(self, array_value)",
    "parameters": [
      {
        "name": "array_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set variable data through canonical data property with format conversion.",
    "harvested_comments": [
      "Simple case: reshape array format (N,a,b) to canonical format (N,components)",
      "Complex case: use pack operations for tensor layout conversion",
      "Assign to canonical data property (triggers PETSc sync)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1512,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic representation for use in equations.\n\nReturns the symbolic expression from the proxy mesh variable,\nwhich can be used in SymPy expressions for constitutive models,\nboundary conditions, etc.\n\nReturns\n-------\nsympy.Matrix\n    Symbolic matrix expression.\n\nNotes\n-----\nThe proxy is automatically updated if particle data has changed.",
    "harvested_comments": [
      "Ensure proxy is up to date before returning symbolic representation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1533,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flattened symbolic representation.\n\nReturns the symbolic expression as a 1D (column) vector form,\nuseful for Voigt notation in tensor calculations.\n\nReturns\n-------\nsympy.Matrix\n    Flattened symbolic expression.",
    "harvested_comments": [
      "Ensure proxy is up to date before returning symbolic representation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_max",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1554,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Maximum value across all MPI ranks.\n\nFinds the maximum value of the particle property across all processors.\nUseful for finding extreme values in particle swarm data.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Maximum value with units preserved (if variable has units).\n\nExamples\n--------\n>>> max_temp = temperature_swarm.global_max()\n>>> print(f\"Maximum temperature: {max_temp}\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [
      "Wrap data in UnitAwareArray to use its global_max implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_min",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1592,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Minimum value across all MPI ranks.\n\nFinds the minimum value of the particle property across all processors.\nUseful for finding extreme values in particle swarm data.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Minimum value with units preserved (if variable has units).\n\nExamples\n--------\n>>> min_pressure = pressure_swarm.global_min()\n>>> print(f\"Minimum pressure: {min_pressure}\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_sum",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1629,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Sum of values across all MPI ranks.\n\nComputes the sum of particle property values across all processors.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Sum with units preserved (if variable has units).\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.\n\nWarning: This sum is NOT a physical domain-integrated quantity because\nparticles are non-uniformly distributed. For domain integration, use\nthe proxy mesh variable with uw.maths.Integral().",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_norm",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1664,
    "signature": "(self, ord = None)",
    "parameters": [
      {
        "name": "ord",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "L2 norm (Frobenius norm) across all MPI ranks.\n\nComputes the L2 norm of particle property values: sqrt(sum(x**2))\nacross all processors.\n\nParameters\n----------\nord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional\n    Order of the norm (default: None = 2-norm)\n\nReturns\n-------\nUWQuantity or scalar\n    L2 norm with units preserved (if variable has units).\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.\n\nFor vectors, computes the Frobenius norm treating the array as flattened.\n\nWarning: This norm is NOT a physical domain-integrated quantity because\nparticles are non-uniformly distributed.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_size",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1697,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total particle count across all MPI ranks.\n\nReturns the total number of particles across all processors.\nUseful for population monitoring and load balancing diagnostics.\n\nReturns\n-------\nint\n    Total number of particles across all ranks.\n\nExamples\n--------\n>>> total_particles = swarm_var.global_size()\n>>> local_particles = swarm_var.data.shape[0]\n>>> print(f\"Rank has {local_particles} of {total_particles} particles\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1726,
    "signature": "(self, filename: int, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save the swarm variable to a h5 file.\n\nParameters\n----------\nfilename :\n    The filename of the swarm variable to save to disk.\ncompression :\n    Add compression to the h5 files (saves space but increases write times with increasing no. of processors)\ncompressionType :\n    Type of compression to use, 'gzip' and 'lzf' supported. 'gzip' is default. Compression also needs to be set to 'True'.\n\nforce_sequential : activate the serial version of hdf5",
    "harvested_comments": [
      "# Add swarm variable unit metadata to the file",
      "Use preferred selective_ranks pattern for unit metadata",
      "Add swarm variable unit metadata",
      "Store in dataset attributes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2029,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Lazy evaluation of symbolic mask array.\n\nOnly updates proxy variables when they're actually needed (when sym is accessed)\nand only if the proxy variables are marked as stale due to data changes.\nThis avoids expensive RBF interpolation during data assignment operations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "createMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2051,
    "signature": "(self, funcsList)",
    "parameters": [
      {
        "name": "funcsList",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This creates a masked sympy function of swarm variables required for Underworld's solvers",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "viewMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2068,
    "signature": "(self, sympy)",
    "parameters": [
      {
        "name": "sympy",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Takes a previously masked sympy function and returns individual sympy objects corresponding to each material",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2088,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Show information on IndexSwarmVariable",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2425,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this swarm operates on",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2433,
    "signature": "(self, new_mesh)",
    "parameters": [
      {
        "name": "new_mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Assign swarm to a new mesh with dimensional validation and proxy updates.\n\nParameters\n----------\nnew_mesh : uw.discretisation.Mesh\n    New mesh to assign this swarm to\n\nRaises\n------\nValueError\n    If new mesh has incompatible dimensions",
    "harvested_comments": [
      "Register new mesh with model",
      "Check if swarm is already compatible with target mesh",
      "Dimensions match, check if proxy variables need updating",
      "No change needed",
      "Use swarm's current dimensions for validation (not model.mesh which may have been auto-updated)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "local_size",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2508,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Number of particles on this MPI rank.\n\nReturns\n-------\nint\n    Local particle count.\n\nSee Also\n--------\ndm.getLocalSize : Underlying PETSc method.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2525,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Particle coordinates (alias for :attr:`points`).\n\n.. deprecated:: 0.99.0\n    Use direct DM field access for particle coordinates.\n\nReturns\n-------\nnumpy.ndarray\n    Particle coordinate array of shape ``(n_particles, dim)``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2539,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm particle coordinates in physical units.\n\n.. deprecated:: 0.99.0\n    Use swarm variables or direct DM access instead.\n    ``swarm.points`` is being deprecated.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from internal model coordinates\nto physical coordinates for user access.\n\nWhen the mesh has coordinate units specified, returns a unit-aware array.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Particle coordinates (with units if mesh.units is set)",
    "harvested_comments": [
      "Check for mesh coordinate changes and trigger migration if needed",
      "Mesh coordinates have changed, force migration to update swarm",
      "Update our mesh version to match",
      "Get current coordinate data from PETSc (these are in model coordinates)",
      "Apply scaling to convert model coordinates to physical coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2650,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set swarm particle coordinates from physical units.\n\n.. deprecated:: 0.99.0\n    Use swarm variables or direct DM access instead.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from physical coordinates\nto internal model coordinates for PETSc storage.\n\nArgs:\n    value (numpy.ndarray): Particle coordinates in physical units",
    "harvested_comments": [
      "Apply inverse scaling to convert physical coordinates to model coordinates",
      "Update the cached NDArray (triggers callback) - use physical coordinates for cache",
      "Update PETSc DM field directly with model coordinates for immediate consistency"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2709,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm particle coordinates in physical units.\n\nThis is the primary public interface for accessing particle coordinates.\nCoordinates are automatically converted from internal model units to\nphysical units based on the model's reference quantities.\n\nReturns\n-------\nUWQuantity or numpy.ndarray\n    Particle coordinates in physical units with shape (n_particles, dim).\n    If model has reference quantities, returns UWQuantity with appropriate\n    length units. Otherwise returns plain array.\n\nNotes\n-----\n- Coordinates are converted from model units to physical units automatically\n- For internal use with model units, access `swarm._particle_coordinates.data`\n- Setting coordinates accepts either physical units or plain numbers\n\nExamples\n--------\n>>> coords_physical = swarm.coords  # Get physical coordinates\n>>> swarm.coords = new_coords_with_units  # Set from physical units\n\nSee Also\n--------\nswarm.units : Get the unit specification for coordinates",
    "harvested_comments": [
      "Get physical coordinates",
      "Set from physical units",
      "Get internal model-unit coordinates",
      "Convert to physical units",
      "Use from_model_magnitude to convert back to physical"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2751,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set swarm particle coordinates from physical units.\n\nAccepts coordinates with units or plain numbers. If units are provided,\nthey are converted to model units automatically. If plain numbers are\nprovided, they are assumed to be in the correct unit system.\n\nParameters\n----------\nvalue : array-like or UWQuantity\n    New coordinates. Can be:\n    - Array with units (e.g., values * uw.units.km)\n    - Plain array (assumed to be in model units or physical units depending on context)",
    "harvested_comments": [
      "Convert physical \u2192 non-dimensional units",
      "Set internal coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2775,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unit specification for swarm coordinates.\n\nReturns the physical unit string for coordinates based on the model's\nreference quantities. This indicates what units the coordinates are in\nwhen accessed via the `coords` property.\n\nReturns\n-------\nstr or None\n    Unit string for coordinates (e.g., 'kilometer', 'meter'), or None\n    if no reference quantities are set\n\nExamples\n--------\n>>> print(swarm.units)  # 'kilometer' if length_scale was set in km\n>>> coords = swarm.coords  # Coordinates in kilometers",
    "harvested_comments": [
      "'kilometer' if length_scale was set in km",
      "Coordinates in kilometers",
      "Coordinates have length dimensions",
      "Check if model has reference quantities",
      "Get length scale from model"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "dont_clip_to_mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2825,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Context manager that temporarily disables mesh clipping for the swarm.\n`swarm.migrate` is called automatically when exiting the context.\n\nUsage:\n    with swarm.dont_clip_to_mesh():\n        # swarm operations that should not be clipped to mesh\n        swarm.data = new_positions",
    "harvested_comments": [
      "swarm operations that should not be clipped to mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migration_disabled",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2853,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Legacy context manager that completely disables migration.\nUse migration_control(disable=True) for new code.\n\nContext manager that temporarily disables particle migration for the swarm.\nMigration is NOT called when exiting the context.\n\nUsage:\n    with swarm.migration_disabled():\n        # swarm operations that should not trigger migration\n        swarm.data = new_positions\n        # ... other operations ...\n        # migrate() will be skipped during these operations",
    "harvested_comments": [
      "swarm operations that should not trigger migration",
      "... other operations ...",
      "migrate() will be skipped during these operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migration_control",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2871,
    "signature": "(self, disable = False)",
    "parameters": [
      {
        "name": "disable",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager to control particle migration behavior.\n\nParameters\n----------\ndisable : bool\n    If False (default), migration is deferred until context exit.\n    If True, migration is completely disabled.\n\nUsage:\n    # Defer migration until end (default)\n    with swarm.migration_control():\n        swarm.points[mask1] += delta1\n        swarm.points[mask2] *= scale\n        # Migration happens HERE on exit\n\n    # Completely disable migration\n    with swarm.migration_control(disable=True):\n        # Operations where migration should never happen\n        # No migration on exit",
    "harvested_comments": [
      "Defer migration until end (default)",
      "Migration happens HERE on exit",
      "Completely disable migration",
      "Operations where migration should never happen",
      "No migration on exit"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "populate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2923,
    "signature": "(self, fill_param: Optional[int] = 1)",
    "parameters": [
      {
        "name": "fill_param",
        "type_hint": "Optional[int]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Populate the swarm with particles throughout the domain.\n\nParameters\n----------\nfill_param:\n    Parameter determining the particle count per cell (per dimension)\n    for the given layout, using the mesh degree.\n\nRaises\n------\nRuntimeError\n    If the swarm has already been initialized with particles.",
    "harvested_comments": [
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count",
      "This is a mesh-local quantity, so let's just",
      "store it on the mesh in an ad_hoc fashion for now"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migrate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3022,
    "signature": "(self, remove_sent_points = True, delete_lost_points = None, max_its = 10)",
    "parameters": [
      {
        "name": "remove_sent_points",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "delete_lost_points",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "max_its",
        "type_hint": null,
        "default": "10",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Migrate swarm across processes after coordinates have been updated.\n\nThe algorithm uses a global kD-tree for the centroids of the domains to decide the particle mpi.rank (send to the closest)\nIf the particles are mis-assigned to a particular mpi.rank, the next choice is the second-closest and so on.\n\nA few particles are still not found after this distribution process which probably means they are just outside the mesh.\nIf some points remain lost, they will be deleted if `delete_lost_points` is set.\n\nImplementation note:\n    We retained (above) the name `DMSwarmPIC_coor` for the particle field to allow this routine to be inherited by a PIC swarm\n    which has this field pre-defined. (We'd need to add a cellid field as well, and re-compute it upon landing)\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "This will only worry about particles that are not already claimed !",
      "Unlikely, but we should check this",
      "Migrate particles between processes (if there are more than one of them)",
      "Send unclaimed points to next processor in line",
      "Now we send the points (basic migration)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_particles_with_coordinates",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3194,
    "signature": "(self, coordinatesArray) -> int",
    "parameters": [
      {
        "name": "coordinatesArray",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Add particles to the swarm using particle coordinates provided\nusing a numpy array.\n\nNote that particles with coordinates NOT local to the current processor will\nbe rejected / ignored.\n\nEither include an array with all coordinates to all processors\nor an array with the local coordinates.\n\nParameters\n----------\ncoordinatesArray : numpy.ndarray\n    The numpy array containing the coordinate of the new particles. Array is\n    expected to take shape n*dim, where n is the number of new particles, and\n    dim is the dimensionality of the swarm's supporting mesh.\n\nReturns\n--------\nnpoints: int\n    The number of points added to the local section of the swarm.",
    "harvested_comments": [
      "### petsc appears to ignore columns that are greater than the mesh dim, but still worth including",
      "-1 means no particles have been added yet (PETSc interface change)",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_particles_with_global_coordinates",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3269,
    "signature": "(self, globalCoordinatesArray, migrate = True, delete_lost_points = True) -> int",
    "parameters": [
      {
        "name": "globalCoordinatesArray",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "migrate",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "delete_lost_points",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Add particles to the swarm using particle coordinates provided\nusing a numpy array.\n\nglobal coordinates: particles will be appropriately migrated\n\nParameters\n----------\nglobalCoordinatesArray : numpy.ndarray\n    The numpy array containing the coordinate of the new particles. Array is\n    expected to take shape n*dim, where n is the number of new particles, and\n    dim is the dimensionality of the swarm's supporting mesh.\n\nReturns\n--------\nnpoints: int\n    The number of points added to the local section of the swarm.",
    "harvested_comments": [
      "### petsc appears to ignore columns that are greater than the mesh dim, but still worth including",
      "-1 means no particles have been added yet",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3347,
    "signature": "(self, filename: int, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save the swarm coordinates to a h5 file.\n\nParameters\n----------\nfilename :\n    The filename of the swarm checkpoint file to save to disk.\ncompression :\n    Add compression to the h5 files (saves space but increases write times with increasing no. of processors)\ncompressionType :\n    Type of compression to use, 'gzip' and 'lzf' supported. 'gzip' is default. Compression also needs to be set to 'True'.",
    "harvested_comments": [
      "It seems to be a bad idea to mix mpi barriers with the access",
      "context manager so the copy-free version of this seems to hang",
      "when there are many active cores. This is probably why the parallel",
      "h5py write hangs",
      "It seems to be a bad idea to mix mpi barriers with the access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3498,
    "signature": "(self, name, size = 1, dtype = float, proxy_degree = 2, _nn_proxy = False, units = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "dtype",
        "type_hint": null,
        "default": "float",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "_nn_proxy",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add a variable to the swarm.\n\nVariables must be created before the swarm is populated with particles.\nOnce swarm.populate() or similar methods are called, PETSc finalizes\nfield registration and no new variables can be added.\n\nParameters\n----------\nname : str\n    Variable name\nsize : int, default 1\n    Number of components (1 for scalar, 2-3 for vector, etc.)\ndtype : type, default float\n    Data type (float or int)\nproxy_degree : int, default 2\n    Degree for mesh proxy variable interpolation\n_nn_proxy : bool, default False\n    Internal parameter for nearest-neighbor proxy\nunits : str, optional\n    Physical units for this variable (e.g., \"kg/m^3\", \"m/s\")\n\nReturns\n-------\nSwarmVariable\n    The created swarm variable\n\nRaises\n------\nRuntimeError\n    If swarm is already populated with particles\n\nExamples\n--------\nCorrect usage:\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> material = swarm.add_variable(\"material\", 1, dtype=int)\n>>> temperature = swarm.add_variable(\"temperature\", 1)\n>>> swarm.populate(fill_param=3)  # Populate after creating variables\n\nIncorrect usage (will raise error):\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> swarm.populate(fill_param=3)\n>>> material = swarm.add_variable(\"material\", 1)  # ERROR!",
    "harvested_comments": [
      "Populate after creating variables",
      "Check early to provide a clear error message",
      "Create variables first\\n\"",
      "Then populate with particles\""
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3575,
    "signature": "(self, swarmName: str, index: int, outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "swarmName",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the swarm and attached data to a .pbin and xdmf file.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3599,
    "signature": "(self, filename: str, swarmname: str, index: int, swarmVars: Optional[list] = None, outputPath: Optional[str] = '', time: Optional[int] = None, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmname",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "time",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save data to h5 and a corresponding xdmf for visualisation using h5py.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nswarmVars :\n    List of swarm objects to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.\ntime :\n    Attach the time to the generated xdmf.\ncompression :\n    Whether to compress the h5 files [bool].\ncompressionType :\n    The type of compression to use. 'gzip' and 'lzf' are the supported types, with 'gzip' as the default.",
    "harvested_comments": [
      "This will eliminate the issue of whether or not to put path separators in the",
      "outputPath. Also does the right thing if outputPath is \"\"",
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 3749,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "List of SwarmVariables attached to this swarm.\n\nReturns\n-------\nlist\n    List of :class:`SwarmVariable` objects defined on this swarm.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3900,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "SwarmVariable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Dummy access manager that provides deferred sync for backward compatibility.\nUses NDArray_With_Callback.delay_callbacks_global() internally.\n\nThis is a compatibility wrapper that allows existing code using the access()\ncontext manager to work with the new direct-access variable interfaces.\nAll variable modifications are deferred and synchronized at context exit.\n\nParameters\n----------\nwriteable_vars\n    Variables that will be modified (ignored - all variables are writable\n    with the new interface, this parameter is kept for API compatibility)\n\nReturns\n-------\nContext manager that defers variable synchronization until exit\n\nNotes\n-----\nThis method is deprecated. New code should access variable.data or\nvariable.array directly without requiring an access context.",
    "harvested_comments": [
      "Use NDArray_With_Callback global delay context for deferred sync",
      "This triggers all accumulated callbacks from all variables"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4249,
    "signature": "(self, V_fn)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the given\nmesh and velocity configuration.",
    "harvested_comments": [
      "we'll want to do this on an element by element basis",
      "for more general mesh",
      "first let's extract a max global velocity magnitude",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 232,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh associated with this swarm.\n\nReturns\n-------\nMesh\n    The computational mesh containing the particles.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 243,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Particle coordinate data array.\n\nProvides direct read/write access to particle positions.\n\nReturns\n-------\nnumpy.ndarray\n    Coordinate array of shape ``(n_particles, dim)``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "particle_coordinates",
    "kind": "property",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 256,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SwarmVariable holding particle coordinates.\n\nReturns\n-------\nSwarmVariable\n    The internal coordinate variable (use ``.data`` for array access).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "particle_cellid",
    "kind": "property",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 267,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SwarmVariable holding particle cell IDs.\n\nEach particle is associated with a mesh cell for efficient\nspatial operations.\n\nReturns\n-------\nSwarmVariable\n    Cell ID variable (use ``.data`` for array access).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "populate_petsc",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 281,
    "signature": "(self, fill_param: Optional[int] = 3, layout: Optional[SwarmPICLayout] = None)",
    "parameters": [
      {
        "name": "fill_param",
        "type_hint": "Optional[int]",
        "default": "3",
        "description": ""
      },
      {
        "name": "layout",
        "type_hint": "Optional[SwarmPICLayout]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Populate the swarm with particles throughout the domain.\n\nWhen using SwarmPICLayout.REGULAR,     `fill_param` defines the number of points in each spatial direction.\nWhen using SwarmPICLayout.GAUSS,       `fill_param` defines the number of quadrature points in each spatial direction.\nWhen using SwarmPICLayout.SUBDIVISION, `fill_param` defines the number times the reference cell is sub-divided.\n\nParameters\n----------\nfill_param:\n    Parameter determining the particle count per cell for the given layout.\nlayout:\n    Type of layout to use. Defaults to `SwarmPICLayout.REGULAR` for mesh objects with simplex\n    type cells, and `SwarmPICLayout.GAUSS` otherwise.",
    "harvested_comments": [
      "# Commenting this out for now.",
      "# Code seems to operate fine without it, and the",
      "# existing values are wrong. It should be something like",
      "# `(elend-elstart)*fill_param^dim` for quads, and around",
      "# half that for simplices, depending on layout."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "populate",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 340,
    "signature": "(self, fill_param: Optional[int] = 1)",
    "parameters": [
      {
        "name": "fill_param",
        "type_hint": "Optional[int]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Populate the swarm with particles throughout the domain.\n\nParameters\n----------\nfill_param:\n    Parameter determining the particle count per cell (per dimension)\n    for the given layout, using the mesh degree.\n\ncell_search:\n    Use k-d tree to locate nearest cells (fails if this swarm is used to build a k-d tree)",
    "harvested_comments": [
      "valid = newp_cells0 != -1",
      "newp_coords = newp_coords0[valid]",
      "newp_cells = newp_cells0[valid]",
      "# Now make a series of copies to allow the swarm cycling to",
      "# work correctly (if required)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "add_particles_with_coordinates",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 436,
    "signature": "(self, coordinatesArray) -> int",
    "parameters": [
      {
        "name": "coordinatesArray",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Add particles to the swarm using particle coordinates provided\nusing a numpy array.\n\nNote that particles with coordinates NOT local to the current processor will\nbe rejected / ignored.\n\nEither include an array with all coordinates to all processors\nor an array with the local coordinates.\n\nParameters\n----------\ncoordinatesArray : numpy.ndarray\n    The numpy array containing the coordinate of the new particles. Array is\n    expected to take shape n*dim, where n is the number of new particles, and\n    dim is the dimensionality of the swarm's supporting mesh.\n\nReturns\n--------\nnpoints: int\n    The number of points added to the local section of the swarm.",
    "harvested_comments": [
      "### petsc appears to ignore columns that are greater than the mesh dim, but still worth including",
      "-1 means no particles have been added yet",
      "Here we update the swarm cycle values as required",
      "self._Xorig.data[...] = coordinatesArray"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 511,
    "signature": "(self, filename: int, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save the swarm coordinates to a h5 file.\n\nParameters\n----------\nfilename :\n    The filename of the swarm checkpoint file to save to disk.\ncompression :\n    Add compression to the h5 files (saves space but increases write times with increasing no. of processors)\ncompressionType :\n    Type of compression to use, 'gzip' and 'lzf' supported. 'gzip' is default. Compression also needs to be set to 'True'.",
    "harvested_comments": [
      "It seems to be a bad idea to mix mpi barriers with the access",
      "context manager so the copy-free version of this seems to hang",
      "when there are many active cores. This is probably why the parallel",
      "h5py write hangs",
      "It seems to be a bad idea to mix mpi barriers with the access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 610,
    "signature": "(self, base_filename: str, swarm_id: str, index: int, outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "base_filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarm_id",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Load particle coordinates from a saved timestep file.\n\nReads an HDF5 file containing particle coordinates and adds\nthem to the swarm using :meth:`add_particles_with_coordinates`.\n\nParameters\n----------\nbase_filename : str\n    Base name for the output files.\nswarm_id : str\n    Identifier for this swarm in the output.\nindex : int\n    Timestep index to read.\noutputPath : str, optional\n    Directory containing the output files.",
    "harvested_comments": [
      "## open up file with coords on all procs",
      "### utilises the UW function for adding a swarm by an array"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "add_variable",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 646,
    "signature": "(self, name, size = 1, dtype = float, proxy_degree = 2, _nn_proxy = False)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "dtype",
        "type_hint": null,
        "default": "float",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "_nn_proxy",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a new SwarmVariable attached to this swarm.\n\nParameters\n----------\nname : str\n    Name for the variable.\nsize : int, optional\n    Number of components per particle (default: 1 for scalar).\ndtype : type, optional\n    Data type for the variable (default: float).\nproxy_degree : int, optional\n    Polynomial degree for mesh proxy variable (default: 2).\n_nn_proxy : bool, optional\n    Use nearest-neighbor proxy (internal use).\n\nReturns\n-------\nSwarmVariable\n    New variable attached to this swarm.\n\nExamples\n--------\n>>> material = swarm.add_variable(\"material\", size=1, dtype=int)\n>>> temperature = swarm.add_variable(\"T\", size=1)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 689,
    "signature": "(self, swarmName: str, index: int, outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "swarmName",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the swarm and attached data to a .pbin and xdmf file.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 713,
    "signature": "(self, filename: str, swarmname: str, index: int, swarmVars: Optional[list] = None, outputPath: Optional[str] = '', time: Optional[int] = None, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmname",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "time",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save data to h5 and a corresponding xdmf for visualisation using h5py.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nswarmVars :\n    List of swarm objects to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.\ntime :\n    Attach the time to the generated xdmf.\ncompression :\n    Whether to compress the h5 files [bool].\ncompressionType :\n    The type of compression to use. 'gzip' and 'lzf' are the supported types, with 'gzip' as the default.",
    "harvested_comments": [
      "This will eliminate the issue of whether or not to put path separators in the",
      "outputPath. Also does the right thing if outputPath is \"\"",
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 863,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Dictionary of SwarmVariables attached to this swarm.\n\nReturns\n-------\ndict\n    Mapping from variable names to :class:`SwarmVariable` objects.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 873,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "SwarmVariable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying swarm variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nAt the conclusion of the users context managed block, numerous further operations\nwill be automatically executed. This includes swarm parallel migration routines\nwhere the swarm's `particle_coordinates` variable has been modified. The swarm\nvariable proxy mesh variables will also be updated for modifed swarm variables.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "grab numpy object, setting read only if necessary",
      "increment variable state"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1069,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = True)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Advect particles using a velocity field.\n\nMoves particles according to the velocity field using forward\nEuler integration with automatic substepping based on CFL\nconditions. Handles particle migration between MPI ranks.\n\nParameters\n----------\nV_fn : sympy.Matrix or MeshVariable\n    Velocity field (vector expression).\ndelta_t : float\n    Total time to advect.\norder : int, optional\n    Integration order (default: 2, not currently used).\ncorrector : bool, optional\n    Apply predictor-corrector scheme (default: False).\nrestore_points_to_domain_func : callable, optional\n    Function to restore particles that leave the domain.\nevalf : bool, optional\n    Use numerical evaluation (True) or symbolic (False).\nstep_limit : bool, optional\n    Apply CFL-based substepping limit (default: True).",
    "harvested_comments": [
      "X0 holds the particle location at the start of advection",
      "This is needed because the particles may be migrated off-proc",
      "during timestepping.",
      "Use current velocity to estimate where the particles would have",
      "landed in an implicit step. WE CANT DO THIS WITH SUB-STEPPING unless"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1334,
    "signature": "(self, V_fn)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the given\nmesh and velocity configuration.",
    "harvested_comments": [
      "we'll want to do this on an element by element basis",
      "for more general mesh",
      "first let's extract a max global velocity magnitude",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1476,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = True)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Advect nodal point particles and track back to mesh nodes.\n\nExtends parent advection with node-tracking logic. After\nadvection, particles are mapped back to their original mesh\nnodes for semi-Lagrangian interpolation.\n\nParameters\n----------\nV_fn : sympy.Matrix or MeshVariable\n    Velocity field (vector expression).\ndelta_t : float\n    Total time to advect.\norder : int, optional\n    Integration order (default: 2).\ncorrector : bool, optional\n    Apply predictor-corrector scheme (default: False).\nrestore_points_to_domain_func : callable, optional\n    Function to restore particles that leave the domain.\nevalf : bool, optional\n    Use numerical evaluation (True) or symbolic (False).\nstep_limit : bool, optional\n    Apply CFL-based substepping limit (default: True).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "NodalPointPICSwarm",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "property",
    "file": "src/underworld3/systems/ddt.py",
    "line": 104,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Current symbolic expression :math:`\\psi` being tracked.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 109,
    "signature": "(self, new_fn)",
    "parameters": [
      {
        "name": "new_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the tracked symbolic expression.",
    "harvested_comments": [
      "Optionally, one could check for matching shape; here we update both."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "update_history_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 130,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Copy current :math:`\\psi` to the first history slot ``psi_star[0]``.",
    "harvested_comments": [
      "Update the first history element with a copy of the current \u03c8."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "initiate_history_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 135,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Initialize all history slots to the current value of :math:`\\psi`.",
    "harvested_comments": [
      "Propagate the initial history to all history steps."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "update",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 143,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update history (alias for ``update_pre_solve``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "update_pre_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 152,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pre-solve update hook (no-op for Symbolic).",
    "harvested_comments": [
      "Default: no action."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "update_post_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 161,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Shift history chain after solve: :math:`\\psi^{*n} \\leftarrow \\psi^{*(n-1)}`.",
    "harvested_comments": [
      "Shift history: copy each element down the chain."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "bdf",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 176,
    "signature": "(self, order: Optional[int] = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute the backward differentiation approximation of the time-derivative of \u03c8.\nFor order 1: bdf \u2261 \u03c8 - psi_star[0]",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "adams_moulton_flux",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 199,
    "signature": "(self, order: Optional[int] = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adams-Moulton flux approximation for implicit time integration.\n\nParameters\n----------\norder : int, optional\n    Order of the approximation (1-3). Defaults to ``self.order``.\n\nReturns\n-------\nsympy.Matrix\n    Weighted average of :math:`\\psi` and history terms.\n\nNotes\n-----\nThe Adams-Moulton formulas for order 1-3 are:\n\n- Order 1: :math:`\\theta \\psi + (1-\\theta) \\psi^*`\n- Order 2: :math:`\\frac{5\\psi + 8\\psi^* - \\psi^{**}}{12}`\n- Order 3: :math:`\\frac{9\\psi + 19\\psi^* - 5\\psi^{**} + \\psi^{***}}{24}`",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "Symbolic",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "property",
    "file": "src/underworld3/systems/ddt.py",
    "line": 324,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Current symbolic expression :math:`\\psi` being tracked.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 329,
    "signature": "(self, new_fn)",
    "parameters": [
      {
        "name": "new_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the tracked expression.",
    "harvested_comments": [
      "self._psi_star_projection_solver.uw_function = self.psi_fn"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "update_history_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 379,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Copy current :math:`\\psi` to ``psi_star[0]`` via evaluation or projection.",
    "harvested_comments": [
      "## update first value in history chain",
      "## avoids projecting if function can be evaluated",
      "print('copying data', flush=True)",
      "if self.evalf:",
      "self.psi_star[0].data[...] = uw.function.evalf("
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "initiate_history_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 408,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Initialize all history slots to the current value of :math:`\\psi`.",
    "harvested_comments": [
      "## set up all history terms to the initial values"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "update",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 419,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update history (alias for ``update_pre_solve``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "update_pre_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 428,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pre-solve update hook (no-op for Eulerian).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "update_post_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 436,
    "signature": "(self, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Shift history chain after solve: :math:`\\psi^{*n} \\leftarrow \\psi^{*(n-1)}`.",
    "harvested_comments": [
      "if average_over_dt:",
      "phi = min(1.0, dt / self.dt_physical)",
      "## copy values down the chain",
      "## update the history fn",
      "### update the first value in the chain"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "bdf",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 474,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Backwards differentiation form for calculating DuDt\nNote that you will need ``bdf`` / :math:`\\delta t` in computing derivatives",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "adams_moulton_flux",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 500,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adams-Moulton flux approximation for implicit time integration.\n\nParameters\n----------\norder : int, optional\n    Order of the approximation (1-3). Defaults to ``self.order``.\n\nReturns\n-------\nsympy.Basic\n    Weighted average of :math:`\\psi` and history terms.",
    "harvested_comments": [
      "am = self.theta*self.psi_fn + ((1.-self.theta)*self.psi_star[0].sym)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Eulerian",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "property",
    "file": "src/underworld3/systems/ddt.py",
    "line": 690,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Current symbolic expression :math:`\\psi` being tracked.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "psi_fn",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 695,
    "signature": "(self, new_fn)",
    "parameters": [
      {
        "name": "new_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the tracked expression.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "update",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 708,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional = None)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "dt_physical",
        "type_hint": "Optional",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update history (alias for ``update_pre_solve``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "update_post_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 719,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional[float] = None)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "dt_physical",
        "type_hint": "Optional[float]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Post-solve update hook (no-op for SemiLagrangian).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "update_pre_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 729,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False, dt_physical: Optional[float] = None)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "dt_physical",
        "type_hint": "Optional[float]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Sample upstream values along characteristics before solve.",
    "harvested_comments": [
      "# Progress from the oldest part of the history",
      "1. Copy the stored values down the chain in preparation for the next timestep",
      "The history term is the nodel value of psi_fn offset back along the characteristics",
      "according to the timestep.",
      "- psi_star[0] is the current value of psi_fn, sampled"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "bdf",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1074,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Backwards differentiation form for calculating DuDt\nNote that you will need ``bdf`` / :math:`\\delta t` in computing derivatives",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "adams_moulton_flux",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1100,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adams-Moulton flux approximation for implicit time integration.\n\nParameters\n----------\norder : int, optional\n    Order of the approximation (0-3). Defaults to ``self.order``.\n\nReturns\n-------\nsympy.Basic\n    Weighted average of :math:`\\psi` and history terms.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SemiLagrangian",
    "is_public": true
  },
  {
    "name": "update",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1236,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update history (alias for ``update_post_solve``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": true
  },
  {
    "name": "update_pre_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1246,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pre-solve update hook (no-op for Lagrangian).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": true
  },
  {
    "name": "update_post_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1255,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Shift history chain and advect swarm after solve.",
    "harvested_comments": [
      "copy the information down the chain",
      "Now update the swarm variable",
      "Now update the swarm locations"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": true
  },
  {
    "name": "bdf",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1292,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Backwards differentiation form for calculating DuDt\nNote that you will need ``bdf`` / :math:`\\delta t` in computing derivatives",
    "harvested_comments": [
      "special case - no history term (catch )"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": true
  },
  {
    "name": "adams_moulton_flux",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1319,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adams-Moulton flux approximation for implicit time integration.\n\nParameters\n----------\norder : int, optional\n    Order of the approximation (0-3). Defaults to ``self.order``.\n\nReturns\n-------\nsympy.Basic\n    Weighted average of :math:`\\psi` and history terms.",
    "harvested_comments": [
      "Special case - no history term"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Lagrangian",
    "is_public": true
  },
  {
    "name": "update",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1440,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Update history (alias for ``update_post_solve``).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": true
  },
  {
    "name": "update_pre_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1450,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pre-solve update hook (no-op for Lagrangian_Swarm).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": true
  },
  {
    "name": "update_post_solve",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1459,
    "signature": "(self, dt: float, evalf: Optional[bool] = False, verbose: Optional[bool] = False)",
    "parameters": [
      {
        "name": "dt",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Shift history chain and evaluate current :math:`\\psi` on swarm.",
    "harvested_comments": [
      "copy the information down the chain",
      "Now update the swarm variable",
      "psi_star_0 = self.psi_star[0]",
      "with self.swarm.access(psi_star_0):",
      "for i in range(psi_star_0.shape[0]):"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": true
  },
  {
    "name": "bdf",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1512,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Backwards differentiation form for calculating DuDt\nNote that you will need ``bdf`` / :math:`\\delta t` in computing derivatives",
    "harvested_comments": [
      "This is actually calculated over several steps so scaling is required"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": true
  },
  {
    "name": "adams_moulton_flux",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1541,
    "signature": "(self, order = None)",
    "parameters": [
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adams-Moulton flux approximation for implicit time integration.\n\nParameters\n----------\norder : int, optional\n    Order of the approximation (1-3). Defaults to ``self.order``.\n\nReturns\n-------\nsympy.Basic\n    Weighted average of :math:`\\psi` and history terms.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "Lagrangian_Swarm",
    "is_public": true
  },
  {
    "name": "start",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 74,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Start PETSc performance logging.\n\nCall this at the beginning of your script/notebook to enable comprehensive\nperformance tracking. Works immediately in Jupyter - no environment variables needed!\n\nThis captures:\n- Decorated Python functions\n- All PETSc operations (MatMult, KSPSolve, VecNorm, etc.)\n- Memory usage and allocation\n- Floating point operations (flops)\n- MPI communication (in parallel runs)\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.timing.start()\n>>> # ... do work ...\n>>> uw.timing.print_table()  # View results\n\nNotes\n-----\n- Safe to call multiple times (subsequent calls are no-ops)\n- Zero overhead when not enabled\n- Can be called anywhere before performance-critical code",
    "harvested_comments": [
      "... do work ...",
      "View results"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "stop",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 104,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Stop PETSc logging (currently a no-op - PETSc logging runs until view()).\n\nProvided for API compatibility with legacy timing module.\nPETSc logging is lightweight and can run continuously.",
    "harvested_comments": [
      "PETSc logging doesn't need explicit stopping"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "reset",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 114,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Reset timing data.\n\nClears all accumulated PETSc logging data and starts fresh.\nUseful for timing specific sections of code.\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.timing.start()\n>>> # ... setup code (not timed) ...\n>>> uw.timing.reset()\n>>> # ... performance-critical code (timed) ...\n>>> uw.timing.print_table()",
    "harvested_comments": [
      "... setup code (not timed) ...",
      "... performance-critical code (timed) ...",
      "Note: PETSc doesn't have a true \"reset\" - we'd need to stop and restart",
      "For now, this is a no-op but documented for API compatibility"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "print_table",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 138,
    "signature": "(filename = None, format = 'auto')",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "format",
        "type_hint": null,
        "default": "'auto'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Display comprehensive performance results.\n\nShows timing for:\n- Decorated Python functions\n- PETSc operations (solvers, matrix ops, etc.)\n- Memory usage\n- Flop counts\n- MPI communication (parallel runs)\n\nParameters\n----------\nfilename : str, optional\n    If provided, write results to file. Extension determines format:\n    - `.csv` : Spreadsheet-compatible CSV format\n    - `.txt` or other : Human-readable ASCII table\nformat : str, optional\n    Override automatic format detection:\n    - \"auto\" : Detect from filename (default)\n    - \"ascii\" : Human-readable table\n    - \"csv\" : Comma-separated values\n\nExample\n-------\n>>> uw.timing.start()\n>>> # ... do work ...\n>>> uw.timing.print_table()  # Print to console\n>>> uw.timing.print_table(\"results.csv\")  # Save as CSV",
    "harvested_comments": [
      "... do work ...",
      "Print to console",
      "Save as CSV"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "enable_petsc_logging",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 176,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Enable PETSc performance logging.\n\nCalled automatically by start(). Can also be called directly.\nSafe to call multiple times.",
    "harvested_comments": [
      "Already enabled"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "print_petsc_log",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 195,
    "signature": "(filename = None, format = 'auto')",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "format",
        "type_hint": null,
        "default": "'auto'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Display or save PETSc performance logging summary.\n\nParameters\n----------\nfilename : str, optional\n    If provided, write log to this file. Otherwise print to console.\n    File extension determines format:\n    - `.csv` : Comma-separated values (spreadsheet-compatible)\n    - `.txt` or other : Human-readable ASCII table (default)\nformat : str, optional\n    Override automatic format detection. Options:\n    - \"auto\" : Detect from filename extension (default)\n    - \"ascii\" : Human-readable table\n    - \"csv\" : Comma-separated values\n\nExample\n-------\n>>> uw.timing.start()\n>>> # ... run simulation ...\n>>> uw.timing.print_petsc_log()  # Console output\n>>> uw.timing.print_petsc_log(\"timing.csv\")  # CSV for analysis",
    "harvested_comments": [
      "... run simulation ...",
      "Console output",
      "CSV for analysis",
      "Determine format from extension or explicit parameter",
      "Create viewer with appropriate format"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "routine_timer_decorator",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 256,
    "signature": "(routine, class_name = None)",
    "parameters": [
      {
        "name": "routine",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "class_name",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Decorator that registers a function as a PETSc timing event.\n\nNo environment variables needed - works immediately!\n\nParameters\n----------\nroutine : callable\n    Function or method to decorate\nclass_name : str, optional\n    Class name for better event labeling (auto-detected for methods)\n\nReturns\n-------\ncallable\n    Wrapped function that tracks calls via PETSc events\n\nExample\n-------\n>>> @uw.timing.routine_timer_decorator\n>>> def expensive_computation():\n>>>     # ... complex calculations ...\n>>>     return result\n>>>\n>>> uw.timing.start()\n>>> expensive_computation()\n>>> uw.timing.print_table()  # Shows timing for expensive_computation\n\nNotes\n-----\n- First call registers the PETSc event (one-time cost)\n- Subsequent calls just increment counters (negligible overhead)\n- Events appear in PETSc log with full statistics",
    "harvested_comments": [
      "... complex calculations ...",
      "Shows timing for expensive_computation",
      "Create event name",
      "Register PETSc event (happens once per function)",
      "Begin/end tracking - PETSc handles all statistics!"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "add_timing_to_module",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 379,
    "signature": "(mod)",
    "parameters": [
      {
        "name": "mod",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Automatically add timing decorators to all classes and functions in a module.\n\nRecursively walks through a module, decorating all classes and their methods.\nUseful for comprehensive profiling of entire subsystems.\n\nParameters\n----------\nmod : module\n    Python module to decorate\n\nExample\n-------\n>>> import underworld3 as uw\n>>> import underworld3.systems\n>>> uw.timing.add_timing_to_module(uw.systems)  # Time all solver classes\n>>> uw.timing.start()\n>>> # ... use solvers ...\n>>> uw.timing.print_table()  # See detailed solver timing\n\nNotes\n-----\n- Only decorates classes/functions defined in the specified module\n- Skips built-in modules and external dependencies\n- Safe to call multiple times (avoids double-decoration)",
    "harvested_comments": [
      "Time all solver classes",
      "... use solvers ...",
      "See detailed solver timing",
      "Already decorated",
      "Find submodules to recurse into"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_event",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 457,
    "signature": "(name)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a custom PETSc event for manual timing.\n\nUseful for timing specific code sections without decorators.\n\nParameters\n----------\nname : str\n    Name for the event (appears in timing output)\n\nReturns\n-------\nPETSc.Log.Event\n    Event object with begin() and end() methods\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.timing.start()\n>>>\n>>> my_event = uw.timing.create_event(\"DataProcessing\")\n>>> my_event.begin()\n>>> # ... complex data processing ...\n>>> my_event.end()\n>>>\n>>> uw.timing.print_table()  # Shows \"DataProcessing\" timing",
    "harvested_comments": [
      "... complex data processing ...",
      "Shows \"DataProcessing\" timing"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_summary",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 493,
    "signature": "(filter_uw = True, min_time = 0.001, sort_by = 'time')",
    "parameters": [
      {
        "name": "filter_uw",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "min_time",
        "type_hint": null,
        "default": "0.001",
        "description": ""
      },
      {
        "name": "sort_by",
        "type_hint": null,
        "default": "'time'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get user-friendly timing summary focusing on UW3 operations.\n\nFilters PETSc's comprehensive log to show only the most relevant timing\ninformation for UW3 users. By default, shows only UW3 operations (not\nlow-level PETSc internals).\n\nParameters\n----------\nfilter_uw : bool, optional\n    If True (default), show only UW3 operations. If False, show all PETSc events.\nmin_time : float, optional\n    Minimum time (seconds) for an event to be displayed. Default 0.001 (1ms).\n    Helps filter out negligible operations.\nsort_by : str, optional\n    Sort events by: 'time' (default), 'count', or 'name'.\n\nReturns\n-------\ndict\n    Dictionary with keys:\n    - 'events': List of (name, count, time, percent) tuples\n    - 'total_time': Total execution time\n    - 'num_events': Number of events displayed\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.timing.start()\n>>> # ... do work ...\n>>>\n>>> # Get UW3-focused summary\n>>> summary = uw.timing.get_summary()\n>>> for name, count, time, pct in summary['events']:\n>>>     print(f\"{name:40s} {count:5d} calls  {time:8.3f}s  ({pct:5.1f}%)\")\n>>>\n>>> # Get all events (including PETSc internals)\n>>> full_summary = uw.timing.get_summary(filter_uw=False, min_time=0.0)\n\nNotes\n-----\n- Call after `uw.timing.start()` and your computation\n- Filtered view helps identify UW3 performance bottlenecks\n- For comprehensive PETSc profiling, use `uw.timing.print_table()` or `filter_uw=False`",
    "harvested_comments": [
      "... do work ...",
      "Get UW3-focused summary",
      "Get all events (including PETSc internals)",
      "Collect all events first to calculate total time",
      "UW3 event patterns (customize based on actual event naming)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "print_summary",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 607,
    "signature": "(filter_uw = True, min_time = 0.001, sort_by = 'time', max_events = 50)",
    "parameters": [
      {
        "name": "filter_uw",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "min_time",
        "type_hint": null,
        "default": "0.001",
        "description": ""
      },
      {
        "name": "sort_by",
        "type_hint": null,
        "default": "'time'",
        "description": ""
      },
      {
        "name": "max_events",
        "type_hint": null,
        "default": "50",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Print user-friendly timing summary table.\n\nDisplays a clean, focused table of timing results for UW3 operations.\nMuch more readable than the full PETSc log for typical users.\n\nParameters\n----------\nfilter_uw : bool, optional\n    If True (default), show only UW3 operations. If False, show all events.\nmin_time : float, optional\n    Minimum time (seconds) for an event to be displayed. Default 0.001 (1ms).\nsort_by : str, optional\n    Sort events by: 'time' (default), 'count', or 'name'.\nmax_events : int, optional\n    Maximum number of events to display. Default 50.\n\nExample\n-------\n>>> import underworld3 as uw\n>>> uw.timing.start()\n>>> # ... run simulation ...\n>>>\n>>> # Quick UW3-focused summary\n>>> uw.timing.print_summary()\n>>>\n>>> # Detailed view with all events\n>>> uw.timing.print_summary(filter_uw=False, max_events=100)\n>>>\n>>> # Show top 10 most-called operations\n>>> uw.timing.print_summary(sort_by='count', max_events=10)\n\nNotes\n-----\n- For full PETSc profiling details, use `uw.timing.print_table()`\n- This function focuses on high-level UW3 operations\n- Perfect for quick performance checks in notebooks",
    "harvested_comments": [
      "... run simulation ...",
      "Quick UW3-focused summary",
      "Detailed view with all events",
      "Show top 10 most-called operations",
      "Only rank 0 prints"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_quantity",
    "kind": "method",
    "file": "src/underworld3/units.py",
    "line": 60,
    "signature": "(self, value, units)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a Pint quantity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_PintHelper",
    "is_public": true
  },
  {
    "name": "get_units",
    "kind": "method",
    "file": "src/underworld3/units.py",
    "line": 66,
    "signature": "(self, quantity)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get units from a Pint quantity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_PintHelper",
    "is_public": true
  },
  {
    "name": "check_dimensionality",
    "kind": "method",
    "file": "src/underworld3/units.py",
    "line": 70,
    "signature": "(self, q1, q2)",
    "parameters": [
      {
        "name": "q1",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "q2",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Check if two quantities have compatible dimensionality.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_PintHelper",
    "is_public": true
  },
  {
    "name": "get_dimensionality",
    "kind": "method",
    "file": "src/underworld3/units.py",
    "line": 74,
    "signature": "(self, quantity)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get dimensionality of a quantity.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_PintHelper",
    "is_public": true
  },
  {
    "name": "check_units_consistency",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 510,
    "signature": "(*expressions) -> bool",
    "parameters": [
      {
        "name": "*expressions",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if multiple expressions have consistent units for addition/comparison.\n\nThis function validates that all provided expressions have the same dimensionality,\nwhich is required for addition, subtraction, and comparison operations.\n\nArgs:\n    *expressions: Any number of expressions, quantities, or unit-aware objects\n\nReturns:\n    bool: True if all expressions have consistent units, False otherwise\n\nRaises:\n    DimensionalityError: If expressions have inconsistent units\n    NoUnitsError: If some expressions have units and others don't\n\nExamples:\n    >>> velocity1 = EnhancedMeshVariable(\"v1\", mesh, 2, units=\"m/s\")\n    >>> velocity2 = EnhancedMeshVariable(\"v2\", mesh, 2, units=\"km/h\")\n    >>> pressure = EnhancedMeshVariable(\"p\", mesh, 1, units=\"Pa\")\n\n    >>> check_units_consistency(velocity1, velocity2)  # True - both velocities\n    >>> check_units_consistency(velocity1, pressure)   # False - different dimensions",
    "harvested_comments": [
      "True - both velocities",
      "False - different dimensions",
      "Extract units info from all expressions",
      "Check if all have units or all don't have units",
      "All are unitless - consistent"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_dimensionality",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 567,
    "signature": "(expression) -> Optional[Any]",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Optional[Any]",
    "existing_docstring": "Get the dimensionality of an expression or quantity.\n\nArgs:\n    expression: Expression, quantity, or unit-aware object\n\nReturns:\n    Dimensionality representation (backend-specific) or None if no units\n\nExamples:\n    >>> velocity = EnhancedMeshVariable(\"velocity\", mesh, 2, units=\"m/s\")\n    >>> dims = get_dimensionality(velocity)\n    >>> print(dims)  # [length] / [time]",
    "harvested_comments": [
      "[length] / [time]"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 591,
    "signature": "(expression, simplify: bool = False) -> Optional[Any]",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "simplify",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": "Optional[Any]",
    "existing_docstring": "Get the units of an expression or quantity.\n\nThis is the unified, public API for extracting units from any object type\n(variables, quantities, SymPy expressions, etc.). It replaces the previous\n`units_of()` function and the internal `function.unit_conversion.get_units()`\nfor a clean, single API surface.\n\nIMPORTANT: This function ALWAYS returns Pint Unit objects (or None), never strings.\nWe accept strings for INPUT (user convenience), but always return Pint objects.\n\nArgs:\n    expression: Expression, quantity, or unit-aware object\n    simplify: If True, convert mixed units to simplified base SI units.\n              For example, `megayear ** 0.5 * meter / second ** 0.5`\n              simplifies to just `meter`. Default: False.\n\nReturns:\n    Pint Unit object or None if no units\n\nExamples:\n    >>> velocity = uw.discretisation.MeshVariable(\"velocity\", mesh, 2, units=\"m/s\")\n    >>> units = uw.get_units(velocity)\n    >>> print(units)  # <Unit('meter / second')>\n\n    >>> # Mixed units from composite expressions\n    >>> th2 = uw.expression(\"th2\", ((2 * kappa * t_now))**0.5)\n    >>> uw.get_units(th2)  # megayear ** 0.5 * meter / second ** 0.5\n    >>> uw.get_units(th2, simplify=True)  # meter (simplified!)",
    "harvested_comments": [
      "<Unit('meter / second')>",
      "Mixed units from composite expressions",
      "megayear ** 0.5 * meter / second ** 0.5",
      "meter (simplified!)",
      "Optionally simplify mixed units to base SI units"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "non_dimensionalise",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 645,
    "signature": "(expression, model = None) -> Any",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "model",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Convert expression to non-dimensional form using model reference scales.\n\nThis function uses dimensional analysis to compute appropriate scaling factors\nfrom the model's reference quantities, then divides the expression by those\nscales to produce dimensionless values. Dimensionality information is preserved\nto enable re-dimensionalization.\n\nProtocol-based approach works with:\n- MeshVariable/SwarmVariable (via .non_dimensional_value() method)\n- UWQuantity objects (extracts dimensionality, computes scale)\n- UnitAwareArray (extracts dimensionality from units)\n- Plain numbers (pass through unchanged)\n\nArgs:\n    expression: Expression, quantity, or unit-aware object to non-dimensionalise\n    model: Model instance with reference quantities (uses default if None)\n\nReturns:\n    Non-dimensional value(s) with preserved dimensionality metadata\n\nRaises:\n    NoUnitsError: If expression has no units and model has reference quantities\n    ValueError: If model has no reference quantities\n\nExamples:\n    >>> # With variables (uses existing method)\n    >>> velocity_var = MeshVariable(\"v\", mesh, 2, units=\"m/s\")\n    >>> nondim_v = non_dimensionalise(velocity_var)\n\n    >>> # With UWQuantity\n    >>> velocity_qty = uw.quantity(5.0, \"cm/year\")\n    >>> nondim_qty = non_dimensionalise(velocity_qty, model)\n    >>> # Result is dimensionless but remembers it was velocity\n\n    >>> # With plain number (no model reference quantities)\n    >>> plain_value = 2.5\n    >>> result = non_dimensionalise(plain_value)  # Returns 2.5",
    "harvested_comments": [
      "With variables (uses existing method)",
      "With UWQuantity",
      "Result is dimensionless but remembers it was velocity",
      "With plain number (no model reference quantities)",
      "Returns 2.5"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "show_nondimensional_form",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 883,
    "signature": "(expression, model = None)",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "model",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Display the non-dimensionalized form of a complex expression.\n\nThis function unwraps the expression (expanding UW wrappers to SymPy),\napplies non-dimensional scaling, and returns the result for inspection.\nUseful for seeing what will actually be compiled into C code when\nscaling is active.\n\nArgs:\n    expression: Any SymPy expression, UW expression, or variable\n    model: Model instance with reference quantities (uses default if None)\n\nReturns:\n    SymPy expression with non-dimensional scaling applied\n\nExamples:\n    >>> # See what the Stokes flux looks like non-dimensionally\n    >>> flux = stokes.constitutive_model.flux\n    >>> nondim_flux = uw.show_nondimensional_form(flux)\n    >>> print(nondim_flux)  # Should show values close to 1.0, not 1e21\n\n    >>> # Check a parameter\n    >>> viscosity = model.Parameters.shear_viscosity_0\n    >>> print(uw.show_nondimensional_form(viscosity))  # Should be ~1.0",
    "harvested_comments": [
      "See what the Stokes flux looks like non-dimensionally",
      "Should show values close to 1.0, not 1e21",
      "Check a parameter",
      "Should be ~1.0",
      "Check if scaling is active"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "dimensionalise",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 929,
    "signature": "(expression, target_dimensionality = None, model = None) -> Any",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_dimensionality",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "model",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Restore dimensional form to non-dimensional values using model reference scales.\n\nThis is the companion function to non_dimensionalise(). It multiplies dimensionless\nvalues by the appropriate reference scale to restore their dimensional form.\n\nThe function can operate in two modes:\n1. **Auto mode**: Extract dimensionality from the expression itself (if preserved)\n2. **Explicit mode**: Use provided target_dimensionality\n\nArgs:\n    expression: Non-dimensional value (UWQuantity, UnitAwareArray, or plain number)\n               with preserved dimensionality metadata\n    target_dimensionality: Optional dict specifying target dimensionality\n                          (Pint format: e.g., {'[length]': 1, '[time]': -1} for velocity)\n                          If None, uses dimensionality from expression\n    model: Model instance with reference quantities (uses default if None)\n\nReturns:\n    Dimensional quantity with appropriate units\n\nRaises:\n    ValueError: If no dimensionality information available\n    ValueError: If model has no reference quantities\n\nExamples:\n    >>> # Auto mode - dimensionality preserved from non_dimensionalise()\n    >>> velocity_qty = uw.quantity(5.0, \"cm/year\")\n    >>> nondim_vel = non_dimensionalise(velocity_qty, model)\n    >>> # nondim_vel remembers it was velocity\n    >>> dimensional_vel = dimensionalise(nondim_vel, model=model)\n    >>> # Result has appropriate units based on model scales\n\n    >>> # Explicit mode - specify dimensionality\n    >>> plain_value = 2.5  # dimensionless number\n    >>> velocity_dimensionality = {'[length]': 1, '[time]': -1}\n    >>> velocity = dimensionalise(plain_value, velocity_dimensionality, model)\n    >>> # Result is 2.5 * (length_scale / time_scale)\n\n    >>> # With arrays\n    >>> nondim_array = UnitAwareArray([1.0, 2.0, 3.0],\n    ...                               units=\"dimensionless\",\n    ...                               dimensionality={'[length]': 1})\n    >>> dimensional_array = dimensionalise(nondim_array, model=model)",
    "harvested_comments": [
      "Auto mode - dimensionality preserved from non_dimensionalise()",
      "nondim_vel remembers it was velocity",
      "Result has appropriate units based on model scales",
      "Explicit mode - specify dimensionality",
      "dimensionless number"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "simplify_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1086,
    "signature": "(expression) -> Any",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Simplify and cancel units in an expression.\n\nThis function performs dimensional analysis to simplify unit expressions,\ncanceling common factors and reducing to fundamental units.\n\nArgs:\n    expression: Expression with units to simplify\n\nReturns:\n    Expression with simplified units\n\nExamples:\n    >>> # Force per area = pressure\n    >>> force_per_area = force / area  # N/m\u00b2\n    >>> simplified = simplify_units(force_per_area)  # Pa",
    "harvested_comments": [
      "Force per area = pressure",
      "This would need backend-specific implementation",
      "For now, return the original expression"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "create_quantity",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1115,
    "signature": "(value, units: Union[str, Any], backend: Optional[str] = None) -> Any",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Union[str, Any]",
        "default": null,
        "description": ""
      },
      {
        "name": "backend",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Create a dimensional quantity from a value and units.\n\nArgs:\n    value: Numeric value or array\n    units: Units specification (string or units object)\n    backend: Backend to use ('pint' or 'sympy'), defaults to 'pint'\n\nReturns:\n    Dimensional quantity\n\nExamples:\n    >>> velocity_qty = create_quantity([1.0, 2.0], \"m/s\")\n    >>> pressure_qty = create_quantity(101325, \"Pa\")",
    "harvested_comments": [
      "backend parameter is deprecated - Pint is the only supported backend"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1138,
    "signature": "(quantity, target_units: Union[str, Any]) -> Any",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_units",
        "type_hint": "Union[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Convert quantity to different units.\n\nThis is the SINGLE SOURCE OF TRUTH for unit conversion in UW3.\nAll .to() methods on unit-aware types should delegate to this function.\n\nHandles:\n- UWQuantity \u2192 returns new UWQuantity with converted value\n- UWexpression \u2192 returns new UWexpression with converted value\n- UnitAwareArray \u2192 returns new UnitAwareArray with converted values\n- Pint Quantity \u2192 returns converted Pint Quantity\n\nArgs:\n    quantity: Quantity to convert (UWQuantity, UWexpression, UnitAwareArray, Pint)\n    target_units: Target units for conversion (str or Pint Unit)\n\nReturns:\n    Same type as input, converted to target units\n\nRaises:\n    DimensionalityError: If units are not compatible for conversion\n    NoUnitsError: If quantity has no units\n\nExamples:\n    >>> velocity = uw.quantity(10, \"m/s\")\n    >>> velocity_kmh = uw.convert_units(velocity, \"km/h\")\n    >>> print(velocity_kmh)  # 36.0 [kilometer / hour]\n\n    >>> radius = uw.expression(\"r\", uw.quantity(6370, \"km\"))\n    >>> radius_m = uw.convert_units(radius, \"m\")\n    >>> print(radius_m.value)  # 6370000.0",
    "harvested_comments": [
      "36.0 [kilometer / hour]",
      "Get current units info",
      "Parse target units if string",
      "Check dimensional compatibility",
      "Create test quantities to check compatibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "to_base_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1272,
    "signature": "(quantity) -> Any",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Convert quantity to SI base units.\n\nThis is a convenience function that converts any unit-aware quantity\nto its SI base unit representation.\n\nArgs:\n    quantity: Quantity to convert (UWQuantity, UWexpression, UnitAwareArray, Pint)\n\nReturns:\n    Same type as input, converted to SI base units\n\nRaises:\n    NoUnitsError: If quantity has no units\n\nExamples:\n    >>> velocity = uw.quantity(36, \"km/h\")\n    >>> velocity_si = uw.to_base_units(velocity)\n    >>> print(velocity_si)  # 10.0 [meter / second]\n\n    >>> radius = uw.expression(\"r\", uw.quantity(6370, \"km\"))\n    >>> radius_si = uw.to_base_units(radius)\n    >>> print(radius_si.value)  # 6370000.0",
    "harvested_comments": [
      "10.0 [meter / second]",
      "Get current units info",
      "=== Handle different input types ===",
      "1. UWQuantity - use its native .to_base_units() method",
      "2. UWexpression - convert the wrapped value"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "to_reduced_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1366,
    "signature": "(quantity) -> Any",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Simplify units by canceling common factors.\n\nThis is useful for complex unit expressions like (kg * m / s\u00b2) / (kg / m\u00b3)\nwhich would simplify to m\u2074 / s\u00b2.\n\nArgs:\n    quantity: Quantity to simplify (UWQuantity, UWexpression, UnitAwareArray, Pint)\n\nReturns:\n    Same type as input, with simplified units\n\nRaises:\n    NoUnitsError: If quantity has no units\n\nExamples:\n    >>> force = uw.quantity(100, \"kg*m/s**2\")\n    >>> force_simplified = uw.to_reduced_units(force)\n    >>> print(force_simplified)  # 100.0 [newton]",
    "harvested_comments": [
      "100.0 [newton]",
      "Get current units info",
      "=== Handle different input types ===",
      "1. UWQuantity - use its native .to_reduced_units() method",
      "2. UWexpression - convert the wrapped value"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "to_compact",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1452,
    "signature": "(quantity) -> Any",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Any",
    "existing_docstring": "Convert quantity to most human-readable unit representation.\n\nThis automatically chooses unit prefixes (kilo, mega, micro, etc.)\nto make the number more readable. For example, 0.001 km becomes 1 m.\n\nArgs:\n    quantity: Quantity to make compact (UWQuantity, UWexpression, UnitAwareArray, Pint)\n\nReturns:\n    Same type as input, with compact units\n\nRaises:\n    NoUnitsError: If quantity has no units\n\nExamples:\n    >>> length = uw.quantity(0.001, \"km\")\n    >>> length_compact = uw.to_compact(length)\n    >>> print(length_compact)  # 1.0 [meter]\n\n    >>> big_length = uw.quantity(1e9, \"m\")\n    >>> big_compact = uw.to_compact(big_length)\n    >>> print(big_compact)  # 1.0 [gigameter]",
    "harvested_comments": [
      "1.0 [meter]",
      "1.0 [gigameter]",
      "Get current units info",
      "=== Handle different input types ===",
      "1. UWQuantity - use its native .to_compact() method"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "get_scaling_coefficients",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1542,
    "signature": "() -> Dict[str, Any]",
    "parameters": [],
    "returns": "Dict[str, Any]",
    "existing_docstring": "Get the current scaling coefficients used for non-dimensionalisation.\n\nReturns:\n    Dictionary of scaling coefficients for fundamental dimensions\n\nExamples:\n    >>> coeffs = get_scaling_coefficients()\n    >>> print(coeffs['[length]'])  # 1.0 meter\n    >>> print(coeffs['[time]'])    # 1.0 year",
    "harvested_comments": [
      "Use the existing scaling module"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "set_scaling_coefficients",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1560,
    "signature": "(coefficients: Dict[str, Any]) -> None",
    "parameters": [
      {
        "name": "coefficients",
        "type_hint": "Dict[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Set custom scaling coefficients for non-dimensionalisation.\n\nArgs:\n    coefficients: Dictionary mapping dimension names to scaling quantities\n\nExamples:\n    >>> coeffs = get_scaling_coefficients()\n    >>> coeffs['[length]'] = create_quantity(1000, \"km\")  # Geological scale\n    >>> coeffs['[time]'] = create_quantity(1e6, \"year\")   # Geological time\n    >>> set_scaling_coefficients(coeffs)",
    "harvested_comments": [
      "Geological scale",
      "Geological time",
      "This would need to update the scaling module's global coefficients"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_dimensionless",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1578,
    "signature": "(expression) -> bool",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if expression is dimensionless.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1583,
    "signature": "(expression) -> bool",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if expression has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "same_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1588,
    "signature": "(expr1, expr2) -> bool",
    "parameters": [
      {
        "name": "expr1",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expr2",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if two expressions have the same units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_velocity",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1596,
    "signature": "(expression) -> bool",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if expression has velocity dimensions [length]/[time].",
    "harvested_comments": [
      "This would need backend-specific dimensionality checking",
      "For now, check string representation"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "is_pressure",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1606,
    "signature": "(expression) -> bool",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Check if expression has pressure dimensions [mass]/([length]\u22c5[time]\u00b2).",
    "harvested_comments": [
      "This would need backend-specific dimensionality checking"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate_expression_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1616,
    "signature": "(expression, expected_units: Union[str, Any]) -> bool",
    "parameters": [
      {
        "name": "expression",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expected_units",
        "type_hint": "Union[str, Any]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Validate that an expression has the expected units.\n\nArgs:\n    expression: Expression to validate\n    expected_units: Expected units (string or units object)\n\nReturns:\n    True if units match, False otherwise\n\nRaises:\n    NoUnitsError: If expression has no units but units are expected",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "assert_dimensionality",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1641,
    "signature": "(value, expected_dimensionality: str, value_name: str = 'value', allow_dimensionless: bool = True, strict: bool = False) -> None",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "expected_dimensionality",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "value_name",
        "type_hint": "str",
        "default": "'value'",
        "description": ""
      },
      {
        "name": "allow_dimensionless",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "strict",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Assert that a value has the expected dimensionality.\n\nThis is a general type-safety gatekeeper that validates physical dimensionality\nat various points in the code. Complements get_dimensionality() by providing\nenforcement rather than just inspection.\n\nArgs:\n    value: The value to validate (quantity, expression, variable, array, etc.)\n    expected_dimensionality: Expected dimensionality as a string\n        - Specific dimensionality: \"[length]\", \"[length]/[time]\", \"[mass]*[length]/[time]**2\"\n        - Dimensionless: \"dimensionless\" or \"\"\n    value_name: Name of the value being validated (for error messages)\n    allow_dimensionless: If True, accept dimensionless values even when dimensional\n        expected (default: True, as dimensionless is valid for solver operations)\n    strict: If True, raise error on dimensionless when dimensional expected\n        (default: False, overrides allow_dimensionless)\n\nRaises:\n    DimensionalityError: If dimensionality doesn't match expected\n    NoUnitsError: If strict=True and value is dimensionless when dimensional expected\n\nExamples:\n    >>> # Validate coordinates have length dimensionality\n    >>> coords = mesh.X.coords\n    >>> assert_dimensionality(coords, \"[length]\", \"coordinates\")\n\n    >>> # Validate velocity has correct dimensionality\n    >>> velocity = uw.discretisation.MeshVariable(\"v\", mesh, 2, units=\"m/s\")\n    >>> assert_dimensionality(velocity, \"[length]/[time]\", \"velocity\")\n\n    >>> # Validate pressure\n    >>> pressure = uw.quantity(1e5, \"Pa\")\n    >>> assert_dimensionality(pressure, \"[mass]/([length]*[time]**2)\", \"pressure\")\n\n    >>> # Accept dimensionless when dimensional expected (default)\n    >>> dimensionless_coords = np.array([[0, 1], [1, 1]])\n    >>> assert_dimensionality(dimensionless_coords, \"[length]\", \"coords\")  # OK\n\n    >>> # Strict mode: reject dimensionless when dimensional expected\n    >>> assert_dimensionality(\n    ...     dimensionless_coords, \"[length]\", \"coords\", strict=True\n    ... )  # Raises NoUnitsError",
    "harvested_comments": [
      "Validate coordinates have length dimensionality",
      "Validate velocity has correct dimensionality",
      "Validate pressure",
      "Accept dimensionless when dimensional expected (default)",
      "Strict mode: reject dimensionless when dimensional expected"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "validate_coordinates_dimensionality",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1772,
    "signature": "(coords) -> None",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Validate that coordinates have length dimensionality [L].\n\nThis function checks that the provided coordinates are either dimensionless\n(which is valid for solver operations) or have length dimensionality. It will\nraise an error if coordinates have the wrong dimensionality (e.g., time,\ntemperature, velocity).\n\nArgs:\n    coords: Coordinate array to validate\n\nRaises:\n    DimensionalityError: If coordinates have units but not length dimensionality\n\nExamples:\n    >>> # Valid: dimensionless coords (for solvers)\n    >>> validate_coordinates_dimensionality(np.array([[0, 1], [1, 1]]))\n\n    >>> # Valid: coords with length units\n    >>> coords = uw.function.UnitAwareArray([[0, 1000], [1000, 1000]], units=\"meter\")\n    >>> validate_coordinates_dimensionality(coords)\n\n    >>> # Invalid: coords with time units (would raise error)\n    >>> time_coords = uw.quantity(5.0, \"second\")\n    >>> validate_coordinates_dimensionality(time_coords)  # Raises DimensionalityError",
    "harvested_comments": [
      "Valid: dimensionless coords (for solvers)",
      "Valid: coords with length units",
      "Invalid: coords with time units (would raise error)",
      "Raises DimensionalityError",
      "Check if coords have units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "enforce_units_consistency",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1827,
    "signature": "(*expressions) -> None",
    "parameters": [
      {
        "name": "*expressions",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Enforce units consistency, raising an error if inconsistent.\n\nArgs:\n    *expressions: Expressions that must have consistent units\n\nRaises:\n    DimensionalityError: If units are inconsistent\n    NoUnitsError: If some have units and others don't",
    "harvested_comments": [
      "This already raises appropriate errors"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "require_units_if_active",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1847,
    "signature": "(value, name: str, expected_dimensionality: str = None, default_unit: str = None) -> float",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "expected_dimensionality",
        "type_hint": "str",
        "default": "None",
        "description": ""
      },
      {
        "name": "default_unit",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "float",
    "existing_docstring": "Validate input and return nondimensional value when units are active.\n\nThis is a gatekeeper function for mesh creation and similar contexts where:\n- When Model with units is active: inputs MUST have units (enforces explicitness)\n- When no units active: raw numbers are accepted\n\nThis prevents ambiguity in dimensional problems where a raw number like `400`\ncould mean meters, kilometers, or a nondimensional value.\n\nArgs:\n    value: Input value (quantity, expression, or raw number)\n    name: Parameter name for error messages (e.g., \"depth_max\")\n    expected_dimensionality: Expected dimensionality string (e.g., \"[length]\")\n        If provided, validates the input has correct dimensionality.\n    default_unit: Default unit to assume for raw values when units not active.\n        Only used for documentation in error messages.\n\nReturns:\n    float: Nondimensional value (divided by appropriate reference scale)\n\nRaises:\n    ValueError: If units are active but value has no units\n    DimensionalityError: If value has wrong dimensionality\n\nExamples:\n    >>> # With units active - requires quantity\n    >>> model = uw.Model()\n    >>> model.set_reference_quantities(length=uw.quantity(1000, \"km\"), ...)\n    >>> depth = require_units_if_active(\n    ...     uw.quantity(400, \"km\"),\n    ...     \"depth_max\",\n    ...     expected_dimensionality=\"[length]\"\n    ... )\n    >>> depth  # Returns 0.4 (400 km / 1000 km reference)\n\n    >>> # Without units - raw numbers accepted\n    >>> depth = require_units_if_active(400, \"depth_max\")\n    >>> depth  # Returns 400 (unchanged)\n\n    >>> # Error case - units active but raw number provided\n    >>> model.set_reference_quantities(...)\n    >>> require_units_if_active(400, \"depth_max\")  # Raises ValueError",
    "harvested_comments": [
      "With units active - requires quantity",
      "Returns 0.4 (400 km / 1000 km reference)",
      "Without units - raw numbers accepted",
      "Returns 400 (unchanged)",
      "Error case - units active but raw number provided"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "convert_angle_to_degrees",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 1947,
    "signature": "(value, name: str = 'angle') -> float",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "'angle'",
        "description": ""
      }
    ],
    "returns": "float",
    "existing_docstring": "Convert an angle value to degrees.\n\nAccepts:\n- Raw numbers: assumed to be degrees\n- Quantities with degree units: extracted as degrees\n- Quantities with radian units: converted to degrees\n\nArgs:\n    value: Angle value (quantity or raw number)\n    name: Parameter name for error messages\n\nReturns:\n    float: Angle in degrees\n\nExamples:\n    >>> convert_angle_to_degrees(45)  # Raw number \u2192 45 degrees\n    >>> convert_angle_to_degrees(uw.quantity(45, \"degree\"))  # \u2192 45\n    >>> convert_angle_to_degrees(uw.quantity(np.pi/4, \"radian\"))  # \u2192 45",
    "harvested_comments": [
      "Raw number \u2192 45 degrees",
      "Raw number - assume degrees (conventional for geographic)",
      "Has units - convert to degrees",
      "pint-style quantity",
      "UWQuantity with pint backend"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "_Unknowns",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 53,
    "signature": "class _Unknowns:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Unknowns",
    "kind": "class",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2123,
    "signature": "class _Unknowns(SolverBaseClass._Unknowns):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 32,
    "signature": "def __init__(self, mesh):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 57,
    "signature": "def __init__(inner_self, _owning_solver):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 832,
    "signature": "def __init__(self,\n                 mesh     : uw.discretisation.Mesh,\n                 u_Field  : uw.discretisation.MeshVariable = None,\n                 degree: int = 2,\n                 verbose    = False,\n                 DuDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                 DFDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                 ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1427,
    "signature": "def __init__(self,\n                 mesh     : uw.discretisation.Mesh,\n                 u_Field  : uw.discretisation.MeshVariable = None,\n                 degree     = 2,\n                 verbose    = False,\n                 DuDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                 DFDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                 ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2126,
    "signature": "def __init__(inner_self, owning_solver):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2149,
    "signature": "def __init__(self,\n                 mesh          : underworld3.discretisation.Mesh,\n                 velocityField : Optional[underworld3.discretisation.MeshVariable] = None,\n                 pressureField : Optional[underworld3.discretisation.MeshVariable] = None,\n                 degree        : Optional[int] = 2,\n                 p_continuous  : Optional[bool] = True,\n                 verbose       : Optional[bool]                           =False,\n                 DuDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                 DFDt          : Union[uw.systems.ddt.SemiLagrangian, uw.systems.ddt.Lagrangian] = None,\n                ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 338,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: Optional[uw.discretisation.MeshVariable] = None, degree: int = 2, verbose: bool = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Initialize vector source term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_MyVectorEquation",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 194,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, verbose = False, degree = 2, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Keep track",
      "# Parent class will set up default values etc",
      "default values for properties"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 398,
    "signature": "(self, mesh: uw.discretisation.Mesh, h_Field: Optional[uw.discretisation.MeshVariable] = None, v_Field: Optional[uw.discretisation.MeshVariable] = None, degree: int = 2, verbose = False, DuDt = None, DFDt = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "h_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "v_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "# Set up the projection operator that",
      "# solves the flow rate",
      "If we add smoothing, it should be small"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 661,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Not used in Stokes, but may be used in NS, VE etc",
      "User-facing operations are matrices / vectors by preference",
      "by default, incompressibility constraint",
      "this attrib records if we need to setup the problem (again)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1203,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, order: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "DuDt Not used in VE, but may be in child classes",
      "Stokes is parent (will not build DuDt or DFDt)",
      "VE time-order"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1374,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1493,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero vector"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1638,
    "signature": "(self, mesh: uw.discretisation.Mesh, tensor_Field: uw.discretisation.MeshVariable = None, scalar_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "tensor_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "scalar_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1815,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, V_fn: Union[uw.discretisation.MeshVariable, sympy.Basic], order: int = 1, restore_points_func: Callable = None, verbose = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "V_fn",
        "type_hint": "Union[uw.discretisation.MeshVariable, sympy.Basic]",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Should be a sympy function",
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2317,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, order: int = 1, theta: float = 0.0, evalf: Optional[bool] = False, verbose = False, DuDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything",
      "## by default - it's the template / skeleton"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2724,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: uw.discretisation.MeshVariable, pressureField: uw.discretisation.MeshVariable, rho: Optional[float] = 0.0, restore_points_func: Callable = None, order: Optional[int] = 2, p_continuous: Optional[bool] = False, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "rho",
        "type_hint": "Optional[float]",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values and load u_Field into the solver",
      "These are unique to the advection solver",
      "self._E = self.mesh.vector.strain_tensor(self.u.sym)",
      "## sets up DuDt and DFDt",
      "# ._setup_history_terms()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1666,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1742,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solver_template.py",
    "line": 86,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: Optional[uw.discretisation.MeshVariable] = None, degree: int = 2, verbose: bool = False, DuDt: Optional[Union[SemiLagrangian_DDt, Lagrangian_DDt, Eulerian_DDt]] = None, DFDt: Optional[Union[SemiLagrangian_DDt, Lagrangian_DDt, Eulerian_DDt]] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Optional[Union[SemiLagrangian_DDt, Lagrangian_DDt, Eulerian_DDt]]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Optional[Union[SemiLagrangian_DDt, Lagrangian_DDt, Eulerian_DDt]]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize the solver.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The computational mesh\nu_Field : uw.discretisation.MeshVariable, optional\n    Solution field (created if None)\ndegree : int\n    Polynomial degree for basis functions\nverbose : bool\n    Enable verbose output\nDuDt : DDt object, optional\n    Time derivative method for solution\nDFDt : DDt object, optional\n    Time derivative method for flux",
    "harvested_comments": [
      "Track instances",
      "Initialize parent class",
      "Initialize default property values",
      "Source term",
      "Problem-specific parameters"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_MyEquation",
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 264,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 574,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nNow uses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 796,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\n`sympy.oo` (infinity) for default values ensures that sympy.Min simplifies away\nthe conditionals when they are not required.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1012,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1579,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nNow uses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1850,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for scalar permeability.\nMatrix-valued `s` remains instance-level (special case).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2009,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 100,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 284,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 392,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\n`sympy.oo` (infinity) for default values ensures that sympy.Min simplifies away\nthe conditionals when they are not required",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 813,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1489,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1574,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 133,
    "signature": "def _object_viewer(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_reset",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 145,
    "signature": "def _reset(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_build",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 357,
    "signature": "def _build(self,\n                    verbose: bool = False,\n                    debug: bool = False,\n                    debug_name: str = None,\n                    ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_problem_description",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 401,
    "signature": "def _setup_problem_description(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_get_dof_partition_by_field_id",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 715,
    "signature": "def _get_dof_partition_by_field_id(self,\n                                       section_type: str,\n                                       field_id: int,\n                                       filename: Optional[str | None] = None,\n                                       outputPath: Optional[str] = \"\"):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_discretisation",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 919,
    "signature": "def _setup_discretisation(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_pointwise_functions",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1070,
    "signature": "def _setup_pointwise_functions(self, verbose=False, debug=False, debug_name=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_solver",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1206,
    "signature": "def _setup_solver(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1347,
    "signature": "def _object_viewer(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_pointwise_functions",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1674,
    "signature": "def _setup_pointwise_functions(self, verbose=False, debug=False, debug_name=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_solver",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1819,
    "signature": "def _setup_solver(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2047,
    "signature": "def _object_viewer(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_history_terms",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2300,
    "signature": "def _setup_history_terms(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2447,
    "signature": "def _object_viewer(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_pointwise_functions",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2562,
    "signature": "def _setup_pointwise_functions(self, verbose=False, debug=False, debug_name=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_solver",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2934,
    "signature": "def _setup_solver(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_BaseMeshVariable",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 73,
    "signature": "class _BaseMeshVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The MeshVariable class generates a variable supported by a finite element mesh and the\nunderlying sympy representation that makes it possible to construct expressions that\ndepend on the values of the MeshVariable.\n\nTo set / read nodal values, use the numpy interface via the 'data' property.\n\nParameters\n----------\nvarname :\n    A text name for this variable. Use an R-string if a latex-expression is used\nmesh :\n    The supporting underworld mesh.\nnum_components :\n    The number of components this variable has.\n    For example, scalars will have `num_components=1`,\n    while a 2d vector would have `num_components=2`.\nvtype :\n    Optional. The underworld variable type for this variable.\n    If not defined it will be inferred from `num_components`\n    if possible.\ndegree :\n    The polynomial degree for this variable.\nvarsymbol:\n    Over-ride the varname with a symbolic form for printing etc (latex). Should be an R-string.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1804,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2307,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2712,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "_PintHelper",
    "kind": "class",
    "file": "src/underworld3/units.py",
    "line": 49,
    "signature": "class _PintHelper",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Simple helper for Pint operations.\n\nThis replaces the deprecated PintBackend class with direct Pint usage.\nProvides a minimal interface for the few places that need backend-like operations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 270,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 559,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "viscosity property and init the parent(s)",
      "In this case, nothing seems to be needed.",
      "The viscosity is completely defined",
      "in terms of the Parameters"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 597,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 776,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "non-paramter properties that we want to",
      "use in other expressions and init the parent(s)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 846,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 967,
    "signature": "(self, unknowns, order = 1, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# We just need to add the expressions for the stress history terms in here.\\",
      "# They are properties to hold expressions that are persistent for this instance",
      "# (i.e. we only update the value, not the object)",
      "Store material_name before creating expressions (needed by create_unique_symbol)",
      "This may not be defined at initialisation time, set to None until used"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1074,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Internal symbols for stress history (not parameters, internal state)",
      "# The following expressions are containers for derived/computed values.",
      "# They have @property calls to retrieve / calculate them.",
      "# We keep them as expression containers for lazy evaluation."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1602,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1667,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Set default diffusivity as an identity matrix wrapped in an expression",
      "Store the validated diffusivity as a diagonal matrix"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1743,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1872,
    "signature": "(inner_self, _owning_model, permeabililty: Union[float, sympy.Function] = 1)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "permeabililty",
        "type_hint": "Union[float, sympy.Function]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Note: typo in param name preserved for compatibility",
      "Row matrix (1, dim) to match grad_u from jacobian"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1994,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "viscosity property and init the parent(s)",
      "In this case, nothing seems to be needed.",
      "The viscosity is completely defined",
      "in terms of the Parameters"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2042,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 66,
    "signature": "(self, dim: int, u_dim: int)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "u_dim",
        "type_hint": "int",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Define / identify the various properties in the class but leave",
      "the implementation to child classes. The constitutive tensor is",
      "defined as a template here, but should be instantiated via class",
      "properties as required.",
      "We provide a function that converts gradients / gradient history terms"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 106,
    "signature": "(inner_self, k = 1)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "k",
        "type_hint": null,
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 290,
    "signature": "(inner_self, viscosity: Union[float, sympy.Function] = None)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "viscosity",
        "type_hint": "Union[float, sympy.Function]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 308,
    "signature": "(self, dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 387,
    "signature": "(self, dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 401,
    "signature": "(inner_self, materialIndex: Union[uw.swarm.SwarmVariable, uw.discretisation.MeshVariable] = None, shear_viscosity_0: Union[list, sympy.Function] = [1], shear_viscosity_min: Union[list, sympy.Function] = [-sympy.oo], shear_viscosity_max: Union[list, sympy.Function] = [sympy.oo], yield_stress: Union[list, sympy.Function] = [sympy.oo], yield_stress_min: Union[list, sympy.Function] = [-sympy.oo], strainrate_inv_II: sympy.Function = sympy.oo, strainrate_inv_II_min: float = 0.0, averaging_method: str = 'HA')",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "materialIndex",
        "type_hint": "Union[uw.swarm.SwarmVariable, uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "shear_viscosity_0",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[1]",
        "description": ""
      },
      {
        "name": "shear_viscosity_min",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[-sympy.oo]",
        "description": ""
      },
      {
        "name": "shear_viscosity_max",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      },
      {
        "name": "yield_stress",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      },
      {
        "name": "yield_stress_min",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[-sympy.oo]",
        "description": ""
      },
      {
        "name": "strainrate_inv_II",
        "type_hint": "sympy.Function",
        "default": "sympy.oo",
        "description": ""
      },
      {
        "name": "strainrate_inv_II_min",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "averaging_method",
        "type_hint": "str",
        "default": "'HA'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 819,
    "signature": "(inner_self, materialIndex: Union[uw.swarm.SwarmVariable, uw.discretisation.MeshVariable] = None, shear_viscosity_0: Union[list, sympy.Function] = [1], shear_modulus: Union[list, sympy.Function] = [sympy.oo], shear_viscosity_min: Union[list, sympy.Function] = [-sympy.oo], shear_viscosity_max: Union[list, sympy.Function] = [sympy.oo], yield_stress: Union[list, sympy.Function] = [sympy.oo], yield_stress_min: Union[list, sympy.Function] = [-sympy.oo], strainrate_inv_II: sympy.Function = sympy.oo, strainrate_inv_II_min: float = 0.0, averaging_method: str = 'HA', stress_star: sympy.Function = None, stress_star_star: sympy.Function = None, dt_elastic: Union[float, sympy.Function] = [sympy.oo])",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "materialIndex",
        "type_hint": "Union[uw.swarm.SwarmVariable, uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "shear_viscosity_0",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[1]",
        "description": ""
      },
      {
        "name": "shear_modulus",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      },
      {
        "name": "shear_viscosity_min",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[-sympy.oo]",
        "description": ""
      },
      {
        "name": "shear_viscosity_max",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      },
      {
        "name": "yield_stress",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      },
      {
        "name": "yield_stress_min",
        "type_hint": "Union[list, sympy.Function]",
        "default": "[-sympy.oo]",
        "description": ""
      },
      {
        "name": "strainrate_inv_II",
        "type_hint": "sympy.Function",
        "default": "sympy.oo",
        "description": ""
      },
      {
        "name": "strainrate_inv_II_min",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "averaging_method",
        "type_hint": "str",
        "default": "'HA'",
        "description": ""
      },
      {
        "name": "stress_star",
        "type_hint": "sympy.Function",
        "default": "None",
        "description": ""
      },
      {
        "name": "stress_star_star",
        "type_hint": "sympy.Function",
        "default": "None",
        "description": ""
      },
      {
        "name": "dt_elastic",
        "type_hint": "Union[float, sympy.Function]",
        "default": "[sympy.oo]",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1293,
    "signature": "(self, dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1495,
    "signature": "(inner_self, diffusivity: Union[float, sympy.Function] = 1)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "diffusivity",
        "type_hint": "Union[float, sympy.Function]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1510,
    "signature": "(self, dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1580,
    "signature": "(inner_self, eta_0: Union[float, sympy.Function] = 1, eta_1: Union[float, sympy.Function] = 1, director: Union[sympy.Matrix, sympy.Function] = sympy.Matrix([0, 0, 1]))",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "eta_0",
        "type_hint": "Union[float, sympy.Function]",
        "default": "1",
        "description": ""
      },
      {
        "name": "eta_1",
        "type_hint": "Union[float, sympy.Function]",
        "default": "1",
        "description": ""
      },
      {
        "name": "director",
        "type_hint": "Union[sympy.Matrix, sympy.Function]",
        "default": "sympy.Matrix([0, 0, 1])",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1629,
    "signature": "(self, dim)",
    "parameters": [
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "default values ... maybe ??"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1694,
    "signature": "(self, material_swarmVariable: Optional[IndexSwarmVariable] = None, constitutive_models: Optional[list] = [])",
    "parameters": [
      {
        "name": "material_swarmVariable",
        "type_hint": "Optional[IndexSwarmVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "constitutive_models",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MultiMaterial",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 93,
    "signature": "(self, index, system, pretty_str = None, latex_str = None, mesh = None, axis_index = None)",
    "parameters": [
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "system",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "pretty_str",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "latex_str",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "axis_index",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Store UW3-specific attributes",
      "Cache the original BaseScalar for equality comparison",
      "This is what makes sympy.diff() work!",
      "Track for debugging"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1379,
    "signature": "(self, mesh, system: Optional[CoordinateSystemType] = CoordinateSystemType.CARTESIAN)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "system",
        "type_hint": "Optional[CoordinateSystemType]",
        "default": "CoordinateSystemType.CARTESIAN",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Guard against SymPy trying to construct a CoordinateSystem from sympified elements",
      "SymPy may iterate over the object and try to recreate it from elements",
      "are the mesh coordinates XYZ or have they been replaced by",
      "\"Natural\" coordinates like r, theta, z ?",
      "Get the raw BaseScalars from the mesh"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_setup_discretisation",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 1524,
    "signature": "def _setup_discretisation(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Most of what is in the init phase that is not called by _setup_terms()\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_setup_discretisation",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_generic_snes_solvers.pyx",
    "line": 2773,
    "signature": "def _setup_discretisation(self, verbose=False):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Most of what is in the init phase that is not called by _setup_terms()\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 46,
    "signature": "def __init__( self,\n                  mesh:  underworld3.discretisation.Mesh,\n                  fn:    Union[float, int, sympy.Basic] ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/cython/petsc_maths.pyx",
    "line": 238,
    "signature": "def __init__( self,\n                  mesh:  underworld3.discretisation.Mesh,\n                  fn:    Union[float, int, sympy.Basic] ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 208,
    "signature": "(self, plex_or_meshfile, degree = 1, simplex = True, coordinate_system_type = None, qdegree = 2, markVertices = None, useRegions = None, useMultipleTags = None, filename = None, refinement = None, refinement_callback = None, coarsening = None, coarsening_callback = None, return_coords_to_bounds = None, boundaries = None, boundary_normals = None, name = None, units = None, verbose = False, *args, **kwargs)",
    "parameters": [
      {
        "name": "plex_or_meshfile",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "coordinate_system_type",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_coords_to_bounds",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundaries",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundary_normals",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Get coordinate units from model (not user parameter)",
      "The model owns the unit system - all meshes use the same units",
      "Ignore user-provided units parameter, get from model instead",
      "Set units from model",
      "Lock model units now that a mesh has been created"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 34,
    "signature": "(self, mesh, name: str = 'default')",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "str",
        "default": "'default'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Stores CachedDMInterpolationInfo"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 741,
    "signature": "(self, name, sym = None, description = 'No description provided', value = None, units = None, **kwargs)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sym",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "description",
        "type_hint": null,
        "default": "'No description provided'",
        "description": ""
      },
      {
        "name": "value",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Legacy parameter",
      "Units for wrapping the value",
      "Handle legacy 'value' parameter",
      "If units are provided and sym is a plain numeric value, wrap it in UWQuantity",
      "Don't wrap if sym is already a UWQuantity, UWexpression, or SymPy expression"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1679,
    "signature": "(self, expr, *args, **kwargs)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWDerivativeExpression",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 150,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "region_id -> material_name",
      "Material change callbacks"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 63,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "mesh_vector_calculus",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 290,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "NATIVE coordinate systems deprecated, always warn"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "mesh_vector_calculus_cylindrical",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 616,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "mesh_vector_calculus_spherical",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/maths/vector_calculus.py",
    "line": 807,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "mesh_vector_calculus_spherical_surface2D_lonlat",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/mpi.py",
    "line": 387,
    "signature": "(self, pattern = 'collective', returnobj = None)",
    "parameters": [
      {
        "name": "pattern",
        "type_hint": null,
        "default": "'collective'",
        "description": ""
      },
      {
        "name": "returnobj",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "call_pattern",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 141,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Parameter change callbacks",
      "Parameter change history"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 151,
    "signature": "(self, name, swarm, size = None, vtype = None, dtype = float, proxy_degree = 1, proxy_continuous = True, _register = True, _proxy = True, _nn_proxy = False, varsymbol = None, rebuild_on_cycle = True, units = None, units_backend = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "dtype",
        "type_hint": null,
        "default": "float",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_proxy",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_nn_proxy",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "rebuild_on_cycle",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "only needed if MATRIX type",
      "Store unit metadata for variable",
      "Convert string units to Pint Unit objects for consistency with MeshVariable",
      "Parse string units to Pint Unit object",
      "uw.units('K') returns a Quantity (1 kelvin), so we extract .units to get the Unit"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1943,
    "signature": "(self, name, swarm, indices = 1, proxy_degree = 1, proxy_continuous = True, update_type = 0, npoints = 5, radius = 0.5, npoints_bc = 2, ind_bc = None, varsymbol = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "indices",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "update_type",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "npoints",
        "type_hint": null,
        "default": "5",
        "description": ""
      },
      {
        "name": "radius",
        "type_hint": null,
        "default": "0.5",
        "description": ""
      },
      {
        "name": "npoints_bc",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "ind_bc",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "**2 # changed to radius",
      "These are the things we require of the generic swarm variable type",
      "The indices variable defines how many \"level set\" maps we create as components in the proxy variable",
      "Initialize lazy evaluation state",
      "Proxy variables need initial update"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2308,
    "signature": "(self, mesh, recycle_rate = 0, verbose = False, clip_to_mesh = True)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "recycle_rate",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "clip_to_mesh",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Store reference to model instead of direct mesh reference",
      "This enables dynamic mesh handover while maintaining access to mesh services",
      "Register mesh with model if not already present",
      "Store reference to this swarm's specific mesh for proxy operations",
      "Mesh version tracking for coordinate change detection"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4310,
    "signature": "(self, trackedVariable: uw.discretisation.MeshVariable, verbose = False)",
    "parameters": [
      {
        "name": "trackedVariable",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Set up a standard swarm",
      "The launch point location",
      "The launch point index",
      "The launch point processor rank",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "NodalPointSwarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 143,
    "signature": "(self, mesh, recycle_rate = 0, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "recycle_rate",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Is the swarm a streak-swarm ?",
      "dictionary for variables",
      "import weakref (not helpful as garbage collection does not remove the fields from the DM)",
      "self._vars = weakref.WeakValueDictionary()",
      "add variable to handle particle coords - predefined by DMSwarm, expose to UW"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1396,
    "signature": "(self, trackedVariable: uw.discretisation.MeshVariable, verbose = False)",
    "parameters": [
      {
        "name": "trackedVariable",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Set up a standard swarm",
      "proxy_degree=trackedVariable.degree,",
      "proxy_continuous=trackedVariable.continuous,",
      "The launch point location",
      "The launch point index"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "NodalPointPICSwarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 68,
    "signature": "(self, psi_fn: sympy.Basic, theta: Optional[float] = 0.5, varsymbol: Optional[str] = '\\\\psi', verbose: Optional[bool] = False, bcs = [], order: int = 1, smoothing: float = 0.0)",
    "parameters": [
      {
        "name": "psi_fn",
        "type_hint": "sympy.Basic",
        "default": null,
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": "Optional[float]",
        "default": "0.5",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Optional[str]",
        "default": "'\\\\psi'",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "bcs",
        "type_hint": null,
        "default": "[]",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "a sympy expression for \u03c8; can be scalar or matrix",
      "Ensure psi_fn is a sympy Matrix.",
      "stored with its native shape",
      "capture the shape",
      "Set the display symbol for psi_fn and for the history variable."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 254,
    "signature": "(self, mesh: uw.discretisation.Mesh, psi_fn: Union[uw.discretisation.MeshVariable, sympy.Basic], vtype: uw.VarType, degree: int, continuous: bool, evalf: Optional[bool] = False, theta: Optional[float] = 0.5, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs = [], order = 1, smoothing = 0.0)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "psi_fn",
        "type_hint": "Union[uw.discretisation.MeshVariable, sympy.Basic]",
        "default": null,
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "uw.VarType",
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": null,
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": "Optional[float]",
        "default": "0.5",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Optional[str]",
        "default": "'u'",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "bcs",
        "type_hint": null,
        "default": "[]",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "0.0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "sympy function or mesh variable",
      "meshVariables are required for:",
      "u(t) - evaluation of u_fn at the current time",
      "u*(t) - u_* evaluated from",
      "psi is evaluated/stored at `order` timesteps. We can't"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 552,
    "signature": "(self, mesh: uw.discretisation.Mesh, psi_fn: sympy.Function, V_fn: sympy.Function, vtype: uw.VarType, degree: int, continuous: bool, swarm_degree: Optional[int] = None, swarm_continuous: Optional[bool] = None, varsymbol: Optional[str] = None, verbose: Optional[bool] = False, bcs = [], order = 1, smoothing = 0.0, preserve_moments = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "psi_fn",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      },
      {
        "name": "V_fn",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "uw.VarType",
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": null,
        "description": ""
      },
      {
        "name": "swarm_degree",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "swarm_continuous",
        "type_hint": "Optional[bool]",
        "default": "None",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "bcs",
        "type_hint": null,
        "default": "[]",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "0.0",
        "description": ""
      },
      {
        "name": "preserve_moments",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "meshVariables are required for:",
      "u(t) - evaluation of u_fn at the current time",
      "u*(t) - u_* evaluated from",
      "psi is evaluated/stored at `order` timesteps. We can't",
      "be sure if psi is a meshVariable or a function to be evaluated"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1167,
    "signature": "(self, mesh: uw.discretisation.Mesh, psi_fn: sympy.Function, V_fn: sympy.Function, vtype: uw.VarType, degree: int, continuous: bool, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs = [], order = 1, smoothing = 0.0, fill_param = 3)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "psi_fn",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      },
      {
        "name": "V_fn",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "uw.VarType",
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": null,
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Optional[str]",
        "default": "'u'",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "bcs",
        "type_hint": null,
        "default": "[]",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "0.0",
        "description": ""
      },
      {
        "name": "fill_param",
        "type_hint": null,
        "default": "3",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "create a new swarm to manage here"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1377,
    "signature": "(self, swarm: uw.swarm.Swarm, psi_fn: sympy.Function, vtype: uw.VarType, degree: int, continuous: bool, varsymbol: Optional[str] = 'u', verbose: Optional[bool] = False, bcs = [], order = 1, smoothing = 0.0, step_averaging = 2)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": "uw.swarm.Swarm",
        "default": null,
        "description": ""
      },
      {
        "name": "psi_fn",
        "type_hint": "sympy.Function",
        "default": null,
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "uw.VarType",
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": null,
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Optional[str]",
        "default": "'u'",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "bcs",
        "type_hint": null,
        "default": "[]",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "smoothing",
        "type_hint": null,
        "default": "0.0",
        "description": ""
      },
      {
        "name": "step_averaging",
        "type_hint": null,
        "default": "2",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": false
  },
  {
    "name": "_apply_unit_aware_scaling",
    "kind": "function",
    "file": "src/underworld3/systems/solvers.py",
    "line": 73,
    "signature": "(dt_nondimensional, field, mesh)",
    "parameters": [
      {
        "name": "dt_nondimensional",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "field",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Helper function to apply unit-aware scaling to timestep estimates.\n\nDetects the units of the velocity field and applies appropriate time scaling\nto convert nondimensional timestep to physical time units.\n\nParameters\n----------\ndt_nondimensional : float or np.ndarray\n    The nondimensional timestep estimate\nfield : MeshVariable or SymPy expression (often a Matrix)\n    The velocity field - units are detected from this\nmesh : Mesh\n    The mesh (may have reference to model with time scales)\n\nReturns\n-------\nfloat or UWQuantity\n    Timestep with physical time units if detectable, otherwise nondimensional",
    "harvested_comments": [
      "Extract a component from field if it's a Matrix (common for velocity)",
      "Extract first component: V_fn[0] or V_fn[0,0]",
      "Try to get units from the field expression",
      "Field has units - verify it has time dimension (as expected for velocity)",
      "Get dimensionality: e.g., {'[length]': 1, '[time]': -1} for velocity"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/units.py",
    "line": 57,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_PintHelper",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 166,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize a constitutive model.\n\nParameters\n----------\nunknowns : UnknownSet\n    The solver's unknowns (velocity, pressure, etc.)\nmaterial_name : str, optional\n    A distinguishing name for this material's symbols.\n    If provided, symbols will be subscripted: \u03b7 \u2192 \u03b7_{name}\n    Useful when bundling multiple models in MultiMaterialModel.",
    "harvested_comments": [
      "Define / identify the various properties in the class but leave",
      "the implementation to child classes. The constitutive tensor is",
      "defined as a template here, but should be instantiated via class",
      "properties as required.",
      "We provide a function that converts gradients / gradient history terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2176,
    "signature": "(self, unknowns, material_swarmVariable: IndexSwarmVariable, constitutive_models: list, normalize_levelsets: bool = False)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_swarmVariable",
        "type_hint": "IndexSwarmVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "constitutive_models",
        "type_hint": "list",
        "default": null,
        "description": ""
      },
      {
        "name": "normalize_levelsets",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Parameters\n----------\nunknowns : UnknownSet\n    The solver's authoritative unknowns (:math:`\\mathbf{u}`,\n    :math:`D\\mathbf{F}/Dt`, :math:`D\\mathbf{u}/Dt`).\nmaterial_swarmVariable : IndexSwarmVariable\n    Index variable tracking material distribution on particles.\nconstitutive_models : list of Constitutive_Model\n    Pre-configured constitutive models for each material.\nnormalize_levelsets : bool, optional\n    Whether to normalize level-set functions to enforce partition of unity.\n    Set to True if IndexSwarmVariable does not maintain partition of unity.\n    Default: False (assumes IndexSwarmVariable maintains partition of unity)",
    "harvested_comments": [
      "Validate compatibility before initialization",
      "Ensure model count matches material indices",
      "CRITICAL: Share solver's unknowns with all constituent models",
      "Composite model doesn't have its own material_name - constituents do"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 529,
    "signature": "(self, coordinate_system)",
    "parameters": [
      {
        "name": "coordinate_system",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize geographic coordinate accessor.\n\nParameters\n----------\ncoordinate_system : CoordinateSystem\n    The coordinate system object with GEOGRAPHIC type",
    "harvested_comments": [
      "Cache for coordinate arrays",
      "Set by _compute_coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 989,
    "signature": "(self, coordinate_system)",
    "parameters": [
      {
        "name": "coordinate_system",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize spherical/polar coordinate accessor.\n\nParameters\n----------\ncoordinate_system : CoordinateSystem\n    The coordinate system object with SPHERICAL or CYLINDRICAL2D type",
    "harvested_comments": [
      "2 for polar, 3 for spherical",
      "Cache for coordinate arrays"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 156,
    "signature": "(self, varname = None, mesh = None, num_components = None, vtype = None, degree = 1, continuous = True, varsymbol = None, _register = True, units = None, units_backend = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize MeshVariable (only called for NEW objects).\n\nRetrieves initialization parameters from __new__ and handles DM reconstruction.",
    "harvested_comments": [
      "Only initialize if this is a new object (not returned existing)",
      "Already initialized",
      "Get parameters - either from __new__ (via _init_params) or direct arguments",
      "Parameters from __new__ method",
      "Direct initialization (should not happen with __new__ pattern, but for safety)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 90,
    "signature": "(self, varname: Union[str, list], mesh: 'Mesh', num_components: Union[int, tuple] = None, vtype: Optional['uw.VarType'] = None, degree: int = 1, continuous: bool = True, varsymbol: Union[str, list] = None, persistent: bool = False, units: Optional[str] = None, units_backend: Optional[str] = None, **kwargs)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": "Union[str, list]",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": "Union[int, tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "Optional['uw.VarType']",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Union[str, list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "persistent",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize enhanced mesh variable.\n\nArgs:\n    varname: Variable name\n    mesh: Mesh object\n    num_components: Number of components (1=scalar, 2/3=vector, etc.)\n    vtype: Variable type (optional)\n    degree: Polynomial degree\n    continuous: Whether variable is continuous\n    varsymbol: Symbol for LaTeX representation\n    persistent: Whether to enable persistence features\n    units: Units for this variable (optional)\n    units_backend: Units backend to use ('pint' or 'sympy')\n    **kwargs: Additional arguments passed to base MeshVariable",
    "harvested_comments": [
      "Check if already initialized (to prevent duplicate initialization)",
      "Store configuration FIRST (before any method calls)",
      "Weak reference to avoid circular deps",
      "Create base variable without registration (we handle registration ourselves)",
      "Never let base variable register itself"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 53,
    "signature": "(self, value: Union[float, int, np.ndarray], units: Optional[str] = None)",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Union[float, int, np.ndarray]",
        "default": null,
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize a UWQuantity.\n\nParameters\n----------\nvalue : float, int, or array-like\n    The dimensional value\nunits : str or Pint Unit, optional\n    Units specification",
    "harvested_comments": [
      "Store value as numpy array or scalar",
      "Scalar - store directly",
      "Handle units",
      "Accept both strings and Pint Unit objects",
      "Already a Pint Unit"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/kdtree.py",
    "line": 38,
    "signature": "(self, data, leafsize = 16, **kwargs)",
    "parameters": [
      {
        "name": "data",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "leafsize",
        "type_hint": null,
        "default": "16",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Construct KD-tree from coordinate data.\n\nParameters\n----------\ndata : array-like\n    Coordinate data to build tree from. Can be unit-aware (UnitAwareArray)\n    or plain numpy array. Shape should be (n_points, n_dimensions).\nleafsize : int, optional\n    Number of points at which to switch to brute-force (default 16)\n**kwargs : dict\n    Additional arguments passed to pykdtree.KDTree",
    "harvested_comments": [
      "Import here to avoid circular imports",
      "Check if data has units and store them",
      "Extract raw numpy array for pykdtree (it doesn't understand units)",
      "Get underlying numpy array without unit wrapping",
      "Call parent constructor with raw data"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "KDTree",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 96,
    "signature": "(self, name: str, points: np.ndarray = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "points",
        "type_hint": "np.ndarray",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a fault surface.\n\nArgs:\n    name: Identifier for this fault segment\n    points: (N, 3) array of 3D points defining the fault surface.\n           If None, the fault is empty and must be loaded or\n           have points added later.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "FaultSurface",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 403,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create an empty fault collection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 98,
    "signature": "(self, name: str, surface: 'Surface', size: int = 1, proxy_degree: int = 1, existing: bool = False, units: Optional[str] = None, mask_width: Optional[float] = None, mask_profile: str = 'gaussian')",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "surface",
        "type_hint": "'Surface'",
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "existing",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "mask_width",
        "type_hint": "Optional[float]",
        "default": "None",
        "description": ""
      },
      {
        "name": "mask_profile",
        "type_hint": "str",
        "default": "'gaussian'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a variable on surface vertices.\n\nArgs:\n    name: Variable name (key in pyvista point_data)\n    surface: Parent Surface object\n    size: Number of components per vertex (1 for scalar, 3 for vector)\n    proxy_degree: Degree of proxy MeshVariable for .sym access\n    existing: If True, wraps existing point_data (for loading from VTK)\n    units: Optional units for this variable (e.g., \"Pa\", \"m/s\")\n    mask_width: Width for distance-based mask (enables .mask property)\n    mask_profile: Profile for mask function (\"step\", \"linear\", \"gaussian\", \"smoothstep\")",
    "harvested_comments": [
      "Create array in pyvista's point_data (unless wrapping existing)",
      "Proxy MeshVariable for .sym access (created lazily)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 355,
    "signature": "(self, name: str, mesh: 'Mesh' = None, control_points: np.ndarray = None, symbol: str = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": "None",
        "description": ""
      },
      {
        "name": "control_points",
        "type_hint": "np.ndarray",
        "default": "None",
        "description": ""
      },
      {
        "name": "symbol",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a surface.\n\nArgs:\n    name: Identifier for this surface\n    mesh: Computational mesh (required for .sym access and distance field)\n    control_points: (N, 3) array of 3D points defining the surface.\n                   If None, the surface is empty and must be loaded or\n                   have points set later.\n    symbol: Short LaTeX-friendly symbol for math display (e.g., \"F\" for \"fault\").\n           If None, defaults to first letter of name capitalized.\n           Used in expressions like d_F instead of {surf_fault_distance}.",
    "harvested_comments": [
      "Register with mesh for adaptation notifications",
      "Math symbol for clean LaTeX display",
      "Default: first letter capitalized (e.g., \"main_fault\" -> \"M\")",
      "Extract first letter, capitalize",
      "Level 1: Control points (primary for evolving surfaces)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1275,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create an empty surface collection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 119,
    "signature": "(self, name: Optional[str] = None, **kwargs)",
    "parameters": [
      {
        "name": "name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize a new Model instance.\n\nParameters:\n-----------\nname : str, optional\n    Human-readable name for this model instance\n**kwargs : dict\n    Additional arguments for Pydantic BaseModel",
    "harvested_comments": [
      "Handle name generation before calling super().__init__",
      "Set initial state if not provided",
      "Transition through initializing to configured",
      "Auto-register as default model if no default exists",
      "This ensures the first user-created model becomes default automatically"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_dm_stack_bcs",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 448,
    "signature": "(dm, boundaries, stacked_bc_label_name)",
    "parameters": [
      {
        "name": "dm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "boundaries",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "stacked_bc_label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Load this up on the stack"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__cinit__",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 59,
    "signature": "def __cinit__( self,\n                   points_input not None:   numpy.ndarray ) :",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__dealloc__",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 81,
    "signature": "def __dealloc__(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_convert_coords_to_tree_units",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 92,
    "signature": "def _convert_coords_to_tree_units(self, coords):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 483,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 709,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 925,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_plastic_effective_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1279,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# First order ...",
      ".rewrite(sympy.Piecewise)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1479,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "super()._object_viewer()",
      "## Viscous deformation\"))",
      "### Elastic deformation\"))",
      "### Plastic deformation\"))",
      "# Todo: add all the other properties in here"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1645,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1716,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "AnisotropicDiffusionModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1794,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GenericFluxModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1934,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2142,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2342,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_reset",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 231,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 248,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 335,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 763,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance",
      "# Todo: add all the other properties in here"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1390,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "## Viscous deformation\"))",
      "# If elasticity is active:",
      "### Elastic deformation\"))",
      "If plasticity is active",
      "### Plastic deformation\"))"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1525,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1670,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 88,
    "signature": "(cls, index, system, pretty_str = None, latex_str = None, mesh = None, axis_index = None)",
    "parameters": [
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "system",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "pretty_str",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "latex_str",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "axis_index",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Create as a BaseScalar with the same index and system"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 248,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1237,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_DS",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2095,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Build this from the PETScDS rather than the SWARM",
      "self._index.build_index()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2118,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "Use raw internal array for KD-tree construction (avoid unit-aware wrapping)",
      "for face in range(cell_num_faces):",
      "points = self.dm.getTransitiveClosure(cell_faces[face])[0][",
      "-face_num_points:"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_PIC",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2200,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Bootstrapping - the kd-tree is needed to build the index but",
      "# the index is also used in the kd-tree.",
      "Create a temp swarm which we'll use to populate particles",
      "at gauss points. These will then be used as basis for",
      "kd-tree indexing back to owning cells."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_domain_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2771,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1299,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_setup_ds",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1344,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "self.clean_name ## Filling up the options database",
      "only active if discontinuous",
      "Check if this is the first field or if we need to rebuild the DM",
      "(needed to ensure Section is properly synchronized with field list)",
      "DM already has fields - need to rebuild to sync Section"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_set_vec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1436,
    "signature": "(self, available)",
    "parameters": [
      {
        "name": "available",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "not sure if required, but to be sure.",
      "This is set for checkpointing."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1530,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__cinit__",
    "kind": "method",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 71,
    "signature": "def __cinit__(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__dealloc__",
    "kind": "method",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 191,
    "signature": "def __dealloc__(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/function/_dminterp_wrapper.pyx",
    "line": 203,
    "signature": "def __repr__(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_latex",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 66,
    "signature": "def _latex(self, printer, exp=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 131,
    "signature": "def __new__(cls,\n                name     : str,\n                meshvar  : underworld3.discretisation.MeshVariable,\n                vtype    : underworld3.VarType,\n                component: Union[int, tuple] = 0,\n                data_loc: int = None,\n                *args, **options):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_collect_mesh_varfns",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 182,
    "signature": "def _collect_mesh_varfns(mesh):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_lambdify_and_evaluate",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 203,
    "signature": "def _lambdify_and_evaluate(expr, coords, interpolated_results, coord_sys=None, mesh=None):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_project_to_work_variable",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 458,
    "signature": "def _project_to_work_variable(expr, mesh, smoothing=1e-6):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_clement_to_work_variable",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 539,
    "signature": "def _clement_to_work_variable(expr, mesh, derivfns):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_dmswarm_get_migrate_type",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 1265,
    "signature": "def _dmswarm_get_migrate_type(sdm):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_dmswarm_set_migrate_type",
    "kind": "method",
    "file": "src/underworld3/function/_function.pyx",
    "line": 1275,
    "signature": "def _dmswarm_set_migrate_type(sdm, mtype:PETsc.DMSwarm.MigrateType):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_ccode",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 27,
    "signature": "def _ccode(self, printer):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_eval_evalf",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 47,
    "signature": "def _eval_evalf(self,prec):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_eval_evalf",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 52,
    "signature": "def _eval_evalf(self,prec):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_eval_evalf",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 65,
    "signature": "def _eval_evalf(self,prec):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_eval_evalf",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 70,
    "signature": "def _eval_evalf(self,prec):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_eval_evalf",
    "kind": "method",
    "file": "src/underworld3/function/analytic.pyx",
    "line": 83,
    "signature": "def _eval_evalf(self,prec):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 583,
    "signature": "(cls, name, *args, **kwargs)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "If the expression already exists, return it",
      "Check both dicts for name collisions",
      "Check ephemeral dict - need to look for any key starting with this name",
      "Determine unique ID for disambiguation",
      "When _unique_name_generation=True, ALWAYS use instance_no as _uw_id"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__lt__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 681,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__le__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 688,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__gt__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 695,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__ge__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 702,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__eq__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 709,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__ne__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 716,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 339,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 366,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultSurface",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 644,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 301,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": null,
    "harvested_comments": [
      "Get raw data length to avoid triggering UnitAwareArray"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1237,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1550,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": false
  },
  {
    "name": "__enter__",
    "kind": "method",
    "file": "src/underworld3/mpi.py",
    "line": 396,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "call_pattern",
    "is_public": false
  },
  {
    "name": "__exit__",
    "kind": "method",
    "file": "src/underworld3/mpi.py",
    "line": 402,
    "signature": "(self, *args)",
    "parameters": [
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "call_pattern",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/parameters.py",
    "line": 317,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ParameterRegistry",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 958,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_proxy_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1005,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "release if defined"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2048,
    "signature": "(self, index)",
    "parameters": [
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_particle_coordinates",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2705,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3952,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_get_map",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3981,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "generate tree if not avaiable",
      "get or generate map",
      "we can't use numpy arrays directly as keys in python dicts, so",
      "we'll use `xxhash` to generate a hash of array.",
      "this shouldn't be an issue performance wise but we should test to be"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1018,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": false
  },
  {
    "name": "_get_map",
    "kind": "method",
    "file": "src/underworld3/swarms/pic_swarm.py",
    "line": 1046,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "generate tree if not avaiable",
      "get or generate map",
      "we can't use numpy arrays directly as keys in python dicts, so",
      "we'll use `xxhash` to generate a hash of array.",
      "this shouldn't be an issue performance wise but we should test to be"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "PICSwarm",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 121,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Display the primary variable",
      "Display the history variable using the different symbol."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Symbolic",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 335,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance",
      "display(Latex(r\"$\\quad\\psi = $ \" + self.psi._repr_latex_()))",
      "r\"$\\quad\\Delta t_{\\textrm{phys}} = $ \"",
      "+ sympy.sympify(self.dt_physical)._repr_latex_()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 701,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SemiLagrangian",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1214,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 1418,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Lagrangian_Swarm",
    "is_public": false
  },
  {
    "name": "_units_view",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 201,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display units registry information following the established view() pattern.",
    "harvested_comments": [
      "# Units Registry",
      "## Common Units Examples:",
      "Create quantities",
      "Set model reference quantities",
      "Fallback for non-Jupyter environments"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_apply_scaling",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 471,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Internal context manager - DEPRECATED, use use_nondimensional_scaling() instead.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_is_scaling_active",
    "kind": "function",
    "file": "src/underworld3/__init__.py",
    "line": 482,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Internal check - DEPRECATED, use is_nondimensional_scaling_active() instead.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_dm_unstack_bcs",
    "kind": "function",
    "file": "src/underworld3/adaptivity.py",
    "line": 472,
    "signature": "(dm, boundaries, stacked_bc_label_name)",
    "parameters": [
      {
        "name": "dm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "boundaries",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "stacked_bc_label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack boundary labels to the list of names",
    "harvested_comments": [
      "Clear labels just in case",
      "ValueError if mismatch"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_q",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 418,
    "signature": "(self, ddu)",
    "parameters": [
      {
        "name": "ddu",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generic flux term",
    "harvested_comments": [
      "tensor multiplication"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_reset",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 461,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flags that the expressions in the consitutive tensor need to be refreshed and also that the\nsolver will need to rebuild the stiffness matrix and jacobians",
    "harvested_comments": [
      "Propagate is_setup flag to solver if we have a reference"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 475,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the identity tensor of appropriate rank (e.g. for projections)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_q",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 622,
    "signature": "(self, edot)",
    "parameters": [
      {
        "name": "edot",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Apply constitutive tensor to strain rate to compute stress.",
    "harvested_comments": [
      "tensor multiplication"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 661,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [
      "Check for tensor forms first (Mandel matrix or full rank-4 tensor)",
      "Mandel form of constitutive tensor",
      "Full rank-4 tensor",
      "Scalar viscosity case",
      "UWexpression has __getitem__ from MathematicalMixin, making it Iterable,"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1336,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [
      "inner_self = self.Parameters",
      "CRITICAL: Use .sym property to avoid UWexpression array corruption issues",
      "See ViscousFlowModel._build_c_tensor() for detailed explanation"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1619,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Build isotropic diffusivity tensor from scalar.",
    "harvested_comments": [
      "Scalar diffusivity case",
      "Use element-wise construction (consistent with ViscousFlowModel pattern)",
      "to handle UWexpression properly and preserve for JIT unwrapping",
      "Diagonal element: kappa",
      "Wrap if bare UWexpression to avoid Iterable check failure"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1711,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constructs the anisotropic (diagonal) tensor from the diffusivity vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "AnisotropicDiffusionModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1908,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a permeability function",
    "harvested_comments": [
      "Scalar permeability case",
      "Use element-wise construction (consistent with ViscousFlowModel and DiffusionModel)",
      "to handle UWexpression properly and preserve for JIT unwrapping",
      "Diagonal element: kappa",
      "Wrap if bare UWexpression to avoid Iterable check failure"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2077,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect two viscosity functions\nand a sympy row-matrix that describes the director components n_{i}",
    "harvested_comments": [
      "Use .sym to get sympy expressions from Parameters",
      "Use element-wise construction (same pattern as ViscousFlowModel).",
      "UWexpression has __getitem__ from MathematicalMixin, making it appear",
      "\"Iterable\" to SymPy's array multiplication operator, which rejects it.",
      "Element-wise construction avoids this by creating Mul objects that"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "_setup_shared_unknowns",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2218,
    "signature": "(self, constitutive_models, unknowns)",
    "parameters": [
      {
        "name": "constitutive_models",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Ensure all constituent models share the solver's authoritative unknowns.\nThis is critical for proper stress history management.",
    "harvested_comments": [
      "Share solver's unknowns - this gives access to composite D(F)/Dt history",
      "Validation: Ensure sharing worked correctly",
      "For elastic models, verify DFDt access"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_validate_model_compatibility",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2236,
    "signature": "(self, models: list) -> bool",
    "parameters": [
      {
        "name": "models",
        "type_hint": "list",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Ensure all constituent models are compatible for flux averaging.\n\nChecks:\n- Same u_dim (scalar vs vector problem compatibility)\n- Same spatial dimension (2D/3D consistency)\n- Compatible flux tensor shapes\n- All models properly initialized",
    "harvested_comments": [
      "Validate model is properly initialized"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 240,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the identity tensor of appropriate rank (e.g. for projections)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 314,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1301,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1516,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a diffusivity function",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models_new.py",
    "line": 1636,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect two viscosity functions\nand a sympy matrix that describes the director components n_{i}",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "__eq__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 107,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Equal to the original BaseScalar from the SAME coordinate system.\n\nThis is the key to making sympy.diff() work - when SymPy checks if\nthe differentiation variable matches symbols in the expression,\nthis makes UWCoordinate match the original BaseScalar.\n\nIMPORTANT: We only match BaseScalars from the SAME mesh's coordinate\nsystem using object identity (`is`), not name comparison. This prevents\ncross-mesh coordinate pollution where coordinates from different meshes\nwould be treated as equal due to having the same name \"N.x\".",
    "harvested_comments": [
      "DON'T fall back to BaseScalar.__eq__ which compares by name!",
      "This caused cross-mesh coordinate pollution (issue discovered 2025-12-15)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "__hash__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 129,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Hash must match _original_base_scalar's hash for SymPy compatibility.\n\nSince __eq__ returns True when comparing to the original BaseScalar,\nwe MUST return the same hash (Python requirement: a == b \u2192 hash(a) == hash(b)).\n\nThis is critical for SymPy's differentiation to work correctly -\nsympy.diff() uses hash-based lookup to find matching symbols.\n\nNote: Cross-mesh coordinate collision is prevented by __eq__ checking\nobject identity of _original_base_scalar, not by different hashes.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_numpycode",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 144,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "NumPy code generation for lambdify().\n\nReturns a unique dummy name that lambdify will map to array columns.\nUses the coordinate's internal index to generate a consistent name.",
    "harvested_comments": [
      "Use the short coordinate name (x, y, z) based on axis index"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_lambdacode",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 155,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Lambda code generation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_pythoncode",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 160,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Python code generation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_base_scalar",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 203,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Backward compatibility: return the original BaseScalar.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_ccodestr",
    "kind": "property",
    "file": "src/underworld3/coordinates.py",
    "line": 224,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate C code string to the original BaseScalar.\n\nThe mesh sets _ccodestr on the original N.x, N.y, N.z objects\nfor JIT code generation (e.g., \"petsc_x[0]\", \"petsc_x[1]\").\nUWCoordinate must expose the same attribute for JIT to work.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_ccodestr",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 235,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Allow setting _ccodestr (propagates to original BaseScalar).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_ccode",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 239,
    "signature": "(self, printer, **kwargs)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "C code representation for JIT compilation.\n\nThe SymPy CCodePrinter looks for this method on symbols.\nWe delegate to the original BaseScalar's _ccodestr.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_latex",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 251,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "LaTeX representation for SymPy printing.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWCoordinate",
    "is_public": false
  },
  {
    "name": "_invalidate_cache",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 548,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mark coordinate cache as invalid (call when mesh coordinates change).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "_compute_coordinates",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 552,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Compute geographic coordinates from Cartesian mesh coordinates.",
    "harvested_comments": [
      "Get raw Cartesian coordinates from DM (avoids unit wrapping)",
      "The mesh stores nondimensional coords when units are active",
      "Get ellipsoid parameters",
      "Use nondimensional if available (when mesh created with units)",
      "Otherwise use raw km values"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 653,
    "signature": "(self, idx)",
    "parameters": [
      {
        "name": "idx",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Access symbolic geographic coordinates.\n\nReturns:\n    \u03bb_lon, \u03bb_lat, \u03bb_d: Symbolic coordinates for use in equations",
    "harvested_comments": [
      "mesh.geo[:]"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 866,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "String representation showing available coordinates and basis vectors.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GeographicCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "_invalidate_cache",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1008,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mark coordinate cache as invalid (call when mesh coordinates change).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "_compute_coordinates",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1012,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Compute spherical/polar coordinates from Cartesian mesh coordinates.",
    "harvested_comments": [
      "Get Cartesian coordinates",
      "2D polar: (x, y) \u2192 (r, \u03b8)",
      "3D spherical: (x, y, z) \u2192 (r, \u03b8, \u03c6)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1100,
    "signature": "(self, idx)",
    "parameters": [
      {
        "name": "idx",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Access symbolic spherical/polar coordinates.\n\nReturns\n-------\ntuple or scalar\n    For 3D: r, \u03b8, \u03c6 symbolic coordinates\n    For 2D: r, \u03b8 symbolic coordinates",
    "harvested_comments": [
      "mesh.spherical[:]"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1281,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "String representation showing available coordinates and basis vectors.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SphericalCoordinateAccessor",
    "is_public": false
  },
  {
    "name": "_apply_units_scaling",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1805,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mark coordinate system as scaled if model has units.",
    "harvested_comments": [
      "Get the model from the mesh",
      "Fall back to default model if mesh doesn't have one",
      "Check if the model has units scaling enabled",
      "No scaling to apply",
      "Get fundamental scales from the model"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1861,
    "signature": "(self, idx)",
    "parameters": [
      {
        "name": "idx",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X[0] for x-coordinate access.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__iter__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1865,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Support x, y = mesh.X unpacking.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__len__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1869,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Support len(mesh.X).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_sympy_",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1947,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Tell SymPy how to convert this object to a SymPy expression.\n\nNote: Uses _sympy_() protocol (not _sympify_()) for SymPy 1.14+ compatibility.\nThis is required for proper symbolic algebra in strict mode (matrix operations).\n\nThis enables CoordinateSystem to work seamlessly with SymPy operations\nlike diff, jacobian, and arithmetic operations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__sympy__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1959,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Alternative SymPy conversion protocol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__getattr__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 1991,
    "signature": "(self, name)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Delegate SymPy-specific attributes to the underlying symbolic matrix.\n\nThis allows CoordinateSystem to be used transparently in SymPy operations\nby forwarding attribute access to _X when the attribute doesn't exist\non CoordinateSystem itself.\n\nNote: When properties like 'geo' or 'spherical' raise AttributeError\n(because the coordinate system doesn't support them), Python falls\nthrough to __getattr__. We detect this and re-invoke the property\nto get the helpful error message.",
    "harvested_comments": [
      "Prevent infinite recursion for _X access",
      "For coordinate accessor properties, re-invoke the property to get",
      "the helpful error message (they raise AttributeError with guidance)",
      "Access the property descriptor directly to get its error message",
      "Try to get the attribute from the underlying symbolic matrix"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__add__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2024,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X + other.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__radd__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2028,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support other + mesh.X.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__sub__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2032,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X - other.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__rsub__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2036,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support other - mesh.X.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__mul__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2040,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X * other.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__rmul__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2044,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support other * mesh.X.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__truediv__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2048,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X / other.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__rtruediv__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2052,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support other / mesh.X.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__pow__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2056,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Support mesh.X ** other.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "__neg__",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2060,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Support -mesh.X.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_cartesian_to_natural_coords",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2528,
    "signature": "(self, cartesian_coords)",
    "parameters": [
      {
        "name": "cartesian_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert Cartesian coordinates to natural coordinate system.\n\nParameters\n----------\ncartesian_coords : numpy.ndarray\n    Array of Cartesian coordinates (N_points, dim)\n\nReturns\n-------\nnumpy.ndarray\n    Array of natural coordinates (N_points, dim)",
    "harvested_comments": [
      "For Cartesian, natural coordinates are the same as Cartesian",
      "Convert (x, y) to (r, theta)",
      "Convert (x, y, z) to (r, theta, z)",
      "Convert (x, y, z) to (r, theta, phi)",
      "colatitude (0 to pi)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_create_cartesian_profile",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2622,
    "signature": "(self, profile_type, **params)",
    "parameters": [
      {
        "name": "profile_type",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**params",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create profiles for Cartesian coordinate systems",
    "harvested_comments": [
      "Horizontal line at specified y-position",
      "Same for Cartesian",
      "Vertical line at specified x-position",
      "Diagonal line from start to end point"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_create_cylindrical_profile",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2695,
    "signature": "(self, profile_type, **params)",
    "parameters": [
      {
        "name": "profile_type",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**params",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create profiles for cylindrical coordinate systems",
    "harvested_comments": [
      "Radial line at specified angle",
      "Angle in radians",
      "Convert to Cartesian coordinates",
      "Natural coordinates",
      "Tangential (circular arc) at specified radius"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_create_spherical_profile",
    "kind": "method",
    "file": "src/underworld3/coordinates.py",
    "line": 2763,
    "signature": "(self, profile_type, **params)",
    "parameters": [
      {
        "name": "profile_type",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**params",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create profiles for spherical coordinate systems",
    "harvested_comments": [
      "Radial line at specified theta, phi",
      "Colatitude (0 to pi)",
      "Azimuth (-pi to pi)",
      "Convert to Cartesian coordinates",
      "Natural coordinates"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "CoordinateSystem",
    "is_public": false
  },
  {
    "name": "_from_gmsh",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 47,
    "signature": "(filename, comm = None, markVertices = False, useRegions = True, useMultipleTags = True)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a Gmsh .msh file from `filename`.\n\n:kwarg comm: Optional communicator to build the mesh on (defaults to\n    COMM_WORLD).",
    "harvested_comments": [
      "# NOTE: - this should be smart enough to serialise the msh conversion",
      "# and then read back in parallel via h5.  This is currently done",
      "# by every gmesh mesh",
      "This option allows objects to be in multiple physical groups",
      "Rather than just the first one found."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_from_plexh5",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 117,
    "signature": "(filename, comm = None, return_sf = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_sf",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a dmplex .h5 file from `filename` provided.\n\ncomm: Optional communicator to build the mesh on (defaults to\nCOMM_WORLD).",
    "harvested_comments": [
      "h5plex = PETSc.DMPlex().createFromFile(filename, comm=comm)",
      "Do this as well"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_deform_mesh",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1241,
    "signature": "(self, new_coords: numpy.ndarray, verbose = False)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method will update the mesh coordinates and reset any cached coordinates in\nthe mesh and in equation systems that are registered on the mesh.\n\nThe coord array that is passed in should match the shape of self.data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_legacy_access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1258,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying mesh variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "Invalidate DMInterpolation cache when DM structure changes",
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "create & set vec"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_var",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2035,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [
      "if array already created, return."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_basis",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2050,
    "signature": "(self, degree, continuous)",
    "parameters": [
      {
        "name": "degree",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2256,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each mesh face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the plane\ndefined by a face (i.e. same side or other side as the cell centroid). If we are inside\nfor all faces in a convex polyhedron, then we are inside the cell.\n\nInternal Coordinate System Access Pattern\n------------------------------------------\nThis method uses `self._coords` (raw PETSc array) instead of `self.data`\nor `self.X.coords` (unit-wrapped properties) for performance and correctness:\n\n1. **Guard at boundaries**: External interfaces use unit-aware properties\n2. **Raw access internally**: Internal geometric calculations use `self._coords`\n3. **Performance**: Avoids UnitAwareArray overhead in tight loops\n4. **Correctness**: Prevents unit conversion issues in geometric operations\n\nThis is the recommended pattern for internal mesh operations that manipulate\ncoordinates directly.",
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "All elements in our mesh are a single type",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Compute face normal from point coordinates (already plain numpy arrays)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_test_if_points_in_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2351,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test",
    "harvested_comments": [
      "Internal version - points assumed to already be in model units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_local_boundary_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2390,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each boundary-defining face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the domain.\nWe cannot ensure convexity, so this is approximate when close to the boundary",
    "harvested_comments": [
      "Use raw array for internal calculations",
      "3D simplex case (probably also OK for hexes)",
      "Control points near centroid",
      "Control points closer to face nodes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_closest_local_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2573,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Internal version - coords assumed to already be in model units",
      "Create index if required",
      "We need to filter points that lie outside the mesh but",
      "still are allocated a nearby element by this distance-only check.",
      "Part 2 - try to find the lost points by walking nearby cells"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_sizes",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2718,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Obtain the (local) mesh radii and centroids using kdtree distances\nThis routine is called when the mesh is built / rebuilt",
    "harvested_comments": [
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2752,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Obtain and cache the (local) mesh centroids using underworld swarm technology.\nThis routine is called when the mesh is built / rebuilt\n\nThe global cell number corresponding to a centroid is (supposed to be)\nself.dm.getCellNumbering().array.min() + index",
    "harvested_comments": [
      ") = petsc_discretisation.petsc_fvm_get_local_cell_sizes(self)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_increment_mesh_version",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2906,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Manually increment mesh version to notify swarms of coordinate changes.\nThis is called automatically when mesh.points is modified, but can be\ncalled manually if coordinates are changed through other means.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 102,
    "signature": "(cls, varname: Union[str, list], mesh: 'Mesh', num_components: Union[int, tuple] = None, vtype: Optional['uw.VarType'] = None, degree: int = 1, continuous: bool = True, varsymbol: Union[str, list] = None, _register: bool = True, units: Optional[str] = None, units_backend: Optional[str] = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": "Union[str, list]",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": "Union[int, tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "Optional['uw.VarType']",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Union[str, list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create or return existing MeshVariable instance.\n\nHandles object uniqueness and mesh DM state management.",
    "harvested_comments": [
      "# Check if already defined (return existing object)",
      "NOTE: DM reconstruction is now handled in _setup_ds() - no snapshotting needed here",
      "Create new instance",
      "Store parameters for __init__"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_variable_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 455,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for variable data.\nFollows the same pattern as mesh.points implementation.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Create NDArray_With_Callback (following mesh._points pattern)",
      "Allow operations like existing arrays",
      "Single callback function (following mesh_update_callback pattern)",
      "Only act on data-changing operations (following mesh.points pattern)",
      "Prevent recursion by checking if we're already in a callback"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_flat_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 518,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for backward-compatible flat data.\nReturns data in shape (-1, num_components) using pack_raw/unpack_raw methods.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Use unpack_raw to get flat format (-1, num_components)",
      "Create NDArray_With_Callback for flat data",
      "Allow operations like existing arrays",
      "Callback for flat data format",
      "Only act on data-changing operations"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 580,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This will substitute specific information about this object",
    "harvested_comments": [
      "feedback on this instance"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_replace_from_adapted_mesh",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1448,
    "signature": "(self, temp_var, adapted_mesh)",
    "parameters": [
      {
        "name": "temp_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "adapted_mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Replace internal storage after mesh adaptation.\n\nCalled by mesh.adapt() to update this variable's internal PETSc\nstructures after the mesh's discretization has changed. The data\nhas already been interpolated to temp_var; this method copies that\ndata into this variable's updated storage.\n\nParameters\n----------\ntemp_var : MeshVariable\n    A temporary variable on the adapted mesh containing the\n    interpolated data for this variable.\nadapted_mesh : Mesh\n    The mesh object (same object, but with updated internal DM).\n\nNotes\n-----\nThis is an internal method called by mesh.adapt(). Users should\nnot need to call this directly.\n\nAfter this method returns, all user references to this variable\nremain valid and contain the interpolated data on the adapted mesh.",
    "harvested_comments": [
      "Destroy old PETSc vectors",
      "The mesh reference is still valid (same object, updated internals)",
      "But we need to find/create our field on the new DM",
      "Check if our field exists on the new DM",
      "Need to add field to new DM (this happens if adapt() didn't pre-create variables)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1593,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create array view of canonical data using appropriate conversion strategy.\n\nStrategy depends on variable complexity:\n- Scalars/Vectors: Simple reshape operations\n- 2D+ Tensors: Complex pack/unpack operations\n\nReturns\n-------\nArrayView\n    Array-like object that delegates changes back to canonical data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_is_simple_variable",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1611,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this is a simple scalar/vector variable (not a complex tensor)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_simple_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1615,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for scalars/vectors using simple reshape operations",
    "harvested_comments": [
      "Simple reshape: (-1, num_components) -> (N, a, b)",
      "For simple variables, reshape to (N, a, b) format",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_tensor_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1943,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for complex tensors using pack/unpack operations",
    "harvested_comments": [
      "Use complex pack/unpack for tensor layouts",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray",
      "Get variable units (needed for both branches)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_canonical_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2274,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create the single canonical data array with PETSc synchronization for MeshVariable.\nThis is the ONLY method that creates arrays with PETSc callbacks.\n\nHandles mesh-specific requirements like locking and ghost value synchronization.\n\nReturns\n-------\nNDArray_With_Callback\n    Canonical array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Ensure PETSc vector is available",
      "Get direct access to PETSc vector in packed format",
      "Create NDArray_With_Callback with proper shape and data",
      "Single canonical callback for PETSc synchronization",
      "Only act on data-changing operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_dimensionalise_stat",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2350,
    "signature": "(self, value: Union[float, tuple]) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Union[float, tuple]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "Helper to dimensionalise statistical values using uw.dimensionalise().\n\nTakes non-dimensional value(s) from PETSc and converts to dimensional\nform using the variable's units and model reference quantities.\n\nParameters\n----------\nvalue : float or tuple\n    Non-dimensional value(s) from PETSc\n\nReturns\n-------\nfloat, tuple, or UWQuantity\n    Dimensionalised value(s) if units are enabled, else unchanged",
    "harvested_comments": [
      "Check if units mode is enabled",
      "Backward compatible - no units mode or variable has no units",
      "Extract dimensionality from units",
      "self.units is already a Pint Unit object with .dimensionality attribute",
      "Pint Unit object - extract dimensionality directly"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_scalar_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2658,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for scalar variables (original implementation).",
    "harvested_comments": [
      "Now returns value directly, not tuple",
      "Now returns value directly, not tuple"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_vector_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2682,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for vector variables using magnitude.",
    "harvested_comments": [
      "Create temporary scalar variable for magnitude",
      "Compute magnitude: |v| = sqrt(v\u00b7v)",
      "Get scalar stats on magnitude",
      "Update with vector-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_tensor_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2720,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for tensor variables using Frobenius norm.",
    "harvested_comments": [
      "Create temporary scalar variable for Frobenius norm",
      "Compute Frobenius norm: ||A||_F = sqrt(sum(A_ij^2))",
      "Get scalar stats on Frobenius norm",
      "Update with tensor-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 66,
    "signature": "(cls, varname, mesh, *args, **kwargs)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Custom __new__ to ensure proper initialization and registration.",
    "harvested_comments": [
      "Create the instance",
      "Perform early registration to override any base variable registration",
      "Register the wrapper immediately (this will overwrite any base variable registration)",
      "Store reference for later use in __init__"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_setup_registration",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 197,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Register with default model, replacing any existing registration from base variable.",
    "harvested_comments": [
      "All variables register with default model",
      "Force registration of wrapper, even if base variable registered itself",
      "Use either the early name (from __new__) or the processed name (from base variable)",
      "This will overwrite any existing registration",
      "Auto-derive scaling coefficient if model has reference quantities"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_auto_derive_scaling_coefficient",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 213,
    "signature": "(self, model)",
    "parameters": [
      {
        "name": "model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Automatically derive scaling coefficient from model's reference quantities.",
    "harvested_comments": [
      "Silently skip if module not available or model incomplete"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_setup_persistence_features",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 229,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Setup additional persistence capabilities for persistent variables.",
    "harvested_comments": [
      "Store qualified name for later reference (for persistent variables)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_lvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 380,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Local PETSc vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_gvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 385,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Global PETSc vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_set_vec",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 400,
    "signature": "(self, available = True)",
    "parameters": [
      {
        "name": "available",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize PETSc vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 579,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Enhanced representation showing persistence and units info.",
    "harvested_comments": [
      "Add persistence info",
      "Add units info"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "__str__",
    "kind": "method",
    "file": "src/underworld3/discretisation/enhanced_variables.py",
    "line": 593,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "String representation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "EnhancedMeshVariable",
    "is_public": false
  },
  {
    "name": "_is_enabled",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 48,
    "signature": "(self) -> bool",
    "parameters": [],
    "returns": "bool",
    "existing_docstring": "Check if caching is enabled.",
    "harvested_comments": [
      "Check mesh flag (default: True)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": false
  },
  {
    "name": "_hash_coords",
    "kind": "method",
    "file": "src/underworld3/function/dminterpolation_cache.py",
    "line": 109,
    "signature": "(self, coords: np.ndarray) -> int",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "np.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Fast coordinate hashing for cache lookups.\n\nUses xxhash for speed (already used in old caching system).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DMInterpolationCache",
    "is_public": false
  },
  {
    "name": "_unwrap_atom",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 76,
    "signature": "(atom, mode = 'nondimensional')",
    "parameters": [
      {
        "name": "atom",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mode",
        "type_hint": null,
        "default": "'nondimensional'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract the value from a single atom based on mode.\n\nArgs:\n    atom: UWexpression, UWQuantity, UWCoordinate, or other symbol\n    mode: 'nondimensional' - use .data for ND values (JIT/evaluate)\n          'dimensional' - use .value for display\n          'symbolic' - use .sym for symbolic substitution\n\nReturns:\n    The unwrapped value (float, sympy.Number, or sympy expression)",
    "harvested_comments": [
      "UWCoordinate: always unwrap to BaseScalar (placeholder for evaluation)",
      "UWexpression",
      "User display: show dimensional value",
      "JIT/evaluate: non-dimensionalize if scaling active",
      "Recursively unwrap to get inner expression"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_unwrap_expression_once",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 132,
    "signature": "(expr, mode = 'nondimensional')",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mode",
        "type_hint": null,
        "default": "'nondimensional'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Single substitution pass over all UW atoms in an expression.\n\nUses free_symbols for reliable iteration (avoids issues with atoms()).\n\nArgs:\n    expr: SymPy expression possibly containing UW atoms\n    mode: See _unwrap_atom\n\nReturns:\n    Expression with UW atoms substituted",
    "harvested_comments": [
      "Handle non-expression types directly",
      "Unwrap the UWexpression itself first",
      "Build substitution dict for all UW atoms"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_unwrap_expressions",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 325,
    "signature": "(fn, keep_constants = True, return_self = True)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "keep_constants",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "return_self",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Main unwrapping logic for JIT compilation.\n\nDEPRECATED: Use unwrap_expression(fn, mode='nondimensional') instead.\nThis function is preserved for backward compatibility.",
    "harvested_comments": [
      "Use unified implementation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_unwrap_for_compilation",
    "kind": "function",
    "file": "src/underworld3/function/expressions.py",
    "line": 336,
    "signature": "(fn, keep_constants = True, return_self = True)",
    "parameters": [
      {
        "name": "fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "keep_constants",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "return_self",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "INTERNAL ONLY: Unwrap UW expressions to pure SymPy for JIT compilation.\n\nDEPRECATED: Use unwrap_expression(fn, mode='nondimensional') instead.",
    "harvested_comments": [
      "Handle UWDerivativeExpression specially"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_hashable_content",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 642,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Include _uw_id in hash so symbols with same name but different IDs are distinct.\n\nThis follows the same pattern as sympy.Dummy which uses dummy_index.\nWhen _uw_id is None, symbols match by name alone (shared identity).\nWhen _uw_id is set, symbols with same name but different IDs are distinct.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__getnewargs_ex__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 655,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Support pickling by including _uw_id in reconstruction args.",
    "harvested_comments": [
      "Return args and kwargs needed to reconstruct this symbol"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_latex",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 700,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Custom LaTeX representation using _display_name.\n\nThis method is called by SymPy's LaTeX printer to get the\nrepresentation of this symbol. By overriding it, we can\ncontrol how the expression appears in LaTeX output without\nchanging its symbolic identity.\n\nParameters\n----------\nprinter : LatexPrinter\n    The SymPy LaTeX printer instance (not used, but required by protocol).\n\nReturns\n-------\nstr\n    The LaTeX representation of this expression.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_sympystr",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 721,
    "signature": "(self, printer)",
    "parameters": [
      {
        "name": "printer",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Custom string representation using _display_name.\n\nThis method is called by SymPy's string printer to get the\nrepresentation of this symbol. Like _latex(), this allows\ncustomizing display without affecting identity.\n\nParameters\n----------\nprinter : StrPrinter\n    The SymPy string printer instance (not used, but required by protocol).\n\nReturns\n-------\nstr\n    The string representation of this expression.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_compute_nondimensional_value",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 867,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Internal: compute the non-dimensional value from the wrapped object.\n\nThis is the machinery that .data uses. Named explicitly to be self-documenting.",
    "harvested_comments": [
      "TRANSPARENT CONTAINER: Derive from _sym (the wrapped object)",
      "Delegate to wrapped object's .data",
      "Fallback to dimensional value"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_sympy_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1027,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy protocol - return self (we ARE a Symbol).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_sympify_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1031,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy sympify protocol - return self.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__bool__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1039,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Always True for boolean contexts.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__hash__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1043,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Delegate to Symbol's hash.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__eq__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1047,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Delegate to Symbol's equality (symbolic identity).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__ne__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1051,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Delegate to Symbol's inequality.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__mul__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1122,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Multiplication - return UWexpression to preserve units.",
    "harvested_comments": [
      "Handle matrix cases",
      "Use applyfunc to multiply each element by self (as Symbol).",
      "This preserves unit tracking: result is Matrix([x * self, ...])",
      "where get_units() can find units for both self AND matrix elements.",
      "DON'T use self._sym * other - that loses matrix element units!"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__rmul__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1164,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right multiplication - handle UWQuantity, Matrix, and scalars.\n\nThis is called when `other * self` fails (other.__mul__ returns NotImplemented).\nIn particular, `MutableDenseMatrix * UWexpression` triggers this because\nSymPy matrices don't understand UWexpression.",
    "harvested_comments": [
      "Handle UWQuantity - preserve units",
      "Handle SymPy Matrix types - delegate to forward multiplication",
      "Matrix * scalar works when scalar is on the left, so use self * other",
      "which calls our __mul__ \u2192 Symbol.__mul__ \u2192 SymPy handles it correctly",
      "scalar * Matrix is handled by SymPy - returns matrix with scaled elements"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__truediv__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1194,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Division - return UWexpression to preserve units.",
    "harvested_comments": [
      "Handle UWQuantity - use full Pint arithmetic",
      "Use FULL Pint quantity arithmetic",
      "Handle UWexpression - preserve LAZY evaluation by returning SymPy quotient",
      "Same design as __mul__: return raw SymPy quotient, derive units on demand",
      "Scalar division - preserve self's units"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__rtruediv__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1247,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right division - handle UWQuantity to preserve units.",
    "harvested_comments": [
      "Scalar / expression - units become inverted",
      "Only handle if units is a Pint unit object (not None or string)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__add__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1268,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Addition - handle UWQuantity and UWexpression with unit conversion.",
    "harvested_comments": [
      "Handle UWexpression + UWexpression",
      "TRANSPARENT CONTAINER: If self.sym is UWQuantity, use proper Pint arithmetic",
      "Both contain UWQuantity - use proper unit-aware addition",
      "Pint will handle 10cm + 1m = 110cm automatically",
      "Pass full UWQuantity - Transparent Container stores it"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__radd__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1344,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right addition - handle UWQuantity specially.",
    "harvested_comments": [
      "Addition is commutative"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__sub__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1351,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Subtraction - LAZY EVALUATION pattern.\n\nWhen subtracting UWexpressions, we preserve both symbols in the tree\nrather than doing eager arithmetic. This allows unwrap_for_evaluate()\nto substitute the correct nondimensional values later.\n\nThe key insight is that if one operand is a coordinate (no units) and\nthe other has units, we CANNOT do the subtraction eagerly because:\n- Coordinates are already in ND form (from mesh scaling)\n- Unit-bearing quantities need to be nondimensionalized by .data\n\nBy keeping both symbols, unwrap_for_evaluate can process each one\ncorrectly according to its type.",
    "harvested_comments": [
      "Handle UWexpression - UWexpression: LAZY EVALUATION",
      "Keep both symbols in the tree - don't do eager arithmetic",
      "Delegate to SymPy Symbol subtraction - preserves both symbols",
      "Handle UWexpression - UWQuantity: Wrap in UWexpression first (LAZY)",
      "Wrap the UWQuantity in a UWexpression to preserve it as a symbol"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__rsub__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1391,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right subtraction - handle UWQuantity specially.",
    "harvested_comments": [
      "UWQuantity - UWexpression \u2192 UWexpression",
      "Convert self to other's units (other is the \"base\" unit here)",
      "Convert self's value to other's units for correct subtraction",
      "other - self: result is in other's units",
      "Use self.value (not self.sym) for arithmetic"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__pow__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1423,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Power - delegate to Symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__rpow__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1427,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right power - delegate to Symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__neg__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1431,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Negation - delegate to Symbol.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1439,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "User-friendly representation showing value with units.\n\nFor expressions with units, shows: value [units]\nFor expressions with symbolic content, shows: name = symbolic_expr\nFor named expressions with simple values, shows: name = value [units]\n\nNote: Uses _display_name (set via rename()) rather than _given_name\nso that renamed expressions show their custom names.",
    "harvested_comments": [
      "Use _display_name for representation (respects rename())",
      "Check if this is a \"named\" expression (user-defined name vs auto-generated)",
      "Auto-generated names start with (",
      "Format the value part",
      "Has units - show value with units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "__str__",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1479,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "String representation showing value with units if available.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_repr_latex_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1488,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "LaTeX representation for Jupyter notebooks.\n\nJupyter prioritizes _repr_latex_ over __repr__, so we override\nSymPy's default to show units.",
    "harvested_comments": [
      "Check if this is a \"named\" expression (user-defined name vs auto-generated)",
      "Format value for LaTeX",
      "Use scientific notation for very small/large numbers",
      "Format units for LaTeX (Pint units have LaTeX-compatible format)",
      "For named expressions, show name = value [units]"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_repr_html_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1533,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "HTML representation for Jupyter notebooks (fallback if LaTeX not available).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_repr_png_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1556,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Disable PNG rendering to ensure _repr_latex_ is used.\n\nSymPy's init_printing() may enable PNG rendering which bypasses\nour custom _repr_latex_. By returning None, we force Jupyter to\nfall back to text/latex format.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_repr_svg_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1566,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Disable SVG rendering to ensure _repr_latex_ is used.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_repr_mimebundle_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1570,
    "signature": "(self, **kwargs)",
    "parameters": [
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "MIME bundle for Jupyter display - highest priority representation.\n\nThis method has ABSOLUTE HIGHEST PRIORITY in Jupyter's display system.\nIt overrides ANY type-based formatters (including SymPy's init_printing()).\n\nWhy this is needed:\n- SymPy's init_printing() registers formatters for sympy.Basic types\n- UWexpression inherits from sympy.Symbol (a sympy.Basic subclass)\n- Without this, SymPy's formatter renders UWexpression as raw symbols\n- _repr_mimebundle_ cannot be overridden by type formatters\n\nReturns dict of MIME type \u2192 content for display.",
    "harvested_comments": [
      "Get our custom LaTeX representation",
      "Also provide plain text fallback"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_ipython_display_",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1596,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "IPython/Jupyter display hook - ABSOLUTE highest priority.\n\nThis method OVERRIDES MathematicalMixin._ipython_display_ to show\nour custom representation with units instead of raw SymPy symbols.\n\nWhy this override is needed:\n- MathematicalMixin._ipython_display_ calls display(Math(latex(sym)))\n- This shows only the symbol name without units\n- We want to show value + units for UWexpressions",
    "harvested_comments": [
      "Use our custom LaTeX representation with units",
      "IPython not available - silent fallback"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/function/expressions.py",
    "line": 1618,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Display expression details for solver .view() \"Where:\" section.\n\nShows the expression name, its symbolic value, and description.\nCalled by solver _object_viewer when expanding expression definitions.",
    "harvested_comments": [
      "Build LaTeX representation: symbol = value",
      "Get the symbolic value",
      "Format the value",
      "Strip $ signs if present (we'll add our own)",
      "Display: name = value (description)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWexpression",
    "is_public": false
  },
  {
    "name": "_evaluate_gradient_interpolant",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 124,
    "signature": "(scalar_var, coords, component = None)",
    "parameters": [
      {
        "name": "scalar_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "component",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate gradient via Clement interpolant (fast, O(h) accurate).\n\nUses PETSc's DMPlexComputeGradientClementInterpolant which averages\ncell-wise gradients at vertices. A scratch DM is used internally to\navoid polluting the mesh's DM.\n\nParameters\n----------\nscalar_var : MeshVariable\n    Field to compute gradient of.\ncoords : array-like\n    Coordinates at which to evaluate gradient.\ncomponent : int or None\n    For multi-component fields, which component.\n\nReturns\n-------\nndarray\n    Gradient values, shape (n_points, dim).",
    "harvested_comments": [
      "Handle multi-component fields",
      "Convert coords to numpy array if needed",
      "Get vertex coordinates (P1 node locations)",
      "Check if field is P1 scalar - can use data directly",
      "Create scratch DM with P1 scalar field for Clement computation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_evaluate_gradient_projection",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 271,
    "signature": "(scalar_var, coords, component = None)",
    "parameters": [
      {
        "name": "scalar_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "component",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate gradient via L2 projection (accurate, O(h\u00b2)).\n\nCreates a cached gradient MeshVariable and projector on the mesh.\nSubsequent calls reuse the cached objects and warm-start the solve\nfrom the previous solution.\n\nParameters\n----------\nscalar_var : MeshVariable\n    Field to compute gradient of.\ncoords : array-like\n    Coordinates at which to evaluate gradient.\ncomponent : int or None\n    For multi-component fields, which component.\n\nReturns\n-------\nndarray\n    Gradient values, shape (n_points, dim).",
    "harvested_comments": [
      "Handle multi-component fields",
      "Convert coords to numpy array if needed",
      "Cache key based on variable and component",
      "Initialize gradient cache on mesh if not present",
      "Get or create cached projectors for each gradient component"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_compute_barycentric",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 379,
    "signature": "(point, vertices)",
    "parameters": [
      {
        "name": "point",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "vertices",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Compute barycentric coordinates of a point within a simplex.\n\nParameters\n----------\npoint : ndarray\n    Query point, shape (dim,).\nvertices : ndarray\n    Simplex vertices, shape (dim+1, dim).\n\nReturns\n-------\nndarray\n    Barycentric coordinates, shape (dim+1,).",
    "harvested_comments": [
      "Not a simplex, return uniform weights",
      "Build matrix T where columns are (v_i - v_n) for i = 0..dim-1",
      "shape (dim, dim)",
      "Solve T @ lambda = (point - v_n)",
      "Last barycentric coordinate"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_evaluate_field_at_vertices",
    "kind": "function",
    "file": "src/underworld3/function/gradient_evaluation.py",
    "line": 416,
    "signature": "(var, component, mesh)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "component",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Evaluate a field component at P1 vertex locations.\n\nFor P1 scalar fields, returns the data directly.\nFor higher-degree or multi-component fields, samples at vertex coordinates.\n\nParameters\n----------\nvar : MeshVariable\n    The mesh variable to sample.\ncomponent : int or None\n    Which component to evaluate (for multi-component fields).\nmesh : Mesh\n    The mesh.\n\nReturns\n-------\nndarray\n    Field values at vertices, shape (n_vertices,).",
    "harvested_comments": [
      "Get vertex count",
      "P1 scalar - return data directly",
      "P1 multi-component - extract the component directly from data",
      "Data layout: [v0_c0, v0_c1, ..., v1_c0, v1_c1, ...]",
      "Reshape to (n_vertices, num_components) and extract component"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_expr_hash",
    "kind": "function",
    "file": "src/underworld3/function/pure_sympy_evaluator.py",
    "line": 126,
    "signature": "(expr)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generate a hash for a sympy expression for caching.\n\nParameters\n----------\nexpr : sympy expression\n    Expression to hash\n\nReturns\n-------\nstr\n    Hash string",
    "harvested_comments": [
      "Use sympy's srepr for consistent string representation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_from_pint",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 100,
    "signature": "(cls, pint_qty, model_registry = None)",
    "parameters": [
      {
        "name": "pint_qty",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "model_registry",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create UWQuantity from a Pint Quantity object.\n\nThis is used by Model.to_model_units() and other internal methods\nthat work with Pint quantities directly.\n\nParameters\n----------\npint_qty : pint.Quantity\n    A Pint Quantity object\nmodel_registry : pint.UnitRegistry, optional\n    Model-specific registry (for model units)\n\nReturns\n-------\nUWQuantity\n    New quantity with the Pint quantity's value and units",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_compute_nd_value",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 161,
    "signature": "(self) -> Union[float, np.ndarray]",
    "parameters": [],
    "returns": "Union[float, np.ndarray]",
    "existing_docstring": "Compute the non-dimensional value using model scaling.",
    "harvested_comments": [
      "If no units, value is already \"non-dimensional\"",
      "Try to get scaling from model",
      "Get the scale factor for our dimensionality",
      "Extract scalar from scale (may be Pint Quantity)",
      "Convert to base units first, then scale"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__add__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 280,
    "signature": "(self, other: Union['UWQuantity', float, int]) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "other",
        "type_hint": "Union['UWQuantity', float, int]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Addition via Pint.",
    "harvested_comments": [
      "One or both dimensionless",
      "Handle UWexpression",
      "Delegate to UWexpression's __radd__",
      "Handle SymPy expressions - LAZY EVALUATION approach",
      "Wrap self in UWexpression first, then add symbolically"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__radd__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 324,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right addition.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__sub__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 328,
    "signature": "(self, other: Union['UWQuantity', float, int]) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "other",
        "type_hint": "Union['UWQuantity', float, int]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Subtraction via Pint.",
    "harvested_comments": [
      "Handle UWexpression: UWQuantity - UWexpression \u2192 UWexpression",
      "For subtraction, units must be compatible - convert other to self's units",
      "Convert other's value to self's units",
      "Units incompatible - use raw value (will be wrong but won't crash)",
      "Result in self's units"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__rsub__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 389,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right subtraction: other - self.",
    "harvested_comments": [
      "Handle UWexpression: UWexpression - UWQuantity is handled by UWexpression.__sub__",
      "This handles: sympy.Basic - UWQuantity",
      "LAZY EVALUATION approach (like __add__):",
      "Wrap self in UWexpression first, preserving the full UWQuantity.",
      "This ensures evaluate() knows the value has units and won't re-scale it."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__mul__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 421,
    "signature": "(self, other: Union['UWQuantity', float, int]) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "other",
        "type_hint": "Union['UWQuantity', float, int]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Multiplication via Pint.",
    "harvested_comments": [
      "Handle UnitAwareArray - Pint doesn't properly combine units with UnitAwareArray",
      "We need to manually combine units and multiply values",
      "Both have units - combine them via Pint",
      "Multiply numeric values (extract numpy from UnitAwareArray)",
      "Return UnitAwareArray with combined units"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__rmul__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 544,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right multiplication.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__truediv__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 548,
    "signature": "(self, other: Union['UWQuantity', float, int]) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "other",
        "type_hint": "Union['UWQuantity', float, int]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Division via Pint.",
    "harvested_comments": [
      "Check if other is a UWexpression - handle specially to preserve units",
      "Both have units - compute combined units (self / other)",
      "Only self has units",
      "Only other has units - result has 1/other_units",
      "Neither has units - just delegate to SymPy"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__rtruediv__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 624,
    "signature": "(self, other)",
    "parameters": [
      {
        "name": "other",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Right division: other / self.\n\nLAZY EVALUATION approach (same as __rsub__ and __add__):\nWrap self in UWexpression first, preserving the full UWQuantity.\nThis ensures evaluate() knows the value has units and won't re-scale it.\n\nRED FLAG: Never embed bare numbers (self._value) in symbolic expressions!\nBare numbers get re-dimensionalized during evaluation, causing unit bugs.",
    "harvested_comments": [
      "Handle SymPy types - use LAZY EVALUATION",
      "LAZY EVALUATION approach:",
      "Wrap self in UWexpression first, preserving the full UWQuantity.",
      "This ensures evaluate() knows the value has units and won't re-scale it.",
      "Store the full UWQuantity - Transparent Container"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__pow__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 661,
    "signature": "(self, exponent: Union[float, int]) -> 'UWQuantity'",
    "parameters": [
      {
        "name": "exponent",
        "type_hint": "Union[float, int]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "'UWQuantity'",
    "existing_docstring": "Exponentiation via Pint.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__neg__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 669,
    "signature": "(self) -> 'UWQuantity'",
    "parameters": [],
    "returns": "'UWQuantity'",
    "existing_docstring": "Negation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_sympy_",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 723,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "SymPy protocol - controls how SymPy converts this object.\n\nFor quantities WITH units: raise SympifyError to force SymPy to\nreturn NotImplemented, which triggers our __rmul__/__radd__ etc.\n\nFor quantities WITHOUT units: return the numeric value.",
    "harvested_comments": [
      "If we have units, don't let SymPy consume us silently",
      "This forces SymPy to return NotImplemented so our __rmul__ gets called",
      "No units - safe to return numeric value"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__float__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 747,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Convert to float.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__str__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 759,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "String representation matching UWexpression style: value [units].",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 765,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "User-friendly representation matching UWexpression style: value [units].",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "__format__",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 771,
    "signature": "(self, format_spec: str) -> str",
    "parameters": [
      {
        "name": "format_spec",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "str",
    "existing_docstring": "Formatted representation matching UWexpression style.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_repr_latex_",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 786,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "LaTeX representation for Jupyter notebooks.",
    "harvested_comments": [
      "Format value for LaTeX",
      "Use scientific notation for very small/large numbers",
      "Format units for LaTeX"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_repr_mimebundle_",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 807,
    "signature": "(self, **kwargs)",
    "parameters": [
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "MIME bundle for Jupyter display - highest priority representation.\n\nThis method has ABSOLUTE HIGHEST PRIORITY in Jupyter's display system.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_ipython_display_",
    "kind": "method",
    "file": "src/underworld3/function/quantities.py",
    "line": 818,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "IPython/Jupyter display hook - ABSOLUTE highest priority.\n\nShows the quantity with units in LaTeX format.",
    "harvested_comments": [
      "IPython not available - silent fallback"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "UWQuantity",
    "is_public": false
  },
  {
    "name": "_extract_value",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 15,
    "signature": "(value, target_units = None)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "target_units",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Universal helper to extract numeric value from quantities or pass through numbers.\n\nThis is a lightweight, zero-side-effect function that makes APIs accept both\nplain numbers and unit-aware quantities transparently.\n\nParameters\n----------\nvalue : float, int, Quantity, UWQuantity, tuple, list, or None\n    Value to extract. Can be:\n    - Plain number \u2192 returned as-is\n    - Pint Quantity \u2192 magnitude extracted\n    - UWQuantity \u2192 value extracted\n    - tuple/list \u2192 recursively processed\n    - None \u2192 returned as-is\ntarget_units : str, optional\n    If provided, converts quantity to these units before extracting value.\n    Ignored if value has no units.\n\nReturns\n-------\nfloat, int, tuple, list, or None\n    Plain numeric value(s), ready to use in numeric APIs\n\nExamples\n--------\n>>> # Plain numbers pass through unchanged\n>>> _extract_value(5.0)\n5.0\n\n>>> # Quantities have magnitude extracted\n>>> _extract_value(5.0 * uw.units.km)\n5000.0  # in meters\n\n>>> # With target units\n>>> _extract_value(5.0 * uw.units.km, 'cm')\n500000.0\n\n>>> # Tuples/lists processed recursively\n>>> _extract_value((0.0, 5.0 * uw.units.km))\n(0.0, 5000.0)\n\n>>> # UWQuantity support\n>>> _extract_value(uw.quantity(5.0, \"km\"))\n5000.0",
    "harvested_comments": [
      "Plain numbers pass through unchanged",
      "Quantities have magnitude extracted",
      "With target units",
      "Tuples/lists processed recursively",
      "UWQuantity support"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_convert_coords_to_si",
    "kind": "function",
    "file": "src/underworld3/function/unit_conversion.py",
    "line": 1001,
    "signature": "(coords)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert coordinate input to numpy array in model coordinates.\n\nThis function handles unit-aware coordinates by converting them to model units,\nnot SI units. This ensures coordinates work correctly with meshes that use\nreference quantities for scaling.\n\nAccepts:\n- numpy arrays (assumed to be in model coordinates if no units)\n- lists/tuples of coordinates (each coordinate can be UWQuantity, Pint Quantity, or float/int)\n- lists/tuples of tuples (for multiple points)\n\nReturns numpy array of shape (n_points, n_dims) with dtype=np.double in model coordinates.",
    "harvested_comments": [
      "Get the model for unit conversion",
      "Helper function to convert a single coordinate value",
      "Unit-aware coordinate - convert to model units",
      "Extract the magnitude",
      "Conversion returned plain number - use it"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_convert_coords_to_tree_units",
    "kind": "method",
    "file": "src/underworld3/kdtree.py",
    "line": 68,
    "signature": "(self, coords)",
    "parameters": [
      {
        "name": "coords",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert query coordinates to match the KD-tree's coordinate system.\n\nParameters\n----------\ncoords : array-like\n    Query coordinates (may or may not have units)\n\nReturns\n-------\nnp.ndarray\n    Coordinates converted to tree's coordinate system (raw numpy array)",
    "harvested_comments": [
      "If tree has no units, just extract raw array",
      "Tree has units - check query coordinates",
      "Same units - just extract raw array",
      "Different units - convert to tree's coordinate system",
      "Use UnitAwareArray's to method if available"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "KDTree",
    "is_public": false
  },
  {
    "name": "_notify_callbacks",
    "kind": "method",
    "file": "src/underworld3/materials.py",
    "line": 304,
    "signature": "(self, event_type: str, *args)",
    "parameters": [
      {
        "name": "event_type",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Notify all callbacks of a material change",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MaterialRegistry",
    "is_public": false
  },
  {
    "name": "_rank2_to_unscaled_matrix",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 91,
    "signature": "(v_ij, dim, covariant = True)",
    "parameters": [
      {
        "name": "v_ij",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "covariant",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank 2 tensor (v_ij) to voigt (vector) form (V_I)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_rank4_to_unscaled_matrix",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 112,
    "signature": "(c_ijkl, dim)",
    "parameters": [
      {
        "name": "c_ijkl",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert rank 4 tensor (c_ijkl) to matrix form (C_IJ)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_unscaled_matrix_to_rank2",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 134,
    "signature": "(V_I, dim)",
    "parameters": [
      {
        "name": "V_I",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert to rank 2 tensor (v_ij) from voigt (vector) form (V_I)",
    "harvested_comments": [
      "convert Voight form V_I to v_ij (matrix)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_unscaled_matrix_to_rank4",
    "kind": "function",
    "file": "src/underworld3/maths/tensors.py",
    "line": 153,
    "signature": "(C_IJ, dim)",
    "parameters": [
      {
        "name": "C_IJ",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dim",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert to rank 4 tensor (c_ijkl) from matrix form (C_IJ)",
    "harvested_comments": [
      "C_IJ -> C_ijkl -> C_jilk -> C_ij_lk -> C_jikl (Symmetry)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_require_pyvista",
    "kind": "function",
    "file": "src/underworld3/meshing/faults.py",
    "line": 56,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check pyvista availability with helpful error message.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 451,
    "signature": "(self, name: str) -> FaultSurface",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "FaultSurface",
    "existing_docstring": "Get a fault by name.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": false
  },
  {
    "name": "__iter__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 455,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Iterate over fault names.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": false
  },
  {
    "name": "__len__",
    "kind": "method",
    "file": "src/underworld3/meshing/faults.py",
    "line": 459,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Number of faults in collection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "FaultCollection",
    "is_public": false
  },
  {
    "name": "_require_pyvista",
    "kind": "function",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 58,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check pyvista availability with helpful error message.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_create_proxy",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 254,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Create the proxy MeshVariable for .sym access.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": false
  },
  {
    "name": "_interpolate_to_proxy",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 263,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Interpolate surface vertex data to mesh nodes.\n\nEach rank populates its LOCAL mesh nodes only using inverse distance\nweighting from surface vertices.",
    "harvested_comments": [
      "Get local mesh node coordinates",
      "Get surface vertex data",
      "For 2D surfaces, use only x,y components for KDTree",
      "Build KDTree for surface vertices",
      "Find nearest surface vertex for each mesh node"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SurfaceVariable",
    "is_public": false
  },
  {
    "name": "_mark_all_proxies_stale",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 496,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Mark all SurfaceVariable proxies as stale.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "_ensure_discretized",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 568,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Ensure discretization is computed (lazy evaluation).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "_discretize_3d",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 601,
    "signature": "(self, offset: float = 0.01) -> None",
    "parameters": [
      {
        "name": "offset",
        "type_hint": "float",
        "default": "0.01",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Discretize 3D control points into triangulated mesh using pyvista delaunay_2d.",
    "harvested_comments": [
      "Check for degenerate cases (all points nearly collinear)",
      "Create PolyData from points and triangulate",
      "Compute normals (both point and cell)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "_discretize_2d",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 633,
    "signature": "(self, n_segments: int = None) -> None",
    "parameters": [
      {
        "name": "n_segments",
        "type_hint": "int",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Create 2D surface as ordered line segments using scipy spline fitting.\n\nFor 2D, a \"surface\" is a 1D curve (polyline) embedded in 2D space.",
    "harvested_comments": [
      "Get 2D coordinates",
      "For just 2 points, connect them directly",
      "Use scipy to fit a parametric spline through points",
      "This naturally orders points along the curve",
      "s=0 means interpolate exactly through points"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "_compute_distance_field",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 765,
    "signature": "(self) -> None",
    "parameters": [],
    "returns": "None",
    "existing_docstring": "Compute signed distance field from mesh nodes to surface.\n\nThe signed distance is positive on one side of the surface and\nnegative on the other. Helper functions like influence_function()\nuse sympy.Abs() when unsigned distance is needed.\n\nFor 3D surfaces: Uses pyvista's compute_implicit_distance.\nFor 2D surfaces: Uses geometry_tools signed_distance_pointcloud_polyline_2d.",
    "harvested_comments": [
      "Use varsymbol for clean LaTeX display: d_{F} instead of {surf_fault_distance}",
      "Always wrap symbol in braces for proper LaTeX grouping (e.g., d_{F_1} not d_F_1)",
      "Get mesh coordinates",
      "2D: Use geometry_tools for signed distance to polyline",
      "Get 2D coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "_on_mesh_adapted",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 991,
    "signature": "(self, adapted_mesh: 'Mesh') -> None",
    "parameters": [
      {
        "name": "adapted_mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      }
    ],
    "returns": "None",
    "existing_docstring": "Called by mesh.adapt() to update after mesh adaptation.\n\nMarks the distance field as stale so it will be recomputed on next access.\nThe surface geometry (control points, pyvista mesh) is unchanged -\nonly the cached distance values need updating.\n\nThe distance MeshVariable itself is reinitialized by mesh.adapt() along\nwith all other MeshVariables - we just need to mark the data as stale.\n\nArgs:\n    adapted_mesh: The mesh (same object, updated internals)",
    "harvested_comments": [
      "Mark distance as stale - will be recomputed on next access",
      "The MeshVariable stays in mesh._vars and gets reinitialized by adapt()",
      "just like any other variable (same pattern as swarm proxy variables)",
      "Mark all variable proxies as stale (they project to mesh nodes)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Surface",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1334,
    "signature": "(self, name: str) -> Surface",
    "parameters": [
      {
        "name": "name",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Surface",
    "existing_docstring": "Get a surface by name.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": false
  },
  {
    "name": "__iter__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1338,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Iterate over surface names.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": false
  },
  {
    "name": "__len__",
    "kind": "method",
    "file": "src/underworld3/meshing/surfaces.py",
    "line": 1342,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Number of surfaces in collection.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SurfaceCollection",
    "is_public": false
  },
  {
    "name": "_register_mesh",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 155,
    "signature": "(self, mesh)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Internal method to register a mesh with this model.\nCalled automatically from Mesh.__init__\n\nParameters:\n-----------\nmesh : uw.discretisation.Mesh\n    Mesh instance to register",
    "harvested_comments": [
      "Set as primary mesh if no primary mesh exists"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_register_swarm",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 200,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Internal method to register a swarm with this model.\nCalled automatically from Swarm.__init__\n\nParameters:\n-----------\nswarm : uw.swarm.Swarm\n    Swarm instance to register",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_register_variable",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 213,
    "signature": "(self, name, variable)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "variable",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Internal method to register a variable with this model.\nCalled automatically from MeshVariable/SwarmVariable.__init__\n\nHandles namespace collision by creating fully qualified names for variables\non different meshes/swarms but with the same symbolic name.\n\nParameters:\n-----------\nname : str\n    Variable name (may not be unique across meshes/swarms)\nvariable : MeshVariable or SwarmVariable\n    Variable instance to register",
    "harvested_comments": [
      "For SwarmVariables, ensure we keep strong reference to swarm to prevent garbage collection",
      "This will raise if swarm already garbage collected",
      "Ensure swarm is registered with strong reference",
      "Check for namespace collision",
      "If same variable object, nothing to do"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_register_solver",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 311,
    "signature": "(self, name, solver)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "solver",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Internal method to register a solver with this model.\nCalled automatically from solver.__init__\n\nParameters:\n-----------\nname : str\n    Solver name/identifier\nsolver : Solver instance\n    Solver to register",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_update_mesh_for_swarm",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 350,
    "signature": "(self, swarm, new_mesh)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "new_mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Internal method to coordinate mesh handover for a specific swarm.\n\nThis method handles the model-level coordination when a swarm\nis assigned to a new mesh via swarm.mesh = new_mesh.\n\nParameters\n----------\nswarm : uw.swarm.Swarm\n    Swarm being reassigned to new mesh\nnew_mesh : uw.discretisation.Mesh\n    New mesh to assign\n\nNotes\n-----\nThis is called from swarm.mesh setter and handles:\n- Unregistering swarm from old mesh\n- Updating model's mesh reference\n- Registering swarm with new mesh",
    "harvested_comments": [
      "Unregister swarm from old mesh",
      "Mesh may not support swarm registration or swarm not registered",
      "Update model's mesh reference",
      "Register swarm with new mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_lock_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 924,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Lock the model units to prevent changes after mesh creation.\n\nThis is called automatically when the first mesh is registered.\nOnce locked, calling set_reference_quantities() will raise an error.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_check_units_locked",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 933,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if model units are locked.\n\nRaises:\n-------\nRuntimeError\n    If units are locked and user tries to change reference quantities",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_simple_dimensional_analysis",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 972,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Pure mathematical dimensional analysis using linear algebra.\n\nUses physics (dimensional structure) not linguistics (names) to derive\nfundamental scales. Works with any user terminology.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_comprehensive_dimensional_analysis",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 981,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Comprehensive dimensional analysis using linear algebra and Pint.\n\nAnalyzes dimensional coverage, provides intelligent error handling,\nand uses human-friendly formatting. Zero dependency on naming conventions.",
    "harvested_comments": [
      "Use the SHARED underworld3 unit registry to avoid registry mismatch errors",
      "Build dimensional matrix from pure physics",
      "Analyze system properties",
      "Handle different system types",
      "Always show warnings (parallel-safe)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_solve_available_dimensions",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1037,
    "signature": "(self, matrix, names, fundamental_dims, ureg)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "names",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "fundamental_dims",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "ureg",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Solve for fundamental scales from the dimensions available in reference quantities.\n\nDerives scales for whatever dimensions are covered by the user's reference\nquantities (e.g., L, M, T from viscosity, velocity, length). Dimensions not\ncovered are left undefined and will only cause errors if actually requested.\nThis follows Pint's approach: work with what's available.",
    "harvested_comments": [
      "Identify which dimensions are covered (have non-zero entries in matrix)",
      "Informational message about missing dimensions (not an error!)",
      "Extract sub-matrix for covered dimensions only",
      "Get magnitudes in SI base units",
      "Can we solve the sub-system?"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_solve_complete_system",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1124,
    "signature": "(self, matrix, magnitudes, names, fundamental_dims, ureg)",
    "parameters": [
      {
        "name": "matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "magnitudes",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "names",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "fundamental_dims",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "ureg",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Solve complete dimensional system using linear algebra.\n\nGiven n reference quantities with known dimensionalities, solves for the\nfundamental scales [L, T, M, \u03b8] that are consistent with all constraints.\n\nThe system is: matrix @ log10(scales) = log10(magnitudes)\nwhere matrix[i,j] is the power of fundamental dimension j in quantity i.",
    "harvested_comments": [
      "Solve the linear system in log space",
      "Create Pint quantities for the fundamental scales - direct, no rounding",
      "Verification (only shown if verbose=True)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_create_pint_registry",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1178,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create Pint registry with model-specific _constants.\n\nUses Pint's _constants pattern like _100km for model units.",
    "harvested_comments": [
      "Create model-specific registry",
      "Store constant definitions for inspection",
      "Define multiple aliases for fundamental dimensions",
      "ASCII aliases: Easy to type",
      "Unicode aliases: Beautiful for display"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_substitute_display_aliases",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1285,
    "signature": "(self, units_str: str) -> str",
    "parameters": [
      {
        "name": "units_str",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "str",
    "existing_docstring": "Replace raw constant names with elegant display aliases in unit strings.\n\nExamples:\n\"_6p31e41kg\" \u2192 \"\u2133\"\n\"_1000km\" \u2192 \"\u2112\"\n\"_631152000000000s\" \u2192 \"\ud835\udcaf\"",
    "harvested_comments": [
      "Replace each constant with its display alias",
      "Replace the constant name with display alias"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_round_scale_for_conditioning",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1338,
    "signature": "(self, scale: float, reference_mag: float = None) -> float",
    "parameters": [
      {
        "name": "scale",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "reference_mag",
        "type_hint": "float",
        "default": "None",
        "description": ""
      }
    ],
    "returns": "float",
    "existing_docstring": "Round scale to achieve optimal numerical conditioning based on unit_rounding_mode.\n\nThe goal is to choose a scale such that reference_mag / scale falls in a target range:\n- 'powers_of_10': Target [1, 10] (default) - optimal precision\n- 'engineering': Target [1, 1000] - SI prefix friendly, avoids fractions\n\nArgs:\n    scale: The derived scale from dimensional analysis\n    reference_mag: The reference quantity magnitude to condition (optional)\n\nReturns:\n    Rounded scale value\n\nExamples:\n    powers_of_10 mode (target result in [1, 10]):\n        scale=500, ref=500 \u2192 100 (gives 500/100 = 5.0)\n        scale=6.37e6, ref=6.37e6 \u2192 1e6 (gives 6.37e6/1e6 = 6.37)\n\n    engineering mode (target result in [1, 1000]):\n        scale=500, ref=500 \u2192 1 (gives 500/1 = 500)\n        scale=6.37e6, ref=6.37e6 \u2192 1e6 (gives 6.37e6/1e6 = 6.37)",
    "harvested_comments": [
      "If no reference magnitude, use old simple rounding",
      "Define target range based on mode",
      "Engineering: target [1, 1000], use powers of 1000",
      "log10(1000)",
      "powers_of_10 (default)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_round_to_nice_value",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1413,
    "signature": "(self, magnitude: float) -> float",
    "parameters": [
      {
        "name": "magnitude",
        "type_hint": "float",
        "default": null,
        "description": ""
      }
    ],
    "returns": "float",
    "existing_docstring": "Simple rounding to nearest power of 10 or 1000 (fallback method).\n\nThis is used when we don't have a reference magnitude to condition against.",
    "harvested_comments": [
      "Round to nearest power of 1000",
      "powers_of_10",
      "Round to nearest power of 10",
      "Clean up floating point errors for values >= 1"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_generate_constant_name",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1441,
    "signature": "(self, magnitude: float, si_units: str, dimension: str) -> str",
    "parameters": [
      {
        "name": "magnitude",
        "type_hint": "float",
        "default": null,
        "description": ""
      },
      {
        "name": "si_units",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "dimension",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": "str",
    "existing_docstring": "Generate Pint _constant names following _100km pattern.",
    "harvested_comments": [
      "Round to nice value first to avoid floating point precision issues",
      "Simplify common SI units",
      "Format magnitude for readability - ensure valid Python identifiers",
      "IMPORTANT: Avoid using recognizable unit names (like \"km\", \"m\", \"kg\") in constant names!",
      "Pint tries to parse them and fails. Use separators to prevent parsing."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_convert_to_user_time_unit",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1483,
    "signature": "(self, time_base_units, velocity_quantity)",
    "parameters": [
      {
        "name": "time_base_units",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "velocity_quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Infer appropriate time unit from velocity reference quantity.\n\nThis implements Stage 2 of the two-stage simplification:\nAfter rationalizing to SI base units, convert to user-friendly time units\nby inferring the appropriate scale from the velocity's unit system.\n\nParameters\n----------\ntime_base_units : pint.Quantity\n    Time in SI base units (seconds)\nvelocity_quantity : pint.Quantity\n    The velocity quantity used to derive time (contains unit hints)\n\nReturns\n-------\npint.Quantity\n    Time in user-appropriate units (year, megayear, day, etc.)\n\nExamples\n--------\n>>> # If velocity is in cm/year, time should be in years or megayears\n>>> time_sec = 1.26e14 * ureg.second\n>>> velocity = 5 * ureg.cm / ureg.year\n>>> result = model._convert_to_user_time_unit(time_sec, velocity)\n>>> # result: 40.0 megayear (not 1.26e14 second)",
    "harvested_comments": [
      "If velocity is in cm/year, time should be in years or megayears",
      "result: 40.0 megayear (not 1.26e14 second)",
      "Infer time unit from velocity's time component",
      "Geological time scale",
      "Daily time scale"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_choose_display_units",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 1552,
    "signature": "(self, quantity, dimension_name = '[unknown]')",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "dimension_name",
        "type_hint": null,
        "default": "'[unknown]'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Choose magnitude-appropriate units for display.\n\nThis implements the display-time unit selection strategy: choose units\nthat give values between 0.1 and 1000 for better readability.\n\nParameters\n----------\nquantity : pint.Quantity\n    Quantity to display in appropriate units\ndimension_name : str, optional\n    Dimension name for context (e.g., '[length]', '[time]', '[mass]')\n\nReturns\n-------\npint.Quantity\n    Same quantity in magnitude-appropriate units\n\nExamples\n--------\n>>> # Length: 2e6 m \u2192 2000 km\n>>> length = 2e6 * ureg.meter\n>>> display_length = model._choose_display_units(length, '[length]')\n>>> # display_length: 2000 kilometer\n\n>>> # Time: 1.26e14 s \u2192 40 Myr\n>>> time = 1.26e14 * ureg.second\n>>> display_time = model._choose_display_units(time, '[time]')\n>>> # display_time: 40.0 megayear",
    "harvested_comments": [
      "Length: 2e6 m \u2192 2000 km",
      "display_length: 2000 kilometer",
      "Time: 1.26e14 s \u2192 40 Myr",
      "display_time: 40.0 megayear",
      "Get base magnitude for comparison"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_format_scale_representations",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2143,
    "signature": "(self, scale_qty) -> str",
    "parameters": [
      {
        "name": "scale_qty",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "str",
    "existing_docstring": "Format a scale quantity showing three representations:\n1. Derivation form (how it was derived)\n2. SI base units (simplified)\n3. Model base units (what 1.0 represents in the model)\n\nParameters\n----------\nscale_qty : pint.Quantity\n    The scale quantity to format\n\nReturns\n-------\nstr\n    Formatted string with all three representations",
    "harvested_comments": [
      "1. Derivation form (current complex units)",
      "2. SI base units (simplified)",
      "3. Model base units (what 1.0 represents)",
      "The scale quantity itself represents what \"1.0\" means in model units",
      "So we format it in a clear way to show this"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_get_domain_friendly_scale",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2318,
    "signature": "(self, qty)",
    "parameters": [
      {
        "name": "qty",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Choose domain-appropriate units based on magnitude using Pint's capabilities.",
    "harvested_comments": [
      "Use the SHARED underworld3 unit registry to avoid registry mismatch errors",
      "Length scales - choose appropriate geological/engineering units",
      "Time scales - choose appropriate geological/engineering units",
      "Mass scales",
      "Very large masses"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_suggest_reference_quantities",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2539,
    "signature": "(self, missing_dimensions) -> list",
    "parameters": [
      {
        "name": "missing_dimensions",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "list",
    "existing_docstring": "Suggest specific reference quantities to complete missing dimensions.\n\nParameters\n----------\nmissing_dimensions : list\n    List of dimension names that are missing\n\nReturns\n-------\nlist\n    List of suggestion strings for each missing dimension",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_handle_conversion_failure",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2603,
    "signature": "(self, qty, qty_dimensionality)",
    "parameters": [
      {
        "name": "qty",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "qty_dimensionality",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Handle conversion failure with diagnostic error messages and suggestions.\n\nParameters\n----------\nqty : pint.Quantity\n    The quantity that failed to convert\nqty_dimensionality : pint.util.UnitsContainer\n    The dimensionality of the failed quantity\n\nReturns\n-------\nUWQuantity\n    Dimensionless quantity with original magnitude (fallback)\n\nRaises\n------\nValueError\n    With diagnostic information when strict error handling is enabled",
    "harvested_comments": [
      "Analyze what dimensions are needed vs. available",
      "Convert Pint internal dimension to our naming",
      "Get validation results",
      "Build diagnostic message",
      "For now, issue a warning instead of raising an error for backward compatibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_optimize_scales_for_readability",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2718,
    "signature": "(self, scalings)",
    "parameters": [
      {
        "name": "scalings",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Optimize scales to use nice round numbers while keeping reference quantities O(1).\n\nParameters\n----------\nscalings : dict\n    Dictionary of fundamental scalings from derive_fundamental_scalings()\n\nReturns\n-------\ndict\n    Optimized scalings with nice round numbers",
    "harvested_comments": [
      "Find nearest \"nice\" scale",
      "Import units backend to create new quantity",
      "Fallback to original scale if optimization fails",
      "Non-standard scale format, keep as-is"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_find_nice_scale",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2754,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Find nearest 'nice' number (powers of 10 times 1, 2, or 5).\n\nParameters\n----------\nvalue : float\n    Original scale value\n\nReturns\n-------\nfloat\n    Nearest nice scale value\n\nExamples\n--------\n>>> model._find_nice_scale(2900)   # \u2192 1000 or 5000\n>>> model._find_nice_scale(0.38)   # \u2192 0.5 or 0.2\n>>> model._find_nice_scale(15.7)   # \u2192 10 or 20",
    "harvested_comments": [
      "\u2192 1000 or 5000",
      "\u2192 0.5 or 0.2",
      "Get the order of magnitude",
      "Choose from nice mantissas: 1, 2, 5",
      "Include 10 to handle edge cases"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_detect_scaling_conflicts",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 2800,
    "signature": "(self, ref_qty)",
    "parameters": [
      {
        "name": "ref_qty",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Detect conflicts in over-determined dimensional systems.\n\nParameters\n----------\nref_qty : dict\n    Reference quantities dictionary\n\nReturns\n-------\ndict\n    Dictionary with keys:\n    - 'has_conflicts': bool indicating if conflicts were found\n    - 'conflicts': list of conflict descriptions\n    - 'resolutions': list of suggested resolutions\n    - 'redundant_quantities': list of quantity names that could be removed",
    "harvested_comments": [
      "Import units (Pint) for dimensional analysis",
      "Build a map of what dimensions each quantity provides",
      "Track which quantities can provide each base dimension",
      "Check for direct conflicts (multiple quantities of same dimension)",
      "Keep first, mark others as redundant"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_convert_to_model_units_general",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 3375,
    "signature": "(self, quantity)",
    "parameters": [
      {
        "name": "quantity",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert any quantity to model units using Pint's native conversion.\n\nReturns None for dimensionless quantities gracefully.",
    "harvested_comments": [
      "NEW APPROACH: Use Pint's native .to() method instead of manual dimensional analysis",
      "This avoids double-scaling issues and leverages Pint's unit conversion engine",
      "IMPORTANT: The source quantity might be in a different Pint registry!",
      "We need to reconstruct it in the MODEL's registry before converting.",
      "First get magnitude and units from the input"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "__repr__",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4318,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Override Pydantic's __repr__ for better user experience.",
    "harvested_comments": [
      "Add units information"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "__str__",
    "kind": "method",
    "file": "src/underworld3/model.py",
    "line": 4335,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "String representation for print() calls.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Model",
    "is_public": false
  },
  {
    "name": "_should_rank_execute",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 58,
    "signature": "(current_rank, rank_selector, total_size)",
    "parameters": [
      {
        "name": "current_rank",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "rank_selector",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "total_size",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if a rank should execute based on rank selector.\n\nArgs:\n    current_rank: The rank to check\n    rank_selector: int, slice, list, tuple, callable, str, or numpy array\n    total_size: Total number of ranks\n\nReturns:\n    bool: True if rank should execute",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_get_executing_ranks",
    "kind": "function",
    "file": "src/underworld3/mpi.py",
    "line": 109,
    "signature": "(rank_selector, total_size)",
    "parameters": [
      {
        "name": "rank_selector",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "total_size",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Get set of ranks that will execute for a given selector.\n\nArgs:\n    rank_selector: Rank selection specification\n    total_size: Total number of ranks\n\nReturns:\n    set: Set of rank numbers that will execute",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_create_variable_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 378,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for variable data.\nFollows the same pattern as swarm.points implementation.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Create NDArray_With_Callback (following swarm._points pattern)",
      "Allow operations like existing arrays",
      "Single callback function (following swarm_update_callback pattern)",
      "Only act on data-changing operations (following swarm.points pattern)",
      "Skip updates during coordinate changes to prevent corruption"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_canonical_data_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 422,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create the single canonical data array with PETSc synchronization.\nThis is the ONLY method that creates arrays with PETSc callbacks.\n\nReturns data in shape (-1, num_components) using pack_raw/unpack_raw methods.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Canonical array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Use unpack_raw to get flat format (-1, num_components)",
      "Handle case where unpack returns None (swarm not initialized)",
      "Create NDArray_With_Callback for flat data",
      "Allow operations like existing arrays",
      "Single canonical callback for PETSc synchronization"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 490,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create array view of canonical data using appropriate conversion strategy.\n\nStrategy depends on variable complexity:\n- Scalars/Vectors: Simple reshape operations\n- 2D+ Tensors: Complex pack/unpack operations\n\nReturns\n-------\nArrayView\n    Array-like object that delegates changes back to canonical data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_is_simple_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 508,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this is a simple scalar/vector variable (not a complex tensor)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_simple_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 512,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for scalars/vectors using simple reshape operations",
    "harvested_comments": [
      "Simple reshape: (-1, num_components) -> (N, a, b)",
      "For simple variables, reshape to (N, a, b) format",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_tensor_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 722,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for complex tensors using pack/unpack operations",
    "harvested_comments": [
      "Use complex pack/unpack for tensor layouts",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray",
      "If ND scaling is active, data is non-dimensional and needs dimensionalization"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_pack_array_to_data_format",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 929,
    "signature": "(self, array_data)",
    "parameters": [
      {
        "name": "array_data",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array format (N,a,b) back to canonical data format (N,components)",
    "harvested_comments": [
      "Use existing pack logic but return numpy array instead of writing to PETSc",
      "This is a pure conversion method - no PETSc access"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1021,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mark proxy mesh variable as stale for lazy evaluation.\nThe actual update happens when the proxy is accessed.",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "Mark proxy as stale for lazy evaluation (avoids immediate PETSc access conflicts)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update_proxy_if_stale",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1036,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Actually update the proxy mesh variable if it's marked as stale.\nThis implements lazy evaluation to avoid PETSc access conflicts.",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "Only update if stale and not already updating",
      "Mark as fresh"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_rbf_to_meshVar",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1060,
    "signature": "(self, meshVar, nnn = None, verbose = False)",
    "parameters": [
      {
        "name": "meshVar",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Here is how it works: for each particle, create a distance-weighted average on the node data\n\nTodo: caching the k-d trees etc for the proxy-mesh-variable nodal points\nTodo: some form of global fall-back for when there are no particles on a processor",
    "harvested_comments": [
      "Mapping to the coordinates of the variable from the",
      "particle coords",
      "If this is our own proxy variable and mesh has changed, recreate it",
      "Use the newly created proxy variable"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_rbf_reduce_to_meshVar",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1091,
    "signature": "(self, meshVar, verbose = False)",
    "parameters": [
      {
        "name": "meshVar",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method updates a mesh variable for the current\nswarm & particle variable state by reducing the swarm to\nthe nearest point for each particle\n\nHere is how it works:\n\n    1) for each particle, create a distance-weighted average on the node data\n    2) check to see which nodes have zero weight / zero contribution and replace with nearest particle value\n\nTodo: caching the k-d trees etc for the proxy-mesh-variable nodal points\nTodo: some form of global fall-back for when there are no particles on a processor",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "1 - Average particles to nodes with distance weighted average",
      "Use non-dimensional coordinates for internal KDTree (matches swarm.data coordinate system)",
      "need actual distances",
      "2 - set NN vals on mesh var where w == 0.0"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1358,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This will substitute specific information about this object",
    "harvested_comments": [
      "feedback on this instance"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2010,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Backward compatibility wrapper for _update_proxy_variables.\n\nMaintains existing API while implementing lazy evaluation internally.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_on_data_changed",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2018,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Hook called by unified data callback when canonical data changes.\n\nFor IndexSwarmVariable, this marks proxy variables as stale for lazy evaluation.\nThis replaces the complex custom array override with a simple hook.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_update_proxy_variables",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2095,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This method updates the proxy mesh (vector) variable for the index variable on the current swarm locations\n\nHere is how it works:\n\n    1) for each particle, create a distance-weighted average on the node data\n    2) for each index in the set, we create a mask mesh variable by mapping 1.0 wherever the\n       index matches and 0.0 where it does not.\n\nNOTE: If no material is identified with a given nodal value, the default is to impose\na near-neighbour hunt for a valid material and set that one\n\n## ToDo: This should be revisited to match the updated master copy of _update\n\nupdate_type 0: assign the particles to the nearest mesh_levelset nodes, and calculate the value on nodes from them.\nupdate_type 1: calculate the material property value on mesh_levelset nodes from the nearest N particles directly.",
    "harvested_comments": [
      "# ToDo: This should be revisited to match the updated master copy of _update",
      "Use non-dimensional coordinates for internal level set KDTree",
      "n, d, b = kd_swarm.find_closest_point(self._meshLevelSetVars[0].coords)",
      "if there is no material found,",
      "impose a near-neighbour hunt for a valid material and set that one"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2415,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Cleanup swarm by unregistering from mesh to prevent memory leaks",
    "harvested_comments": [
      "Mesh/Model may have already been garbage collected, which is fine"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_force_migration_after_mesh_change",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3160,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Force migration of swarm particles after mesh coordinate changes.\n\nThis method bypasses the normal migration_disabled check since mesh\ncoordinate changes require swarm particles to be re-distributed\nregardless of migration disabled state.",
    "harvested_comments": [
      "Temporarily override migration disabled state",
      "Disable variable array callbacks during migration to prevent corruption",
      "Collect all variable arrays and disable their callbacks",
      "Perform standard migration",
      "Re-enable variable array callbacks"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_legacy_access",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3759,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "SwarmVariable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying swarm variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nAt the conclusion of the users context managed block, numerous further operations\nwill be automatically executed. This includes swarm parallel migration routines\nwhere the swarm's `particle_coordinates` variable has been modified. The swarm\nvariable proxy mesh variables will also be updated for modifed swarm variables.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "grab numpy object, setting read only if necessary",
      "increment variable state"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_setup_projections",
    "kind": "method",
    "file": "src/underworld3/systems/ddt.py",
    "line": 350,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Initialize projection solvers for history updates.",
    "harvested_comments": [
      "## using this to store terms that can't be evaluated (e.g. derivatives)",
      "The projection operator for mapping derivative values to the mesh - needs to be different for each variable type, unfortunately ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Eulerian",
    "is_public": false
  },
  {
    "name": "_class_timer_decorator",
    "kind": "function",
    "file": "src/underworld3/timing.py",
    "line": 318,
    "signature": "(cls)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Decorator that adds timing to all methods in a class.\n\nWalks through class methods and wraps them with routine_timer_decorator.\n\nParameters\n----------\ncls : type\n    Class to decorate\n\nReturns\n-------\ntype\n    Same class with methods wrapped for timing\n\nExample\n-------\n>>> @uw.timing._class_timer_decorator\n>>> class MyAnalysis:\n>>>     def compute(self):\n>>>         # ... work ...\n>>>\n>>> uw.timing.start()\n>>> analysis = MyAnalysis()\n>>> analysis.compute()  # Automatically timed\n>>> uw.timing.print_table()",
    "harvested_comments": [
      "... work ...",
      "Automatically timed",
      "Skip special methods",
      "Skip already decorated",
      "Create timed version"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_get_ureg",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 43,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the Pint unit registry.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_get_pint_helper",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 82,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the Pint helper (lazy singleton).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_get_default_backend",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 91,
    "signature": "()",
    "parameters": [],
    "returns": null,
    "existing_docstring": "DEPRECATED: Use _get_pint_helper() instead.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_extract_units_info",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 96,
    "signature": "(obj)",
    "parameters": [
      {
        "name": "obj",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract units information from various object types.\n\nArgs:\n    obj: Object that might have units (variable, quantity, expression, etc.)\n\nReturns:\n    tuple: (has_units, units, backend) or (False, None, None)",
    "harvested_comments": [
      "PRIORITY 0: Check for SymPy expressions first (including derivatives)",
      "This must come before unit-aware object check because UWexpression wraps",
      "SymPy derivatives and we need to detect the derivative, not the wrapper's units",
      "Check if object has a SymPy expression inside (UWexpression, variables, etc.)",
      "TRANSPARENT CONTAINER PRINCIPLE (2025-11-26): Check .sym property (UWexpression,"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_extract_units_from_sympy_expression",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 342,
    "signature": "(expr)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract units from SymPy expressions containing unit-aware variables.\n\nThis function analyzes mathematical expressions like 2*velocity to determine\ntheir units based on the unit-aware variables they contain.\n\nArgs:\n    expr: SymPy expression\n\nReturns:\n    tuple: (has_units, units, backend) or None if no units found",
    "harvested_comments": [
      "Import the function extraction utilities",
      "Extract all UW objects (function symbols) from the expression",
      "Get the default model to access registered variables",
      "Map function symbols back to their variables",
      "Skip coordinate symbols"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_analyze_expression_units",
    "kind": "function",
    "file": "src/underworld3/units.py",
    "line": 410,
    "signature": "(expr, unit_info_list)",
    "parameters": [
      {
        "name": "expr",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "unit_info_list",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Analyze a SymPy expression to determine its resultant units.\n\nThis implements basic dimensional analysis for mathematical operations:\n- Addition/subtraction: units must be the same, result has same units\n- Multiplication: units multiply\n- Division: units divide\n- Powers: units are raised to the power\n\nArgs:\n    expr: SymPy expression\n    unit_info_list: List of (units, backend) tuples from variables in expression\n\nReturns:\n    Units for the resulting expression",
    "harvested_comments": [
      "For now, implement simple heuristics",
      "TODO: Full dimensional analysis implementation",
      "If expression is multiplication, combine units using Pint",
      "Check if it's a constant times a variable",
      "Simple case: constant * variable"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  }
]