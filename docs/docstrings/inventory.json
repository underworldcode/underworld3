[
  {
    "name": "Mesh",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 149,
    "signature": "class Mesh",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unstructured mesh with PETSc DMPlex backend.\n\nThe Mesh class provides the spatial discretisation for finite element\ncomputations. It wraps PETSc's DMPlex for unstructured mesh management,\nsupporting various cell types (triangles, quadrilaterals, tetrahedra,\nhexahedra) and coordinate systems.\n\nParameters\n----------\nplex_or_meshfile : PETSc.DMPlex or str\n    Either a PETSc DMPlex object or path to a mesh file (gmsh, exodus).\ndegree : int, optional\n    Polynomial degree for the coordinate field (default 1).\nsimplex : bool, optional\n    True for simplicial elements (triangles/tets), False for quads/hexes.\ncoordinate_system_type : CoordinateSystemType, optional\n    Coordinate system for vector calculus (Cartesian, cylindrical, etc.).\nqdegree : int, optional\n    Quadrature degree for numerical integration (default 2).\nboundaries : list of NamedTuple, optional\n    Boundary region definitions with names and values.\nboundary_normals : dict, optional\n    Outward normal vectors for each boundary.\nunits : str or pint.Unit, optional\n    Physical units for mesh coordinates.\nverbose : bool, optional\n    Print mesh construction information.\n\nAttributes\n----------\nN : sympy.vector.CoordSys3D\n    SymPy coordinate system for symbolic expressions.\nX : UWCoordinate tuple\n    Coordinate variables (x, y, z) for use in expressions.\ndim : int\n    Spatial dimension of the mesh.\ndm : PETSc.DMPlex\n    Underlying PETSc distributed mesh object.\n\nExamples\n--------\nMeshes are typically created via the meshing module::\n\n    >>> mesh = uw.meshing.UnstructuredSimplexBox(\n    ...     minCoords=(0, 0), maxCoords=(1, 1), cellSize=0.1\n    ... )\n    >>> T = mesh.add_variable(\"T\", vtype=uw.VarType.SCALAR)\n\nSee Also\n--------\nunderworld3.meshing : Mesh generation utilities.\nunderworld3.discretisation.MeshVariable : Field variables on meshes.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SwarmType",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 52,
    "signature": "class SwarmType",
    "parameters": [],
    "returns": null,
    "existing_docstring": "PETSc swarm type specification.\n\nDetermines how particles are managed by PETSc's DMSwarm infrastructure.\n\nAttributes\n----------\nDMSWARM_BASIC : int\n    Basic point cloud without mesh association.\nDMSWARM_PIC : int\n    Particle-in-cell mode with automatic mesh cell tracking.\n    Particles are migrated between MPI ranks as they move across\n    cell boundaries.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SwarmVariable",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 82,
    "signature": "class SwarmVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Variable supported by a particle swarm (point cloud).\n\nA SwarmVariable stores values at discrete particle locations and provides\na mesh-based proxy representation for use in symbolic expressions. This\nenables Lagrangian tracking of material properties through deformation.\n\nParameters\n----------\nname : str\n    Identifier for this variable (must be unique within the swarm).\nswarm : Swarm\n    The supporting particle swarm.\nsize : int or tuple, optional\n    Shape specification: int for vectors, tuple for matrices.\n    If None, inferred from ``vtype``.\nvtype : VarType, optional\n    Variable type (SCALAR, VECTOR, TENSOR, SYM_TENSOR, MATRIX).\n    If None, inferred from ``size``.\ndtype : type, default=float\n    Data type for storage (float or int).\nproxy_degree : int, default=1\n    Polynomial degree for the mesh proxy variable.\nproxy_continuous : bool, default=True\n    Whether the proxy uses continuous (True) or discontinuous (False)\n    interpolation.\nvarsymbol : str, optional\n    LaTeX symbol for display. Defaults to ``name``.\nrebuild_on_cycle : bool, default=True\n    If True, rebuild the proxy when particles cycle through periodic\n    boundaries. Recommended for continuous fields.\nunits : str or pint.Unit, optional\n    Physical units for this variable (e.g., 'kelvin', 'Pa').\n    Requires reference quantities to be set on the model.\n\nAttributes\n----------\ndata : numpy.ndarray\n    Direct access to variable values at particle locations.\nsym : sympy.Matrix\n    Symbolic representation for use in expressions.\n\nSee Also\n--------\nMeshVariable : Variable supported by mesh nodes.\nSwarm : Container for particle locations.\n\nExamples\n--------\nCreate a temperature field on a swarm:\n\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> T = swarm.add_variable(\"T\", size=1, vtype=uw.VarType.SCALAR)\n>>> T.data[:] = 1600.0  # Set initial temperature\n\nCreate a velocity field:\n\n>>> v = swarm.add_variable(\"v\", size=mesh.dim, vtype=uw.VarType.VECTOR)\n\nNotes\n-----\nSwarmVariables are essential for tracking material properties that\nadvect with the flow. The mesh proxy enables their use in finite\nelement formulations while particle storage preserves Lagrangian\nhistory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "IndexSwarmVariable",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 1883,
    "signature": "class IndexSwarmVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Integer-valued swarm variable for material tracking.\n\nIndexSwarmVariable stores integer indices at particle locations, typically\nused for tracking distinct material types. It automatically generates\nsymbolic mask expressions for each material index, enabling material-\ndependent properties in constitutive models.\n\nParameters\n----------\nname : str\n    Variable name for identification and I/O.\nswarm : Swarm\n    Parent swarm object.\nindices : int\n    Number of distinct material indices (default 1).\nproxy_degree : int\n    Polynomial degree for mesh projection (default 1).\nproxy_continuous : bool\n    Whether mesh proxy is continuous (default True).\n\nAttributes\n----------\nsym : list of sympy.Expr\n    Symbolic mask expressions for each material index.\n\nExamples\n--------\n>>> material = IndexSwarmVariable(\"M\", swarm, indices=3)\n>>> material.data[:] = 0  # Set all particles to material 0\n>>> # Use sym[i] as multiplier for material i properties\n>>> viscosity = material.sym[0] * 1e20 + material.sym[1] * 1e21\n\nSee Also\n--------\nSwarmVariable : Base class for particle-supported variables.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Swarm",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 2193,
    "signature": "class Swarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A basic particle swarm implementation for Lagrangian particle tracking and data storage.\n\nThe UW `Swarm` class provides a simplified particle management system that uses\nPETSc's DMSWARM_BASIC type. Unlike the standard `Swarm` class, this implementation\ndoes not rely on PETSc to determine ranks for particle migration but instead uses\nour own kdtree neighbour-domain computations.\n\nThis class is preferred for most operations except where particle / cell relationships\nare always required.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The mesh object that defines the computational domain for particle operations.\n    Particles will be associated with this mesh for spatial queries and operations.\nrecycle_rate : int, optional\n    Rate at which particles are recycled for streak management. If > 1, enables\n    streak particle functionality where particles are duplicated and tracked\n    across multiple cycles. Default is 0 (no recycling).\nverbose : bool, optional\n    Enable verbose output for debugging and monitoring particle operations.\n    Default is False.\n\nAttributes\n----------\nmesh : uw.discretisation.Mesh\n    Reference to the associated mesh object.\ndim : int\n    Spatial dimension of the mesh (2D or 3D).\ncdim : int\n    Coordinate dimension of the mesh.\ndata : numpy.ndarray\n    Direct access to particle coordinate data.\nparticle_coordinates : SwarmVariable\n    SwarmVariable containing particle coordinate information.\nrecycle_rate : int\n    Current recycle rate for streak management.\ncycle : int\n    Current cycle number for streak particles.\n\nMethods\n-------\npopulate(fill_param=1)\n    Populate the swarm with particles throughout the domain.\nmigrate(remove_sent_points=True, delete_lost_points=True, max_its=10)\n    Manually migrate particles across MPI processes after coordinate updates.\nadd_particles_with_coordinates(coords)\n    Add new particles at specified coordinate locations.\nadd_particles_with_global_coordinates(coords)\n    Add particles using global coordinate system.\nadd_variable(name, size, dtype=float)\n    Add a new variable to track additional particle properties.\nsave(filename, meshUnits=1.0, swarmUnits=1.0, units=\"dimensionless\")\n    Save swarm data to file.\nread_timestep(filename, step_name, outputPath=\"./output/\")\n    Read swarm data from a specific timestep file.\nadvection(V_fn, delta_t, evalf=False, corrector=True, restore_points_func=None)\n    Advect particles using a velocity field.\nestimate_dt(V_fn, dt_min=1.0e-15, dt_max=1.0)\n    Estimate appropriate timestep for particle advection.\n\nExamples\n--------\nCreate a basic swarm and populate with particles:\n\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1))\n>>> swarm = uw.swarm.Swarm(mesh=mesh)\n>>> swarm.populate(fill_param=2)\n\nCreate a streak swarm with recycling:\n\n>>> streak_swarm = uw.swarm.Swarm(mesh=mesh, recycle_rate=5)\n>>> streak_swarm.populate(fill_param=1)\n\nAdd custom particle data:\n\n>>> temperature = swarm.add_variable(\"temperature\", 1)\n>>> velocity = swarm.add_variable(\"velocity\", mesh.dim)\n\nManual particle migration after coordinate updates:\n\nNote: particle migration is still called automatically when we\n`access` and update the particle_coordinates variables\n\nNote: `swarm.populate` uses a the mesh point locations for discontinuous interpolants to\ndetermine the particle locations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "NodalPointSwarm",
    "kind": "class",
    "file": "src/underworld3/swarm.py",
    "line": 4281,
    "signature": "class NodalPointSwarm",
    "parameters": [],
    "returns": null,
    "existing_docstring": "BASIC_Swarm with particles located at the coordinate points of a meshVariable\n\nThe swarmVariable `X0` is defined so that the particles can \"snap back\" to their original locations\nafter they have been moved.\n\nThe purpose of this Swarm is to manage sample points for advection schemes based on upstream sampling\n(method of characteristics etc)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 34,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "nuke_coords_and_rebuild",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1087,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)",
      "let's go ahead and do an initial projection from linear (the default)",
      "to linear. this really is a nothing operation, but a",
      "side effect of this operation is that coordinate DM DMField is",
      "converted to the required `PetscFE` type. this may become necessary"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "checkpoint_xdmf",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3124,
    "signature": "(filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Identify the mesh file. Use the",
      "# zeroth one if this option is turned off",
      "# Obtain the mesh information",
      "We only use a subset of the possible cell types",
      "# Create the header"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 61,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "clone",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 609,
    "signature": "(self, name, varsymbol)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 887,
    "signature": "(self, new_coords, meth = 0, p = 2, verbose = False, nnn = None, rubbish = None)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "meth",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "p",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "rubbish",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "An inverse-distance mapping is quite robust here ... as long",
      "as long we take care of the case where some nodes coincide (likely if used mesh2mesh)",
      "Use non-dimensional coordinates for internal RBF interpolation KDTree"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "load_from_h5_plex_vector",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1176,
    "signature": "(self, filename: str, data_name: Optional[str] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Ensure vectors are initialized"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2790,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2796,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2802,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "jacobian",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2808,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# validate if this is a vector ?"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1380,
    "signature": "(self, new_coords, verbose = False, nnn = None)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "An inverse-distance mapping is quite robust here ... as long",
      "as we take care of the case where some nodes coincide (likely if used with mesh2mesh)",
      "We try to eliminate contributions from recently remeshed particles",
      "Get data directly from PETSc to avoid circular callback dependencies",
      "What to do if there are no particles"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "write_proxy",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1807,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "if not proxied, nothing to do. return."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1818,
    "signature": "(self, data_filename: str, swarmID: str, data_name: str, index: int, outputPath = '')",
    "parameters": [
      {
        "name": "data_filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmID",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": null,
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "mesh.write_timestep( \"test\", meshUpdates=False, meshVars=[X], outputPath=\"\", index=0)",
      "swarm.write_timestep(\"test\", \"swarm\", swarmVars=[var], outputPath=\"\", index=0)",
      "check if swarmFilename exists",
      "easier to debug abs path",
      "## open up file with coords on all procs and open up data on all procs. May be problematic for large problems."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2023,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "visMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2065,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "clip_to_mesh",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2798,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "clip_to_mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2802,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3454,
    "signature": "(self, base_filename: str, swarm_id: str, index: int, outputPath: Optional[str] = '', migrate = True)",
    "parameters": [
      {
        "name": "base_filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarm_id",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "migrate",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "## open up file with coords on all procs",
      "We make it possible not to migrate the swarm because this",
      "will also delete points outside the mesh. We may not want to do",
      "that (either for debugging / visualisation, or when adapting the mesh)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3982,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = False)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Convert delta_t to model units if it has units",
      "This ensures consistent arithmetic: velocity is in model units, so time must be too",
      "X0 holds the particle location at the start of advection",
      "This is needed because the particles may be migrated off-proc",
      "during timestepping. Probably not needed - use global evaluation instead"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "advection",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4377,
    "signature": "(self, V_fn, delta_t, order = 2, corrector = False, restore_points_to_domain_func = None, evalf = False, step_limit = True)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "delta_t",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "corrector",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "restore_points_to_domain_func",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "step_limit",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "NodalPointSwarm",
    "is_public": true
  },
  {
    "name": "dim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 735,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Topological dimension of the mesh.\n\nReturns\n-------\nint\n    The mesh dimension (2 for 2D, 3 for 3D).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "cdim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 746,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "Coordinate dimension (embedding space dimension).\n\nFor most meshes, ``cdim == dim``. For surface meshes embedded in 3D\n(e.g., a 2D spherical shell), ``dim=2`` but ``cdim=3``.\n\nReturns\n-------\nint\n    The coordinate dimension.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "element",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 760,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "Element type information for the mesh.\n\nContains details about the finite element discretization including\ncell type, polynomial degree, and quadrature order.\n\nReturns\n-------\ndict\n    Element information dictionary.\n\nNotes\n-----\nUW3 does not support mixed-element meshes; this applies uniformly\nto all cells.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_scale",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 780,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "Length scale for non-dimensionalization.\n\nThis property is IMMUTABLE after mesh creation to ensure synchronization\nwith all spatial operators (gradient, divergence, curl, etc.).\n\nThe length scale is derived from model reference quantities at mesh creation:\n- Priority 1: `domain_depth` from `model.set_reference_quantities()`\n- Priority 2: `length` from `model.set_reference_quantities()`\n- Default: 1.0 (no scaling)\n\nReturns\n-------\nfloat\n    Length scale value for non-dimensionalization\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_depth=uw.quantity(100, \"km\"))\n>>> mesh = uw.meshing.UnstructuredSimplexBox(...)\n>>> mesh.length_scale\n100000.0  # meters\n\nSee Also\n--------\nlength_units : Units string for length scale",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 811,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Unit string for the length scale.\n\nReturns\n-------\nstr\n    Units for the length scale (e.g., \"meter\", \"kilometer\")\n\nExamples\n--------\n>>> mesh.length_units\n'kilometer'",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 827,
    "signature": "(self, level = 0)",
    "parameters": [
      {
        "name": "level",
        "type_hint": null,
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Displays mesh information at different levels.\n\nParameters\n----------\nlevel : int (0 default)\n    The display level.\n    0, for basic mesh information (variables and boundaries), while level=1 displays detailed mesh information (including PETSc information)",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "Display coordinate units if set",
      "Display length scale for non-dimensionalization",
      "Display coordinate system information",
      "Show available coordinate accessors"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view_parallel",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1020,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "returns the break down of boundary labels from each processor",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "# Boundary information on each proc",
      "## goes through each processor and gets the label size"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "clone_dm_hierarchy",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1071,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Clone the dm hierarchy on the mesh",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "update_lvec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1189,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This method creates and/or updates the mesh variable local vector.\nIf the local vector is already up to date, this method will do nothing.",
    "harvested_comments": [
      "create the local vector (memory chunk) and attach to original dm",
      "push avar arrays into the parent dm array",
      "The field decomposition seems to fail if coarse DMs are present",
      "traverse subdms, taking user generated data in the subdm",
      "local vec, pushing it into a global sub vec"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "lvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1228,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "Returns a local Petsc vector containing the flattened array\nof all the mesh variables.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1371,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Dummy access manager that provides deferred sync for backward compatibility.\nUses NDArray_With_Callback.delay_callbacks_global() internally.\n\nThis is a compatibility wrapper that allows existing code using the access()\ncontext manager to work with the new direct-access variable interfaces.\nAll variable modifications are deferred and synchronized at context exit.\n\nParameters\n----------\nwriteable_vars\n    Variables that will be modified (ignored - all variables are writable\n    with the new interface, this parameter is kept for API compatibility)\n\nReturns\n-------\nContext manager that defers variable synchronization until exit\n\nNotes\n-----\nThis method is deprecated. New code should access variable.data or\nvariable.array directly without requiring an access context.",
    "harvested_comments": [
      "Use NDArray_With_Callback global delay context for deferred sync",
      "This triggers all accumulated callbacks from all variables"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1421,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "SymPy coordinate system for symbolic calculus.\n\nThe base coordinate system used for gradient, divergence, and\ncurl operations. Access base scalars via ``mesh.N.x``, ``mesh.N.y``,\n``mesh.N.z`` and base vectors via ``mesh.N.i``, ``mesh.N.j``, ``mesh.N.k``.\n\nReturns\n-------\nsympy.vector.CoordSys3D\n    The SymPy coordinate system object.\n\nSee Also\n--------\nX : Coordinate system with data access.\nr : Tuple of coordinate scalars.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma_N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1441,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "SymPy coordinate system for boundary/surface coordinates.\n\nReturns\n-------\nsympy.vector.CoordSys3D\n    The boundary coordinate system object.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1452,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "Boundary coordinate scalars as a row matrix.\n\nReturns\n-------\nsympy.Matrix\n    Row matrix of boundary coordinate scalars.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "X",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1463,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate system with symbolic coordinates and data access.\n\nThe primary interface for mesh coordinates, providing both symbolic\nexpressions for equations and numerical data for evaluation.\n\nReturns\n-------\nCoordinateSystem\n    Coordinate system object with:\n\n    - ``mesh.X[0]``, ``mesh.X[1]``: Symbolic coordinate functions\n    - ``mesh.X.coords``: Coordinate data array (vertex positions)\n    - ``mesh.X.units``: Coordinate units\n    - ``x, y = mesh.X``: Unpack symbolic coordinates\n\nExamples\n--------\n>>> x, y = mesh.X  # Symbolic coordinates for equations\n>>> coords = mesh.X.coords  # Numerical vertex positions\n\nSee Also\n--------\nN : SymPy coordinate system for vector calculus.",
    "harvested_comments": [
      "Symbolic coordinates for equations",
      "Numerical vertex positions"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "CoordinateSystem",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1491,
    "signature": "(self) -> CoordinateSystem",
    "parameters": [],
    "returns": "CoordinateSystem",
    "existing_docstring": "Alias for :attr:`X` (the coordinate system object).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "r",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1496,
    "signature": "(self) -> Tuple[sympy.vector.BaseScalar]",
    "parameters": [],
    "returns": "Tuple[sympy.vector.BaseScalar]",
    "existing_docstring": "Tuple of coordinate scalars :math:`(x, y)` or :math:`(x, y, z)`.\n\nReturns\n-------\ntuple\n    Tuple of SymPy base scalars ``(N.x, N.y[, N.z])``.\n\nSee Also\n--------\nrvec : Position vector form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "rvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1511,
    "signature": "(self) -> sympy.vector.Vector",
    "parameters": [],
    "returns": "sympy.vector.Vector",
    "existing_docstring": "Position vector :math:`\\mathbf{r} = x\\hat{i} + y\\hat{j} [+ z\\hat{k}]`.\n\nReturns\n-------\nsympy.vector.Vector\n    The position vector in the mesh coordinate system.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1531,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of mesh element vertex coordinates.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.data`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nThis is an alias for mesh.points (which is also deprecated).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1550,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh node coordinates in physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.points`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from internal model coordinates\nto physical coordinates for user access.\n\nWhen the mesh has coordinate units specified, returns a unit-aware array.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Node coordinates (with units if specified)",
    "harvested_comments": [
      "Apply scaling to convert model coordinates to physical coordinates",
      "Wrap with unit-aware array if units are specified"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1592,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set mesh node coordinates from physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from physical coordinates\nto internal model coordinates for PETSc storage.\n\nArgs:\n    value (numpy.ndarray or UnitAwareArray): Node coordinates in physical units",
    "harvested_comments": [
      "PRINCIPLE (2025-11-27): When units are active, require unit-aware input",
      "to avoid ambiguity about whether values are dimensional or non-dimensional.",
      "Plain array assigned when units are active - ambiguous",
      "Handle unit-aware input",
      "Extract numerical value from unit-aware object"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_coordinates",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1661,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh coordinates in physical units.\n\nReturns the mesh coordinate array scaled to physical units using\nthe model's length scale. Requires the mesh to be associated with\na model that has reference quantities set.\n\nReturns\n-------\nUWQuantity or None\n    Coordinates in physical units, or None if no model scaling available\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_length=1000*uw.units.km, ...)\n>>> mesh = uw.meshing.StructuredQuadBox(...)\n>>> physical_coords = mesh.physical_coordinates  # In kilometers",
    "harvested_comments": [
      "In kilometers"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_bounds",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1686,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh bounds in physical units.\n\nReturns the mesh bounding box scaled to physical units using\nthe model's length scale.\n\nReturns\n-------\ntuple of UWQuantity or None\n    (min_coords, max_coords) in physical units, or None if no model scaling\n\nExamples\n--------\n>>> physical_min, physical_max = mesh.physical_bounds\n>>> print(f\"Domain: {physical_min} to {physical_max}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_extent",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1717,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh spatial extent in physical units.\n\nReturns the mesh size (max - min) in each dimension scaled to physical units.\n\nReturns\n-------\nUWQuantity or None\n    Extent in physical units, or None if no model scaling\n\nExamples\n--------\n>>> extent = mesh.physical_extent\n>>> print(f\"Domain size: {extent}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1745,
    "signature": "(self, filename: str, index: int, outputPath: Optional[str] = '', meshVars: Optional[list] = [], swarmVars: Optional[list] = [], meshUpdates: bool = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write the selected mesh, variables and swarm variables (as proxies) for later visualisation.\nAn xdmf file is generated and the overall package can then be read by paraview or pyvista.\nVertex values (on the mesh points) are stored for all variables regardless of their interpolation order",
    "harvested_comments": [
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists",
      "easier to debug abs",
      "check if we have write access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1816,
    "signature": "(self, index: int, meshVars: Optional[list] = [], outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the mesh and mesh vars in a h5 and xdmf file.\n\nParameters\n----------\nmeshVars:\n    List of UW mesh variables to save. If left empty then just the mesh is saved.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [
      "## save mesh vars",
      "### create petsc viewer",
      "## Empty meshVars will save just the mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1862,
    "signature": "(self, filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0, unique_id: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      },
      {
        "name": "unique_id",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write data in a format that can be restored for restarting the simulation\nThe difference between this and the visualisation is 1) the parallel section needs\nto be stored to reload the data correctly, and 2) the visualisation information (vertex form of fields)\nis not stored. This routines uses dmplex *VectorView and *VectorLoad functionality",
    "harvested_comments": [
      "The mesh checkpoint is the same as the one required for visualisation",
      "Checkpoint file",
      "Store the parallel-mesh section information for restoring the checkpoint.",
      "v._gvec.view(viewer) # would add viz information plus a duplicate of the data",
      "should not be required"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1924,
    "signature": "(self, filename: str, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh data to the specified hdf5 file.\n\n\nParameters\n----------\nfilename :\n    The filename for the mesh checkpoint file.\nindex :\n    Not yet implemented. An optional index which might\n    correspond to the timestep (for example).",
    "harvested_comments": [
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "viewer.pushTimestepping(viewer)",
      "viewer.setTimestep(index)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vtk",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1989,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh to the specified file",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "generate_xdmf",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1998,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method generates an xdmf schema for the specified file.\n\nThe filename of the generated file will be the same as the hdf5 file\nbut with the `xmf` extension.\n\nParameters\n----------\nfilename :\n    File name of the checkpointed hdf5 file for which the\n    xdmf schema will be written.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2020,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "block_vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2029,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points_in_domain",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2475,
    "signature": "(self, points, strict_validation = True)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "strict_validation",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in this domain.\nUses a mesh-boundary skeletonization array to determine whether the point is\ninside the boundary or outside. If close to the boundary, it checks if points\nare in a cell.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\nstrict_validation : bool\n    Whether to perform strict validation near boundaries",
    "harvested_comments": [
      "Convert points to model coordinates using the unified conversion function",
      "This handles all coordinate formats: plain numbers, unit-aware coordinates, lists, tuples, arrays",
      "_convert_coords_to_si now converts to model coordinates (despite the name)",
      "and handles all the complexity of extracting values from unit-aware coordinates",
      "# This choice of distance needs some more thought"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2529,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Note, the nearest point may not be all\nthat close by - use get_closest_local_cells to filter out points\nthat are (probably) not within any local cell.\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model coordinates",
      "Simply extract raw values - np.asarray handles unit-aware objects correctly",
      "## returns an empty 1D array if no coords are provided",
      "CRITICAL: Must return 1D array, not 2D, for Cython buffer compatibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "test_if_points_in_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2646,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test\n\nReturns\n-------\nnumpy.ndarray\n    Boolean array indicating if points are in cells",
    "harvested_comments": [
      "Convert points to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_local_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2681,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius_old",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2779,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2796,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_max_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2812,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global maximum distance from any cell centroid to a face.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2827,
    "signature": "(self, uw_function, uw_meshVariable, basis = None)",
    "parameters": [
      {
        "name": "uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "uw_meshVariable",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "basis",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Returns various norms on the mesh for the provided function.\n  - size\n  - mean\n  - min\n  - max\n  - sum\n  - L2 norm\n  - rms\n\n  NOTE: this currently assumes scalar variables !",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_mask_from_label",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2863,
    "signature": "(self, label_name, label_value)",
    "parameters": [
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract single label value and make a point mask - note: this produces a mask on the mesh points and\nassumes a 1st order mesh. Cell labels are not respected in this function.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "register_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2889,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register swarm as dependent on this mesh for coordinate change notifications",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "unregister_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2893,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unregister swarm (called during swarm cleanup)",
    "harvested_comments": [
      "WeakSet handles weak references internally, just remove the swarm directly"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "register_surface",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2898,
    "signature": "(self, surface)",
    "parameters": [
      {
        "name": "surface",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register surface as dependent on this mesh for adaptation notifications.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "unregister_surface",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2902,
    "signature": "(self, surface)",
    "parameters": [
      {
        "name": "surface",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unregister surface (called during surface cleanup).",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "adapt",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2917,
    "signature": "(self, metric_field, verbose = False)",
    "parameters": [
      {
        "name": "metric_field",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Adapt the mesh discretization based on a metric field.\n\nThis method refines or coarsens the mesh in place, automatically\ntransferring all attached MeshVariables, updating Surfaces, and\nmarking Solvers for rebuild on their next solve() call.\n\nParameters\n----------\nmetric_field : MeshVariable\n    A scalar MeshVariable containing target edge lengths (H field).\n    Smaller values mean finer mesh, larger values mean coarser.\nverbose : bool, optional\n    If True, print progress and statistics during adaptation.\n\nNotes\n-----\nThe adaptation uses PETSc's mesh adaptation with MMG/pragmatic backend.\n\n**What happens automatically:**\n\n- MeshVariables are interpolated to the new mesh\n- Surfaces recompute their distance fields\n- Swarms are marked as stale (particle-element associations invalidated)\n- Solvers are marked for rebuild (happens lazily on next solve())\n\nExamples\n--------\n>>> # Define metric from fault distance\n>>> metric = uw.discretisation.MeshVariable(\"H\", mesh, 1)\n>>> with mesh.access(metric):\n...     # Smaller H near fault, larger far away\n...     metric.data[:, 0] = 0.01 + 0.09 * fault.distance_from(mesh.data)\n>>> mesh.adapt(metric, verbose=True)\n>>> stokes.solve()  # Solver rebuilds automatically",
    "harvested_comments": [
      "Define metric from fault distance",
      "Smaller H near fault, larger far away",
      "Solver rebuilds automatically",
      "Store old state for transfer",
      "Notify surfaces to mark their distance fields as stale"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_lookup_by_symbol",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3342,
    "signature": "(mesh, sympy_object)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sympy_object",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Given a sympy object, scan the mesh variables in `mesh` to find the\nlocation (meshvariable, component in the data array) corresponding to the symbol\nor return None if not found",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_find_labeled_points_local",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3359,
    "signature": "(dm, label_name, label_value, sectionIndex = False, verbose = False)",
    "parameters": [
      {
        "name": "dm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sectionIndex",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Identify local points associated with \"Label\"\n\ndm -> expects a petscDM object\nlabel_name -> \"String Name for Label\"\nsectionIndex -> False: leave points as indexed by the relevant section on the dm\n                True: index into the local coordinate array\n\nNOTE: Assumes uniform element types",
    "harvested_comments": [
      "print(f\"Label: {label_name} / {label_value}\")",
      "print(f\"points: {pStart}: {pEnd}\")",
      "print(f\"edges : {eStart}: {eEnd}\")",
      "print(f\"faces : {fStart}: {fEnd}\")",
      "print(f\"\", flush=True)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 428,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the units associated with this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 433,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the units for this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 438,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 443,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the dimensionality of this variable.",
    "harvested_comments": [
      "Use Pint directly to get dimensionality"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 622,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data array to PETSc using traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data in traditional flat format (-1, num_components)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Convert to expected shape: (-1, num_components)",
      "Direct PETSc access (following mesh.access pattern)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Direct assignment to PETSc vec (like mesh.access does at line 1156)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 676,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced pack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nCRITICAL: This is the entry point where dimensional data enters PETSc storage.\nAll unit conversion and non-dimensionalization must happen here.\n\nParameters\n----------\ndata_array : numpy.ndarray or UWQuantity or UnitAwareArray\n    Array data to pack into mesh field. Can have units (will be converted).\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "STEP 1: Handle unit conversion for incoming data",
      "This is CRITICAL for the array setter to work correctly with units",
      "Check if data has units (UWQuantity or UnitAwareArray)",
      "Data has units - need to convert and extract magnitude",
      "Convert incoming units to variable's units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 779,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc in traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in traditional flat format (-1, num_components)",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Sync parallel operations if requested"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 828,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced unpack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in correct shape for the variable",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Unpack data using same layout as original method"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 912,
    "signature": "(self, filename: str, name: Optional[str] = None, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Append variable data to the specified mesh hdf5\ndata file. The file must already exist.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file. It\n    must already exist.\nname :\n    Textual name for dataset. In particular, this\n    will be used for XDMF generation. If not\n    provided, the variable name will be used.\nindex :\n    Not currently supported. An optional index which\n    might correspond to the timestep (for example).",
    "harvested_comments": [
      "Keep vector available for future access",
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "PetscViewerHDF5PushTimestepping(cviewer)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 990,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write variable data to the specified mesh hdf5\ndata file. The file will be over-written.\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file",
    "harvested_comments": [
      "Keep vector available for future access",
      "Variable coordinates - let's put those in the file to",
      "make it a standalone \"swarm\"",
      "# Add variable unit metadata to standalone file",
      "Use preferred selective_ranks pattern for unit metadata"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1084,
    "signature": "(self, data_filename, data_name, index, outputPath = '', verbose = False)",
    "parameters": [
      {
        "name": "data_filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": null,
        "default": "''",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a mesh variable from an arbitrary vertex-based checkpoint file\nand reconstruct/interpolate the data field accordingly. The data sizes / meshes can be\ndifferent and will be matched using a kd-tree / inverse-distance weighting\nto the new mesh.",
    "harvested_comments": [
      "Fix this to match the write_timestep function",
      "mesh.write_timestep( \"test\", meshUpdates=False, meshVars=[X], outputPath=\"\", index=0)",
      "swarm.write_timestep(\"test\", \"swarm\", swarmVars=[var], outputPath=\"\", index=0)",
      "check if data_file exists",
      "Keep vector available for future access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "fn",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1206,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists (deprecated)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "ijk",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1213,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1220,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the sympy.Matrix view of this variable",
    "harvested_comments": [
      "Note: Scaling is applied during unwrap(), not here"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1228,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to a flattened version of the sympy.Matrix view of this variable.\nAssume components are stored in the same order that sympy iterates entries in\na matrix except for the symmetric tensor case where we store in a Voigt form",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1496,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this variable belongs to (accessed via weak reference).\nRaises RuntimeError if the mesh has been garbage collected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "vec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1513,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "The corresponding PETSc local vector for this variable.",
    "harvested_comments": [
      "Ensure vector is initialized when accessed"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1527,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "TESTING: Original data property implementation.\nNumpy proxy array to underlying variable data.\nNote that the returned array is a proxy for all the *local* nodal\ndata, and is provided as 1d list.\n\nFor both read and write, this array can only be accessed via the\nmesh `access()` context manager.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1542,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view of canonical data with automatic format conversion.\nShape: (N, a, b) for tensor shape (a, b).\n\nThis property is ALWAYS a view of the canonical .data property.\nNo direct PETSc access - all changes delegate back to canonical storage.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2212,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Canonical data storage with PETSc synchronization.\nShape: (-1, num_components) - flat format for backward compatibility.\n\nThis is the ONLY property that handles PETSc synchronization to avoid conflicts.\nThe .array property uses this as its underlying storage with format conversion.\n\nReturns\n-------\nNDArray_With_Callback\n    Array with shape (-1, num_components) with automatic PETSc synchronization",
    "harvested_comments": [
      "Cache and reuse canonical data object to avoid field access conflicts",
      "Use direct __dict__ check to avoid potential attribute access issues",
      "Create the single canonical data array with PETSc sync"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2300,
    "signature": "(self, array_value)",
    "parameters": [
      {
        "name": "array_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set variable data using pack method to handle shape transformation.",
    "harvested_comments": [
      "Use pack method to handle proper data transformation and shape conversion"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "min",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2354,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable minimum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of minimum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "max",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2382,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable maximum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of maximum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sum",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2410,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable sum value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "norm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2438,
    "signature": "(self, norm_type) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "norm_type",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable norm value.\n\nnorm_type: type of norm, one of\n    - 0: NORM 1 ||v|| = sum_i | v_i |. ||A|| = max_j || v_*j ||\n    - 1: NORM 2 ||v|| = sqrt(sum_i |v_i|^2) (vectors only)\n    - 3: NORM INFINITY ||v|| = max_i |v_i|. ||A|| = max_i || v_i* ||, maximum row sum\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mean",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2471,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable mean value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "std",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2498,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable standard deviation value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw values from PETSc",
      "For scalar: std = sqrt((sum(x^2)/n) - (sum(x)/n)^2)",
      "Create a temporary vector for x^2 computation",
      "Calculate variance: E[x^2] - (E[x])^2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2554,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Universal statistics method for all variable types.\n\nReturns various statistical measures appropriate for the variable type.\nFor scalars: standard statistical measures.\nFor vectors: magnitude-based statistics.\nFor tensors: Frobenius norm and invariant-based measures.\n\nReturns\n-------\ndict\n    Dictionary containing statistical measures:\n    - 'type': Variable type ('scalar', 'vector', 'tensor')\n    - 'components': Number of components\n    - 'size': Number of elements\n    - 'mean': Mean value (scalar) or magnitude mean (vector/tensor)\n    - 'min': Minimum value (scalar) or magnitude min (vector/tensor)\n    - 'max': Maximum value (scalar) or magnitude max (vector/tensor)\n    - 'sum': Sum of all values\n    - 'norm2': L2 norm\n    - 'rms': Root mean square\n\n    Additional keys for vectors/tensors:\n    - 'magnitude_*': Statistics on vector magnitude\n    - 'frobenius_*': Statistics on tensor Frobenius norm (for tensors)\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2720,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of variable vertex coordinates for this variable's DOF locations.\n\nReturns coordinates for this variable's specific degree-of-freedom locations,\nwhich may differ from mesh coordinate variable locations if the degrees differ.\n\nWhen mesh has reference quantities set, returns unit-aware coordinates in meters.",
    "harvested_comments": [
      "Get non-dimensional [0-1] model coordinates for this variable's specific DOF locations",
      "If mesh has units, dimensionalise to physical coordinates",
      "Dimensionalise using the proper units system",
      "Specify length dimensionality since coords have dimension [length]",
      "No units - return non-dimensional coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords_nd",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2750,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "Non-dimensional [0-1] coordinates for this variable's DOF locations.\n\nReturns raw model coordinates from PETSc without any unit wrapping.\nThis is the coordinate system used by internal KDTree indexing, evaluation,\nand other algorithmic operations.\n\nFor user-facing operations with physical units, use `.coords` which returns\ndimensional coordinates when the model has reference quantities set.\n\nReturns\n-------\nndarray\n    Non-dimensional [0-1] coordinates, shape (N, dim)\n\nExamples\n--------\n>>> # Internal algorithmic use - KDTree indexing\n>>> kd_tree = uw.kdtree.KDTree(var.coords_nd)\n>>>\n>>> # User-facing display with dimensional units\n>>> print(f\"Positions: {var.coords}\")  # Shows meters, km, etc.\n\nNotes\n-----\nThis is a zero-copy operation that returns a view of the cached coordinate\narray directly from the mesh. No memory allocation or copying occurs.\n\nSee Also\n--------\ncoords : Dimensional coordinates with unit wrapping (user-facing)",
    "harvested_comments": [
      "Internal algorithmic use - KDTree indexing",
      "User-facing display with dimensional units",
      "Shows meters, km, etc.",
      "Direct access to non-dimensional coordinates from mesh cache",
      "This is a ZERO-COPY operation - returns cached array directly"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 360,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the units associated with this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 365,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the units for this variable.",
    "harvested_comments": [
      "Convert string units to Pint Unit objects for consistency"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 374,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "use_legacy_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 936,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deprecated: Array interface is now unified using NDArray_With_Callback",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "use_enhanced_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 940,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deprecated: Array interface is now unified using NDArray_With_Callback",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sync_disabled",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 944,
    "signature": "(self, description = 'batch operation')",
    "parameters": [
      {
        "name": "description",
        "type_hint": null,
        "default": "'batch operation'",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager to disable automatic synchronization for batch operations.\nNow uses NDArray_With_Callback's delay_callback mechanism.\n\nParameters\n----------\ndescription : str\n    Description of the batch operation for debugging",
    "harvested_comments": [
      "Use NDArray_With_Callback's built-in delay mechanism"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1157,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced pack method that directly accesses PETSc field without access() context.\nDesigned for the new swarmVariable.array interface.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data to pack into PETSc field\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Direct PETSc field access without context manager",
      "Pack data using same layout as original method",
      "Increment variable state to track changes",
      "Update the proxy mesh variable if one exists (for integral calculations)",
      "Sync parallel operations if requested"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1220,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced unpack method that directly accesses PETSc field without access() context.\nDesigned for the new swarmVariable.array interface.\n\nParameters\n----------\nsqueeze : bool\n    Whether to squeeze singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Direct PETSc field access without context manager",
      "Sync parallel operations if requested",
      "TODO: Add parallel sync logic here if needed",
      "Unpack data using same layout as original method",
      "Always restore the field"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1261,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data array to PETSc using traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data in traditional flat format (-1, num_components)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Convert to expected shape: (-1, num_components)",
      "Direct PETSc field access without context manager",
      "Direct assignment in traditional flat format",
      "Increment variable state to track changes",
      "Update the proxy mesh variable if one exists (for integral calculations)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1306,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc in traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in traditional flat format (-1, num_components)",
    "harvested_comments": [
      "Check if swarm has any particles before accessing field",
      "Swarm not populated yet, return empty array",
      "Direct PETSc field access without context manager",
      "Field not properly initialized, restore and return empty array",
      "Return data in traditional flat format"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "swarm",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1420,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The swarm this variable belongs to (accessed via weak reference).\nRaises RuntimeError if the swarm has been garbage collected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1437,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "TESTING: Original data property implementation.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1444,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Canonical data storage with PETSc synchronization.\nShape: (-1, num_components) - flat format for backward compatibility.\n\nThis is the ONLY property that handles PETSc synchronization to avoid conflicts.\nThe .array property uses this as its underlying storage with format conversion.\n\nReturns\n-------\nNDArray_With_Callback\n    Array with shape (-1, num_components) with automatic PETSc synchronization",
    "harvested_comments": [
      "Cache and reuse canonical data object to avoid field access conflicts",
      "Use direct __dict__ check to avoid MathematicalMixin recursion",
      "Create the single canonical data array with PETSc sync"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1466,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view of canonical data with automatic format conversion.\nShape: (N, a, b) for tensor shape (a, b).\n\nThis property is ALWAYS a view of the canonical .data property.\nNo direct PETSc access - all changes delegate back to canonical storage.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1477,
    "signature": "(self, array_value)",
    "parameters": [
      {
        "name": "array_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set variable data through canonical data property with format conversion.",
    "harvested_comments": [
      "Simple case: reshape array format (N,a,b) to canonical format (N,components)",
      "Complex case: use pack operations for tensor layout conversion",
      "Assign to canonical data property (triggers PETSc sync)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1492,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symbolic representation for use in equations.\n\nReturns the symbolic expression from the proxy mesh variable,\nwhich can be used in SymPy expressions for constitutive models,\nboundary conditions, etc.\n\nReturns\n-------\nsympy.Matrix\n    Symbolic matrix expression.\n\nNotes\n-----\nThe proxy is automatically updated if particle data has changed.",
    "harvested_comments": [
      "Ensure proxy is up to date before returning symbolic representation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 1513,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flattened symbolic representation.\n\nReturns the symbolic expression as a 1D (column) vector form,\nuseful for Voigt notation in tensor calculations.\n\nReturns\n-------\nsympy.Matrix\n    Flattened symbolic expression.",
    "harvested_comments": [
      "Ensure proxy is up to date before returning symbolic representation"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_max",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1534,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Maximum value across all MPI ranks.\n\nFinds the maximum value of the particle property across all processors.\nUseful for finding extreme values in particle swarm data.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Maximum value with units preserved (if variable has units).\n\nExamples\n--------\n>>> max_temp = temperature_swarm.global_max()\n>>> print(f\"Maximum temperature: {max_temp}\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [
      "Wrap data in UnitAwareArray to use its global_max implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_min",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1572,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Minimum value across all MPI ranks.\n\nFinds the minimum value of the particle property across all processors.\nUseful for finding extreme values in particle swarm data.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Minimum value with units preserved (if variable has units).\n\nExamples\n--------\n>>> min_pressure = pressure_swarm.global_min()\n>>> print(f\"Minimum pressure: {min_pressure}\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_sum",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1609,
    "signature": "(self, axis = None, out = None, keepdims = False)",
    "parameters": [
      {
        "name": "axis",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "out",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "keepdims",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Sum of values across all MPI ranks.\n\nComputes the sum of particle property values across all processors.\n\nParameters\n----------\naxis : None, int, or tuple of ints, optional\n    Axis or axes along which to operate. By default, flattened input is used.\nout : None, optional\n    Alternative output array (not supported, kept for API compatibility).\nkeepdims : bool, optional\n    If True, reduced axes are left as dimensions with size one.\n\nReturns\n-------\nUWQuantity or scalar\n    Sum with units preserved (if variable has units).\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.\n\nWarning: This sum is NOT a physical domain-integrated quantity because\nparticles are non-uniformly distributed. For domain integration, use\nthe proxy mesh variable with uw.maths.Integral().",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_norm",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1644,
    "signature": "(self, ord = None)",
    "parameters": [
      {
        "name": "ord",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "L2 norm (Frobenius norm) across all MPI ranks.\n\nComputes the L2 norm of particle property values: sqrt(sum(x**2))\nacross all processors.\n\nParameters\n----------\nord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional\n    Order of the norm (default: None = 2-norm)\n\nReturns\n-------\nUWQuantity or scalar\n    L2 norm with units preserved (if variable has units).\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.\n\nFor vectors, computes the Frobenius norm treating the array as flattened.\n\nWarning: This norm is NOT a physical domain-integrated quantity because\nparticles are non-uniformly distributed.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "global_size",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1677,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total particle count across all MPI ranks.\n\nReturns the total number of particles across all processors.\nUseful for population monitoring and load balancing diagnostics.\n\nReturns\n-------\nint\n    Total number of particles across all ranks.\n\nExamples\n--------\n>>> total_particles = swarm_var.global_size()\n>>> local_particles = swarm_var.data.shape[0]\n>>> print(f\"Rank has {local_particles} of {total_particles} particles\")\n\nNotes\n-----\nThis is a collective operation - all ranks must call it.\nThe result is identical on all ranks.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1706,
    "signature": "(self, filename: int, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save the swarm variable to a h5 file.\n\nParameters\n----------\nfilename :\n    The filename of the swarm variable to save to disk.\ncompression :\n    Add compression to the h5 files (saves space but increases write times with increasing no. of processors)\ncompressionType :\n    Type of compression to use, 'gzip' and 'lzf' supported. 'gzip' is default. Compression also needs to be set to 'True'.\n\nforce_sequential : activate the serial version of hdf5",
    "harvested_comments": [
      "# Add swarm variable unit metadata to the file",
      "Use preferred selective_ranks pattern for unit metadata",
      "Add swarm variable unit metadata",
      "Store in dataset attributes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2009,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Lazy evaluation of symbolic mask array.\n\nOnly updates proxy variables when they're actually needed (when sym is accessed)\nand only if the proxy variables are marked as stale due to data changes.\nThis avoids expensive RBF interpolation during data assignment operations.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "createMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2031,
    "signature": "(self, funcsList)",
    "parameters": [
      {
        "name": "funcsList",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This creates a masked sympy function of swarm variables required for Underworld's solvers",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "viewMask",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2048,
    "signature": "(self, sympy)",
    "parameters": [
      {
        "name": "sympy",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Takes a previously masked sympy function and returns individual sympy objects corresponding to each material",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2068,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Show information on IndexSwarmVariable",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2405,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this swarm operates on",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2413,
    "signature": "(self, new_mesh)",
    "parameters": [
      {
        "name": "new_mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Assign swarm to a new mesh with dimensional validation and proxy updates.\n\nParameters\n----------\nnew_mesh : uw.discretisation.Mesh\n    New mesh to assign this swarm to\n\nRaises\n------\nValueError\n    If new mesh has incompatible dimensions",
    "harvested_comments": [
      "Register new mesh with model",
      "Check if swarm is already compatible with target mesh",
      "Dimensions match, check if proxy variables need updating",
      "No change needed",
      "Use swarm's current dimensions for validation (not model.mesh which may have been auto-updated)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "local_size",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2488,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Number of particles on this MPI rank.\n\nReturns\n-------\nint\n    Local particle count.\n\nSee Also\n--------\ndm.getLocalSize : Underlying PETSc method.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2505,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Particle coordinates (alias for :attr:`points`).\n\n.. deprecated:: 0.99.0\n    Use swarm variable ``.data`` properties instead.\n\nReturns\n-------\nnumpy.ndarray\n    Particle coordinate array of shape ``(n_particles, dim)``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2519,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm particle coordinates in physical units.\n\n.. deprecated:: 0.99.0\n    Use swarm variables or direct DM access instead.\n    ``swarm.points`` is being deprecated.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from internal model coordinates\nto physical coordinates for user access.\n\nWhen the mesh has coordinate units specified, returns a unit-aware array.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Particle coordinates (with units if mesh.units is set)",
    "harvested_comments": [
      "Check for mesh coordinate changes and trigger migration if needed",
      "Mesh coordinates have changed, force migration to update swarm",
      "Update our mesh version to match",
      "Get current coordinate data from PETSc (these are in model coordinates)",
      "Apply scaling to convert model coordinates to physical coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2630,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set swarm particle coordinates from physical units.\n\n.. deprecated:: 0.99.0\n    Use swarm variables or direct DM access instead.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from physical coordinates\nto internal model coordinates for PETSc storage.\n\nArgs:\n    value (numpy.ndarray): Particle coordinates in physical units",
    "harvested_comments": [
      "Apply inverse scaling to convert physical coordinates to model coordinates",
      "Update the cached NDArray (triggers callback) - use physical coordinates for cache",
      "Update PETSc DM field directly with model coordinates for immediate consistency"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2689,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Swarm particle coordinates in physical units.\n\nThis is the primary public interface for accessing particle coordinates.\nCoordinates are automatically converted from internal model units to\nphysical units based on the model's reference quantities.\n\nReturns\n-------\nUWQuantity or numpy.ndarray\n    Particle coordinates in physical units with shape (n_particles, dim).\n    If model has reference quantities, returns UWQuantity with appropriate\n    length units. Otherwise returns plain array.\n\nNotes\n-----\n- Coordinates are converted from model units to physical units automatically\n- For internal use with model units, access `swarm._particle_coordinates.data`\n- Setting coordinates accepts either physical units or plain numbers\n\nExamples\n--------\n>>> coords_physical = swarm.coords  # Get physical coordinates\n>>> swarm.coords = new_coords_with_units  # Set from physical units\n\nSee Also\n--------\nswarm.units : Get the unit specification for coordinates",
    "harvested_comments": [
      "Get physical coordinates",
      "Set from physical units",
      "Get internal model-unit coordinates",
      "Convert to physical units",
      "Use from_model_magnitude to convert back to physical"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2731,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set swarm particle coordinates from physical units.\n\nAccepts coordinates with units or plain numbers. If units are provided,\nthey are converted to model units automatically. If plain numbers are\nprovided, they are assumed to be in the correct unit system.\n\nParameters\n----------\nvalue : array-like or UWQuantity\n    New coordinates. Can be:\n    - Array with units (e.g., values * uw.units.km)\n    - Plain array (assumed to be in model units or physical units depending on context)",
    "harvested_comments": [
      "Convert physical \u2192 non-dimensional units",
      "Set internal coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2755,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Unit specification for swarm coordinates.\n\nReturns the physical unit string for coordinates based on the model's\nreference quantities. This indicates what units the coordinates are in\nwhen accessed via the `coords` property.\n\nReturns\n-------\nstr or None\n    Unit string for coordinates (e.g., 'kilometer', 'meter'), or None\n    if no reference quantities are set\n\nExamples\n--------\n>>> print(swarm.units)  # 'kilometer' if length_scale was set in km\n>>> coords = swarm.coords  # Coordinates in kilometers",
    "harvested_comments": [
      "'kilometer' if length_scale was set in km",
      "Coordinates in kilometers",
      "Coordinates have length dimensions",
      "Check if model has reference quantities",
      "Get length scale from model"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "dont_clip_to_mesh",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2805,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Context manager that temporarily disables mesh clipping for the swarm.\n`swarm.migrate` is called automatically when exiting the context.\n\nUsage:\n    with swarm.dont_clip_to_mesh():\n        # swarm operations that should not be clipped to mesh\n        swarm.data = new_positions",
    "harvested_comments": [
      "swarm operations that should not be clipped to mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migration_disabled",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2833,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Legacy context manager that completely disables migration.\nUse migration_control(disable=True) for new code.\n\nContext manager that temporarily disables particle migration for the swarm.\nMigration is NOT called when exiting the context.\n\nUsage:\n    with swarm.migration_disabled():\n        # swarm operations that should not trigger migration\n        swarm.data = new_positions\n        # ... other operations ...\n        # migrate() will be skipped during these operations",
    "harvested_comments": [
      "swarm operations that should not trigger migration",
      "... other operations ...",
      "migrate() will be skipped during these operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migration_control",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2851,
    "signature": "(self, disable = False)",
    "parameters": [
      {
        "name": "disable",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Context manager to control particle migration behavior.\n\nParameters\n----------\ndisable : bool\n    If False (default), migration is deferred until context exit.\n    If True, migration is completely disabled.\n\nUsage:\n    # Defer migration until end (default)\n    with swarm.migration_control():\n        swarm.points[mask1] += delta1\n        swarm.points[mask2] *= scale\n        # Migration happens HERE on exit\n\n    # Completely disable migration\n    with swarm.migration_control(disable=True):\n        # Operations where migration should never happen\n        # No migration on exit",
    "harvested_comments": [
      "Defer migration until end (default)",
      "Migration happens HERE on exit",
      "Completely disable migration",
      "Operations where migration should never happen",
      "No migration on exit"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "populate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2903,
    "signature": "(self, fill_param: Optional[int] = 1)",
    "parameters": [
      {
        "name": "fill_param",
        "type_hint": "Optional[int]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Populate the swarm with particles throughout the domain.\n\nParameters\n----------\nfill_param:\n    Parameter determining the particle count per cell (per dimension)\n    for the given layout, using the mesh degree.\n\nRaises\n------\nRuntimeError\n    If the swarm has already been initialized with particles.",
    "harvested_comments": [
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count",
      "This is a mesh-local quantity, so let's just",
      "store it on the mesh in an ad_hoc fashion for now"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "migrate",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3002,
    "signature": "(self, remove_sent_points = True, delete_lost_points = None, max_its = 10)",
    "parameters": [
      {
        "name": "remove_sent_points",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "delete_lost_points",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "max_its",
        "type_hint": null,
        "default": "10",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Migrate swarm across processes after coordinates have been updated.\n\nThe algorithm uses a global kD-tree for the centroids of the domains to decide the particle mpi.rank (send to the closest)\nIf the particles are mis-assigned to a particular mpi.rank, the next choice is the second-closest and so on.\n\nA few particles are still not found after this distribution process which probably means they are just outside the mesh.\nIf some points remain lost, they will be deleted if `delete_lost_points` is set.\n\nImplementation note:\n    We retained (above) the name `DMSwarmPIC_coor` for the particle field to allow this routine to be inherited by a PIC swarm\n    which has this field pre-defined. (We'd need to add a cellid field as well, and re-compute it upon landing)\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "This will only worry about particles that are not already claimed !",
      "Unlikely, but we should check this",
      "Migrate particles between processes (if there are more than one of them)",
      "Send unclaimed points to next processor in line",
      "Now we send the points (basic migration)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_particles_with_coordinates",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3174,
    "signature": "(self, coordinatesArray) -> int",
    "parameters": [
      {
        "name": "coordinatesArray",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Add particles to the swarm using particle coordinates provided\nusing a numpy array.\n\nNote that particles with coordinates NOT local to the current processor will\nbe rejected / ignored.\n\nEither include an array with all coordinates to all processors\nor an array with the local coordinates.\n\nParameters\n----------\ncoordinatesArray : numpy.ndarray\n    The numpy array containing the coordinate of the new particles. Array is\n    expected to take shape n*dim, where n is the number of new particles, and\n    dim is the dimensionality of the swarm's supporting mesh.\n\nReturns\n--------\nnpoints: int\n    The number of points added to the local section of the swarm.",
    "harvested_comments": [
      "### petsc appears to ignore columns that are greater than the mesh dim, but still worth including",
      "-1 means no particles have been added yet (PETSc interface change)",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_particles_with_global_coordinates",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3249,
    "signature": "(self, globalCoordinatesArray, migrate = True, delete_lost_points = True) -> int",
    "parameters": [
      {
        "name": "globalCoordinatesArray",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "migrate",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "delete_lost_points",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": "int",
    "existing_docstring": "Add particles to the swarm using particle coordinates provided\nusing a numpy array.\n\nglobal coordinates: particles will be appropriately migrated\n\nParameters\n----------\nglobalCoordinatesArray : numpy.ndarray\n    The numpy array containing the coordinate of the new particles. Array is\n    expected to take shape n*dim, where n is the number of new particles, and\n    dim is the dimensionality of the swarm's supporting mesh.\n\nReturns\n--------\nnpoints: int\n    The number of points added to the local section of the swarm.",
    "harvested_comments": [
      "### petsc appears to ignore columns that are greater than the mesh dim, but still worth including",
      "-1 means no particles have been added yet",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero",
      "It allocates N-1 instead of N, so we add +1 to compensate",
      "PETSc 3.24+ fixed this bug, so we use the exact count"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3327,
    "signature": "(self, filename: int, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save the swarm coordinates to a h5 file.\n\nParameters\n----------\nfilename :\n    The filename of the swarm checkpoint file to save to disk.\ncompression :\n    Add compression to the h5 files (saves space but increases write times with increasing no. of processors)\ncompressionType :\n    Type of compression to use, 'gzip' and 'lzf' supported. 'gzip' is default. Compression also needs to be set to 'True'.",
    "harvested_comments": [
      "It seems to be a bad idea to mix mpi barriers with the access",
      "context manager so the copy-free version of this seems to hang",
      "when there are many active cores. This is probably why the parallel",
      "h5py write hangs",
      "It seems to be a bad idea to mix mpi barriers with the access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "add_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3478,
    "signature": "(self, name, size = 1, dtype = float, proxy_degree = 2, _nn_proxy = False, units = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "dtype",
        "type_hint": null,
        "default": "float",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "_nn_proxy",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Add a variable to the swarm.\n\nVariables must be created before the swarm is populated with particles.\nOnce swarm.populate() or similar methods are called, PETSc finalizes\nfield registration and no new variables can be added.\n\nParameters\n----------\nname : str\n    Variable name\nsize : int, default 1\n    Number of components (1 for scalar, 2-3 for vector, etc.)\ndtype : type, default float\n    Data type (float or int)\nproxy_degree : int, default 2\n    Degree for mesh proxy variable interpolation\n_nn_proxy : bool, default False\n    Internal parameter for nearest-neighbor proxy\nunits : str, optional\n    Physical units for this variable (e.g., \"kg/m^3\", \"m/s\")\n\nReturns\n-------\nSwarmVariable\n    The created swarm variable\n\nRaises\n------\nRuntimeError\n    If swarm is already populated with particles\n\nExamples\n--------\nCorrect usage:\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> material = swarm.add_variable(\"material\", 1, dtype=int)\n>>> temperature = swarm.add_variable(\"temperature\", 1)\n>>> swarm.populate(fill_param=3)  # Populate after creating variables\n\nIncorrect usage (will raise error):\n>>> swarm = uw.swarm.Swarm(mesh)\n>>> swarm.populate(fill_param=3)\n>>> material = swarm.add_variable(\"material\", 1)  # ERROR!",
    "harvested_comments": [
      "Populate after creating variables",
      "Check early to provide a clear error message",
      "Create variables first\\n\"",
      "Then populate with particles\""
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3555,
    "signature": "(self, swarmName: str, index: int, outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "swarmName",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the swarm and attached data to a .pbin and xdmf file.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3579,
    "signature": "(self, filename: str, swarmname: str, index: int, swarmVars: Optional[list] = None, outputPath: Optional[str] = '', time: Optional[int] = None, compression: Optional[bool] = False, compressionType: Optional[str] = 'gzip', force_sequential: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmname",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "time",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      },
      {
        "name": "compression",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "compressionType",
        "type_hint": "Optional[str]",
        "default": "'gzip'",
        "description": ""
      },
      {
        "name": "force_sequential",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save data to h5 and a corresponding xdmf for visualisation using h5py.\n\nParameters\n----------\nswarmName :\n    Name of the swarm to save.\nswarmVars :\n    List of swarm objects to save.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.\ntime :\n    Attach the time to the generated xdmf.\ncompression :\n    Whether to compress the h5 files [bool].\ncompressionType :\n    The type of compression to use. 'gzip' and 'lzf' are the supported types, with 'gzip' as the default.",
    "harvested_comments": [
      "This will eliminate the issue of whether or not to put path separators in the",
      "outputPath. Also does the right thing if outputPath is \"\"",
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 3729,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "List of SwarmVariables attached to this swarm.\n\nReturns\n-------\nlist\n    List of :class:`SwarmVariable` objects defined on this swarm.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3880,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "SwarmVariable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Dummy access manager that provides deferred sync for backward compatibility.\nUses NDArray_With_Callback.delay_callbacks_global() internally.\n\nThis is a compatibility wrapper that allows existing code using the access()\ncontext manager to work with the new direct-access variable interfaces.\nAll variable modifications are deferred and synchronized at context exit.\n\nParameters\n----------\nwriteable_vars\n    Variables that will be modified (ignored - all variables are writable\n    with the new interface, this parameter is kept for API compatibility)\n\nReturns\n-------\nContext manager that defers variable synchronization until exit\n\nNotes\n-----\nThis method is deprecated. New code should access variable.data or\nvariable.array directly without requiring an access context.",
    "harvested_comments": [
      "Use NDArray_With_Callback global delay context for deferred sync",
      "This triggers all accumulated callbacks from all variables"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4229,
    "signature": "(self, V_fn)",
    "parameters": [
      {
        "name": "V_fn",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the given\nmesh and velocity configuration.",
    "harvested_comments": [
      "we'll want to do this on an element by element basis",
      "for more general mesh",
      "first let's extract a max global velocity magnitude",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": true
  },
  {
    "name": "_BaseMeshVariable",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 73,
    "signature": "class _BaseMeshVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The MeshVariable class generates a variable supported by a finite element mesh and the\nunderlying sympy representation that makes it possible to construct expressions that\ndepend on the values of the MeshVariable.\n\nTo set / read nodal values, use the numpy interface via the 'data' property.\n\nParameters\n----------\nvarname :\n    A text name for this variable. Use an R-string if a latex-expression is used\nmesh :\n    The supporting underworld mesh.\nnum_components :\n    The number of components this variable has.\n    For example, scalars will have `num_components=1`,\n    while a 2d vector would have `num_components=2`.\nvtype :\n    Optional. The underworld variable type for this variable.\n    If not defined it will be inferred from `num_components`\n    if possible.\ndegree :\n    The polynomial degree for this variable.\nvarsymbol:\n    Over-ride the varname with a symbolic form for printing etc (latex). Should be an R-string.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 208,
    "signature": "(self, plex_or_meshfile, degree = 1, simplex = True, coordinate_system_type = None, qdegree = 2, markVertices = None, useRegions = None, useMultipleTags = None, filename = None, refinement = None, refinement_callback = None, coarsening = None, coarsening_callback = None, return_coords_to_bounds = None, boundaries = None, boundary_normals = None, name = None, units = None, verbose = False, *args, **kwargs)",
    "parameters": [
      {
        "name": "plex_or_meshfile",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "coordinate_system_type",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_coords_to_bounds",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundaries",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundary_normals",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Get coordinate units from model (not user parameter)",
      "The model owns the unit system - all meshes use the same units",
      "Ignore user-provided units parameter, get from model instead",
      "Set units from model",
      "Lock model units now that a mesh has been created"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 151,
    "signature": "(self, name, swarm, size = None, vtype = None, dtype = float, proxy_degree = 1, proxy_continuous = True, _register = True, _proxy = True, _nn_proxy = False, varsymbol = None, rebuild_on_cycle = True, units = None, units_backend = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "size",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "dtype",
        "type_hint": null,
        "default": "float",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_proxy",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "_nn_proxy",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "rebuild_on_cycle",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "only needed if MATRIX type",
      "Store unit metadata for variable",
      "Convert string units to Pint Unit objects for consistency with MeshVariable",
      "Parse string units to Pint Unit object",
      "uw.units('K') returns a Quantity (1 kelvin), so we extract .units to get the Unit"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1923,
    "signature": "(self, name, swarm, indices = 1, proxy_degree = 1, proxy_continuous = True, update_type = 0, npoints = 5, radius = 0.5, npoints_bc = 2, ind_bc = None, varsymbol = None)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "indices",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "proxy_continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "update_type",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "npoints",
        "type_hint": null,
        "default": "5",
        "description": ""
      },
      {
        "name": "radius",
        "type_hint": null,
        "default": "0.5",
        "description": ""
      },
      {
        "name": "npoints_bc",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "ind_bc",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "**2 # changed to radius",
      "These are the things we require of the generic swarm variable type",
      "The indices variable defines how many \"level set\" maps we create as components in the proxy variable",
      "Initialize lazy evaluation state",
      "Proxy variables need initial update"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2288,
    "signature": "(self, mesh, recycle_rate = 0, verbose = False, clip_to_mesh = True)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "recycle_rate",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "clip_to_mesh",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Store reference to model instead of direct mesh reference",
      "This enables dynamic mesh handover while maintaining access to mesh services",
      "Register mesh with model if not already present",
      "Store reference to this swarm's specific mesh for proxy operations",
      "Mesh version tracking for coordinate change detection"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 4290,
    "signature": "(self, trackedVariable: uw.discretisation.MeshVariable, verbose = False)",
    "parameters": [
      {
        "name": "trackedVariable",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Set up a standard swarm",
      "The launch point location",
      "The launch point index",
      "The launch point processor rank",
      "PETSc < 3.24 has an off-by-one bug in addNPoints when swarm size is initially zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "NodalPointSwarm",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 156,
    "signature": "(self, varname = None, mesh = None, num_components = None, vtype = None, degree = 1, continuous = True, varsymbol = None, _register = True, units = None, units_backend = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize MeshVariable (only called for NEW objects).\n\nRetrieves initialization parameters from __new__ and handles DM reconstruction.",
    "harvested_comments": [
      "Only initialize if this is a new object (not returned existing)",
      "Already initialized",
      "Get parameters - either from __new__ (via _init_params) or direct arguments",
      "Parameters from __new__ method",
      "Direct initialization (should not happen with __new__ pattern, but for safety)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1237,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_DS",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2095,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Build this from the PETScDS rather than the SWARM",
      "self._index.build_index()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2118,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "Use raw internal array for KD-tree construction (avoid unit-aware wrapping)",
      "for face in range(cell_num_faces):",
      "points = self.dm.getTransitiveClosure(cell_faces[face])[0][",
      "-face_num_points:"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_PIC",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2200,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Bootstrapping - the kd-tree is needed to build the index but",
      "# the index is also used in the kd-tree.",
      "Create a temp swarm which we'll use to populate particles",
      "at gauss points. These will then be used as basis for",
      "kd-tree indexing back to owning cells."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_domain_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2771,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1258,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_setup_ds",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1303,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "self.clean_name ## Filling up the options database",
      "only active if discontinuous",
      "Check if this is the first field or if we need to rebuild the DM",
      "(needed to ensure Section is properly synchronized with field list)",
      "DM already has fields - need to rebuild to sync Section"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_set_vec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1395,
    "signature": "(self, available)",
    "parameters": [
      {
        "name": "available",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "not sure if required, but to be sure.",
      "This is set for checkpointing."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1489,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 958,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_proxy_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1005,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "release if defined"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "__getitem__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2028,
    "signature": "(self, index)",
    "parameters": [
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_particle_coordinates",
    "kind": "property",
    "file": "src/underworld3/swarm.py",
    "line": 2685,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3932,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_get_map",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3961,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "generate tree if not avaiable",
      "get or generate map",
      "we can't use numpy arrays directly as keys in python dicts, so",
      "we'll use `xxhash` to generate a hash of array.",
      "this shouldn't be an issue performance wise but we should test to be"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_from_gmsh",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 47,
    "signature": "(filename, comm = None, markVertices = False, useRegions = True, useMultipleTags = True)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a Gmsh .msh file from `filename`.\n\n:kwarg comm: Optional communicator to build the mesh on (defaults to\n    COMM_WORLD).",
    "harvested_comments": [
      "# NOTE: - this should be smart enough to serialise the msh conversion",
      "# and then read back in parallel via h5.  This is currently done",
      "# by every gmesh mesh",
      "This option allows objects to be in multiple physical groups",
      "Rather than just the first one found."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_from_plexh5",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 117,
    "signature": "(filename, comm = None, return_sf = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_sf",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a dmplex .h5 file from `filename` provided.\n\ncomm: Optional communicator to build the mesh on (defaults to\nCOMM_WORLD).",
    "harvested_comments": [
      "h5plex = PETSc.DMPlex().createFromFile(filename, comm=comm)",
      "Do this as well"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_deform_mesh",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1241,
    "signature": "(self, new_coords: numpy.ndarray, verbose = False)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method will update the mesh coordinates and reset any cached coordinates in\nthe mesh and in equation systems that are registered on the mesh.\n\nThe coord array that is passed in should match the shape of self.data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_legacy_access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1258,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying mesh variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "Invalidate DMInterpolation cache when DM structure changes",
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "create & set vec"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_var",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2035,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [
      "if array already created, return."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_basis",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2050,
    "signature": "(self, degree, continuous)",
    "parameters": [
      {
        "name": "degree",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2256,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each mesh face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the plane\ndefined by a face (i.e. same side or other side as the cell centroid). If we are inside\nfor all faces in a convex polyhedron, then we are inside the cell.\n\nInternal Coordinate System Access Pattern\n------------------------------------------\nThis method uses `self._coords` (raw PETSc array) instead of `self.data`\nor `self.X.coords` (unit-wrapped properties) for performance and correctness:\n\n1. **Guard at boundaries**: External interfaces use unit-aware properties\n2. **Raw access internally**: Internal geometric calculations use `self._coords`\n3. **Performance**: Avoids UnitAwareArray overhead in tight loops\n4. **Correctness**: Prevents unit conversion issues in geometric operations\n\nThis is the recommended pattern for internal mesh operations that manipulate\ncoordinates directly.",
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "All elements in our mesh are a single type",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Compute face normal from point coordinates (already plain numpy arrays)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_test_if_points_in_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2351,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test",
    "harvested_comments": [
      "Internal version - points assumed to already be in model units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_local_boundary_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2390,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each boundary-defining face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the domain.\nWe cannot ensure convexity, so this is approximate when close to the boundary",
    "harvested_comments": [
      "Use raw array for internal calculations",
      "3D simplex case (probably also OK for hexes)",
      "Control points near centroid",
      "Control points closer to face nodes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_closest_local_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2573,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Internal version - coords assumed to already be in model units",
      "Create index if required",
      "We need to filter points that lie outside the mesh but",
      "still are allocated a nearby element by this distance-only check.",
      "Part 2 - try to find the lost points by walking nearby cells"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_sizes",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2718,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Obtain the (local) mesh radii and centroids using kdtree distances\nThis routine is called when the mesh is built / rebuilt",
    "harvested_comments": [
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2752,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Obtain and cache the (local) mesh centroids using underworld swarm technology.\nThis routine is called when the mesh is built / rebuilt\n\nThe global cell number corresponding to a centroid is (supposed to be)\nself.dm.getCellNumbering().array.min() + index",
    "harvested_comments": [
      ") = petsc_discretisation.petsc_fvm_get_local_cell_sizes(self)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_increment_mesh_version",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2906,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Manually increment mesh version to notify swarms of coordinate changes.\nThis is called automatically when mesh.points is modified, but can be\ncalled manually if coordinates are changed through other means.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 102,
    "signature": "(cls, varname: Union[str, list], mesh: 'Mesh', num_components: Union[int, tuple] = None, vtype: Optional['uw.VarType'] = None, degree: int = 1, continuous: bool = True, varsymbol: Union[str, list] = None, _register: bool = True, units: Optional[str] = None, units_backend: Optional[str] = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": "Union[str, list]",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": "Union[int, tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "Optional['uw.VarType']",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Union[str, list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create or return existing MeshVariable instance.\n\nHandles object uniqueness and mesh DM state management.",
    "harvested_comments": [
      "# Check if already defined (return existing object)",
      "NOTE: DM reconstruction is now handled in _setup_ds() - no snapshotting needed here",
      "Create new instance",
      "Store parameters for __init__"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_variable_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 455,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for variable data.\nFollows the same pattern as mesh.points implementation.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Create NDArray_With_Callback (following mesh._points pattern)",
      "Allow operations like existing arrays",
      "Single callback function (following mesh_update_callback pattern)",
      "Only act on data-changing operations (following mesh.points pattern)",
      "Prevent recursion by checking if we're already in a callback"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_flat_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 518,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for backward-compatible flat data.\nReturns data in shape (-1, num_components) using pack_raw/unpack_raw methods.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Use unpack_raw to get flat format (-1, num_components)",
      "Create NDArray_With_Callback for flat data",
      "Allow operations like existing arrays",
      "Callback for flat data format",
      "Only act on data-changing operations"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 580,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This will substitute specific information about this object",
    "harvested_comments": [
      "feedback on this instance"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_replace_from_adapted_mesh",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1407,
    "signature": "(self, temp_var, adapted_mesh)",
    "parameters": [
      {
        "name": "temp_var",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "adapted_mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Replace internal storage after mesh adaptation.\n\nCalled by mesh.adapt() to update this variable's internal PETSc\nstructures after the mesh's discretization has changed. The data\nhas already been interpolated to temp_var; this method copies that\ndata into this variable's updated storage.\n\nParameters\n----------\ntemp_var : MeshVariable\n    A temporary variable on the adapted mesh containing the\n    interpolated data for this variable.\nadapted_mesh : Mesh\n    The mesh object (same object, but with updated internal DM).\n\nNotes\n-----\nThis is an internal method called by mesh.adapt(). Users should\nnot need to call this directly.\n\nAfter this method returns, all user references to this variable\nremain valid and contain the interpolated data on the adapted mesh.",
    "harvested_comments": [
      "Destroy old PETSc vectors",
      "The mesh reference is still valid (same object, updated internals)",
      "But we need to find/create our field on the new DM",
      "Check if our field exists on the new DM",
      "Need to add field to new DM (this happens if adapt() didn't pre-create variables)"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1552,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create array view of canonical data using appropriate conversion strategy.\n\nStrategy depends on variable complexity:\n- Scalars/Vectors: Simple reshape operations\n- 2D+ Tensors: Complex pack/unpack operations\n\nReturns\n-------\nArrayView\n    Array-like object that delegates changes back to canonical data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_is_simple_variable",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1570,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this is a simple scalar/vector variable (not a complex tensor)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_simple_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1574,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for scalars/vectors using simple reshape operations",
    "harvested_comments": [
      "Simple reshape: (-1, num_components) -> (N, a, b)",
      "For simple variables, reshape to (N, a, b) format",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_tensor_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1902,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for complex tensors using pack/unpack operations",
    "harvested_comments": [
      "Use complex pack/unpack for tensor layouts",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray",
      "Get variable units (needed for both branches)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_canonical_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2233,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create the single canonical data array with PETSc synchronization for MeshVariable.\nThis is the ONLY method that creates arrays with PETSc callbacks.\n\nHandles mesh-specific requirements like locking and ghost value synchronization.\n\nReturns\n-------\nNDArray_With_Callback\n    Canonical array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Ensure PETSc vector is available",
      "Get direct access to PETSc vector in packed format",
      "Create NDArray_With_Callback with proper shape and data",
      "Single canonical callback for PETSc synchronization",
      "Only act on data-changing operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_dimensionalise_stat",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2309,
    "signature": "(self, value: Union[float, tuple]) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Union[float, tuple]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "Helper to dimensionalise statistical values using uw.dimensionalise().\n\nTakes non-dimensional value(s) from PETSc and converts to dimensional\nform using the variable's units and model reference quantities.\n\nParameters\n----------\nvalue : float or tuple\n    Non-dimensional value(s) from PETSc\n\nReturns\n-------\nfloat, tuple, or UWQuantity\n    Dimensionalised value(s) if units are enabled, else unchanged",
    "harvested_comments": [
      "Check if units mode is enabled",
      "Backward compatible - no units mode or variable has no units",
      "Extract dimensionality from units",
      "self.units is already a Pint Unit object with .dimensionality attribute",
      "Pint Unit object - extract dimensionality directly"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_scalar_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2617,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for scalar variables (original implementation).",
    "harvested_comments": [
      "Now returns value directly, not tuple",
      "Now returns value directly, not tuple"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_vector_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2641,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for vector variables using magnitude.",
    "harvested_comments": [
      "Create temporary scalar variable for magnitude",
      "Compute magnitude: |v| = sqrt(v\u00b7v)",
      "Get scalar stats on magnitude",
      "Update with vector-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_tensor_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2679,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for tensor variables using Frobenius norm.",
    "harvested_comments": [
      "Create temporary scalar variable for Frobenius norm",
      "Compute Frobenius norm: ||A||_F = sqrt(sum(A_ij^2))",
      "Get scalar stats on Frobenius norm",
      "Update with tensor-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_variable_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 378,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for variable data.\nFollows the same pattern as swarm.points implementation.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Create NDArray_With_Callback (following swarm._points pattern)",
      "Allow operations like existing arrays",
      "Single callback function (following swarm_update_callback pattern)",
      "Only act on data-changing operations (following swarm.points pattern)",
      "Skip updates during coordinate changes to prevent corruption"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_canonical_data_array",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 422,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create the single canonical data array with PETSc synchronization.\nThis is the ONLY method that creates arrays with PETSc callbacks.\n\nReturns data in shape (-1, num_components) using pack_raw/unpack_raw methods.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Canonical array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Use unpack_raw to get flat format (-1, num_components)",
      "Handle case where unpack returns None (swarm not initialized)",
      "Create NDArray_With_Callback for flat data",
      "Allow operations like existing arrays",
      "Single canonical callback for PETSc synchronization"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 490,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create array view of canonical data using appropriate conversion strategy.\n\nStrategy depends on variable complexity:\n- Scalars/Vectors: Simple reshape operations\n- 2D+ Tensors: Complex pack/unpack operations\n\nReturns\n-------\nArrayView\n    Array-like object that delegates changes back to canonical data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_is_simple_variable",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 508,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this is a simple scalar/vector variable (not a complex tensor)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_simple_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 512,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for scalars/vectors using simple reshape operations",
    "harvested_comments": [
      "Simple reshape: (-1, num_components) -> (N, a, b)",
      "For simple variables, reshape to (N, a, b) format",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_create_tensor_array_view",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 722,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for complex tensors using pack/unpack operations",
    "harvested_comments": [
      "Use complex pack/unpack for tensor layouts",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray",
      "If ND scaling is active, data is non-dimensional and needs dimensionalization"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_pack_array_to_data_format",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 929,
    "signature": "(self, array_data)",
    "parameters": [
      {
        "name": "array_data",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Convert array format (N,a,b) back to canonical data format (N,components)",
    "harvested_comments": [
      "Use existing pack logic but return numpy array instead of writing to PETSc",
      "This is a pure conversion method - no PETSc access"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1021,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mark proxy mesh variable as stale for lazy evaluation.\nThe actual update happens when the proxy is accessed.",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "Mark proxy as stale for lazy evaluation (avoids immediate PETSc access conflicts)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update_proxy_if_stale",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1036,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Actually update the proxy mesh variable if it's marked as stale.\nThis implements lazy evaluation to avoid PETSc access conflicts.",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "Only update if stale and not already updating",
      "Mark as fresh"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_rbf_to_meshVar",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1060,
    "signature": "(self, meshVar, nnn = None, verbose = False)",
    "parameters": [
      {
        "name": "meshVar",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Here is how it works: for each particle, create a distance-weighted average on the node data\n\nTodo: caching the k-d trees etc for the proxy-mesh-variable nodal points\nTodo: some form of global fall-back for when there are no particles on a processor",
    "harvested_comments": [
      "Mapping to the coordinates of the variable from the",
      "particle coords",
      "If this is our own proxy variable and mesh has changed, recreate it",
      "Use the newly created proxy variable"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_rbf_reduce_to_meshVar",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1091,
    "signature": "(self, meshVar, verbose = False)",
    "parameters": [
      {
        "name": "meshVar",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method updates a mesh variable for the current\nswarm & particle variable state by reducing the swarm to\nthe nearest point for each particle\n\nHere is how it works:\n\n    1) for each particle, create a distance-weighted average on the node data\n    2) check to see which nodes have zero weight / zero contribution and replace with nearest particle value\n\nTodo: caching the k-d trees etc for the proxy-mesh-variable nodal points\nTodo: some form of global fall-back for when there are no particles on a processor",
    "harvested_comments": [
      "if not proxied, nothing to do. return.",
      "1 - Average particles to nodes with distance weighted average",
      "Use non-dimensional coordinates for internal KDTree (matches swarm.data coordinate system)",
      "need actual distances",
      "2 - set NN vals on mesh var where w == 0.0"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1358,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This will substitute specific information about this object",
    "harvested_comments": [
      "feedback on this instance"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SwarmVariable",
    "is_public": false
  },
  {
    "name": "_update",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1990,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Backward compatibility wrapper for _update_proxy_variables.\n\nMaintains existing API while implementing lazy evaluation internally.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_on_data_changed",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 1998,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Hook called by unified data callback when canonical data changes.\n\nFor IndexSwarmVariable, this marks proxy variables as stale for lazy evaluation.\nThis replaces the complex custom array override with a simple hook.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "_update_proxy_variables",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2075,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This method updates the proxy mesh (vector) variable for the index variable on the current swarm locations\n\nHere is how it works:\n\n    1) for each particle, create a distance-weighted average on the node data\n    2) for each index in the set, we create a mask mesh variable by mapping 1.0 wherever the\n       index matches and 0.0 where it does not.\n\nNOTE: If no material is identified with a given nodal value, the default is to impose\na near-neighbour hunt for a valid material and set that one\n\n## ToDo: This should be revisited to match the updated master copy of _update\n\nupdate_type 0: assign the particles to the nearest mesh_levelset nodes, and calculate the value on nodes from them.\nupdate_type 1: calculate the material property value on mesh_levelset nodes from the nearest N particles directly.",
    "harvested_comments": [
      "# ToDo: This should be revisited to match the updated master copy of _update",
      "Use non-dimensional coordinates for internal level set KDTree",
      "n, d, b = kd_swarm.find_closest_point(self._meshLevelSetVars[0].coords)",
      "if there is no material found,",
      "impose a near-neighbour hunt for a valid material and set that one"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "IndexSwarmVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 2395,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Cleanup swarm by unregistering from mesh to prevent memory leaks",
    "harvested_comments": [
      "Mesh/Model may have already been garbage collected, which is fine"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_force_migration_after_mesh_change",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3140,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Force migration of swarm particles after mesh coordinate changes.\n\nThis method bypasses the normal migration_disabled check since mesh\ncoordinate changes require swarm particles to be re-distributed\nregardless of migration disabled state.",
    "harvested_comments": [
      "Temporarily override migration disabled state",
      "Disable variable array callbacks during migration to prevent corruption",
      "Collect all variable arrays and disable their callbacks",
      "Perform standard migration",
      "Re-enable variable array callbacks"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  },
  {
    "name": "_legacy_access",
    "kind": "method",
    "file": "src/underworld3/swarm.py",
    "line": 3739,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "SwarmVariable",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying swarm variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nAt the conclusion of the users context managed block, numerous further operations\nwill be automatically executed. This includes swarm parallel migration routines\nwhere the swarm's `particle_coordinates` variable has been modified. The swarm\nvariable proxy mesh variables will also be updated for modifed swarm variables.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "grab numpy object, setting read only if necessary",
      "increment variable state"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Swarm",
    "is_public": false
  }
]