[
  {
    "name": "SNES_Poisson",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 154,
    "signature": "class SNES_Poisson",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Poisson equation solver.\n\nProvides a discrete representation of the Poisson equation:\n\n.. math::\n\n    \\nabla \\cdot \\left[ \\boldsymbol{\\kappa} \\nabla u \\right] = f\n\nwhere :math:`\\mathbf{F} = \\boldsymbol{\\kappa} \\nabla u` relates the flux to\ngradients in the unknown :math:`u`.\n\nAttributes\n----------\nu : MeshVariable\n    The unknown scalar field.\nconstitutive_model : DiffusionModel\n    Provides the diffusivity tensor :math:`\\kappa`. Set to one of the\n    scalar ``uw.constitutive_models`` classes. Can be constant, spatially\n    varying, non-linear, or anisotropic.\nf : sympy.Expr\n    Volumetric source term.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Darcy",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 316,
    "signature": "class SNES_Darcy",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Darcy flow equation solver for groundwater problems.\n\nProvides a discrete representation of the groundwater flow equations:\n\n.. math::\n\n    \\underbrace{S_s \\frac{\\partial h}{\\partial t}}_{\\dot{u}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa} \\nabla h\n    - \\boldsymbol{s} \\right]}_{\\mathbf{F}}\n    = \\underbrace{W}_{h}\n\nThe flux term :math:`\\mathbf{F}` relates the effective velocity to\npressure gradients:\n\n.. math::\n\n    \\boldsymbol{v} = \\boldsymbol{\\kappa} \\nabla h - \\boldsymbol{s}\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nh_Field : MeshVariable, optional\n    Mesh variable for hydraulic head. Created automatically if not provided.\nv_Field : MeshVariable, optional\n    Mesh variable for Darcy velocity. Created automatically if not provided.\ndegree : int, default=2\n    Polynomial degree for the finite element discretization.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : optional\n    Time derivative operator for the unknown.\nDFDt : optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nh : MeshVariable\n    The hydraulic head unknown.\nv : MeshVariable\n    The Darcy velocity field.\ns : sympy.Expr\n    Source term for pressure gradients (e.g., :math:`\\rho g`).\nSs : sympy.Expr\n    Specific storage coefficient.\n\nNotes\n-----\n- The unknown is :math:`h`, the hydraulic head\n- The permeability tensor :math:`\\kappa` is set via the ``constitutive_model``\n  property using one of the ``uw.constitutive_models`` classes\n- :math:`W` is a pressure source term\n- :math:`S_s` is the specific storage coefficient\n- The time-dependent term :math:`\\dot{f}` is not implemented in this version\n- The solver returns both the primary field and the Darcy flux (mean-flow velocity)\n\nSee Also\n--------\nSNES_Poisson : Related diffusion-only solver.\nuw.constitutive_models.DarcyFlowModel : Constitutive model for Darcy flow.",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 525,
    "signature": "class SNES_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Stokes equation solver for incompressible viscous flow.\n\nThis class provides functionality for a discrete representation\nof the Stokes flow equations assuming an incompressibility\n(or near-incompressibility) constraint.\n\nThe momentum equation is:\n\n.. math::\n\n    -\\nabla \\cdot \\left[ \\boldsymbol{\\tau} - p \\mathbf{I} \\right] = \\mathbf{f}\n\nwith the incompressibility constraint:\n\n.. math::\n\n    \\nabla \\cdot \\mathbf{u} = 0\n\nThe flux term is a deviatoric stress (:math:`\\boldsymbol{\\tau}`) related to velocity\ngradients (:math:`\\nabla \\mathbf{u}`) through a viscosity tensor :math:`\\eta`, and a\nvolumetric (pressure) part :math:`p`:\n\n.. math::\n\n    \\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\nThe constraint equation gives incompressible flow by default but can be set\nto any function of the unknown :math:`\\mathbf{u}` and :math:`\\nabla \\cdot \\mathbf{u}`.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The computational mesh.\nvelocityField : uw.discretisation.MeshVariable, optional\n    Pre-existing velocity field. If None, one is created automatically.\npressureField : uw.discretisation.MeshVariable, optional\n    Pre-existing pressure field. If None, one is created automatically.\ndegree : int, optional\n    Polynomial degree for velocity interpolation. Default is 2.\np_continuous : bool, optional\n    If True (default), pressure is continuous. Set False for discontinuous pressure.\nverbose : bool, optional\n    Enable verbose output during solving. Default is False.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for velocity (used in derived classes).\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for flux (used in viscoelastic models).\n\nAttributes\n----------\nu : MeshVariable\n    The velocity field (accessed via ``solver.Unknowns.u``).\np : MeshVariable\n    The pressure field (accessed via ``solver.Unknowns.p``).\nbodyforce : UWexpression\n    Volumetric body force vector :math:`\\mathbf{f}`.\nconstitutive_model : ConstitutiveModel\n    Viscosity model providing the stress-strain relationship.\npenalty : UWexpression\n    Augmented Lagrangian penalty parameter :math:`\\lambda`.\nsaddle_preconditioner : sympy.Expr\n    Preconditioner for the saddle point system (default: :math:`1/\\eta`).\nconstraints : sympy.Matrix\n    Constraint equation(s), default is :math:`\\nabla \\cdot \\mathbf{u}`.\n\nNotes\n-----\n**Viscosity model**: The viscosity tensor :math:`\\boldsymbol{\\eta}` is provided by\nsetting the ``constitutive_model`` property to one of the ``uw.constitutive_models``\nclasses. It may be constant, spatially varying, non-linear, or anisotropic.\n\n**Augmented Lagrangian**: Setting ``penalty`` to a non-zero value adds\n:math:`\\lambda \\nabla \\cdot \\mathbf{u}` to the weak form, improving convergence\nfor incompressible flow (in addition to the constraint equation).\n\n**Mixed finite elements**: The pressure field interpolation order determines\nthe integration order of the mixed method and is typically lower than the\nvelocity field order.\n\n**Viscoelastic models**: For viscoelastic behaviour, the flux term contains\nstress history tracked on a particle swarm. See :class:`SNES_VE_Stokes`.\n\nSee Also\n--------\nSNES_VE_Stokes : Viscoelastic Stokes solver with flux history.\nSNES_NavierStokes : Navier-Stokes solver with inertial terms.\nuw.constitutive_models : Available viscosity models.\n\nExamples\n--------\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1), cellSize=0.1)\n>>> stokes = uw.systems.Stokes(mesh, degree=2)\n>>> stokes.constitutive_model = uw.constitutive_models.ViscousFlowModel()\n>>> stokes.constitutive_model.Parameters.viscosity = 1.0\n>>> stokes.bodyforce = [0, -1]  # gravity\n>>> stokes.solve()",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_VE_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1081,
    "signature": "class SNES_VE_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoelastic Stokes equation solver.\n\nProvides a discrete representation of the Stokes flow equations with\nincompressibility (or near-incompressibility) constraint and a flux\nhistory term for viscoelastic modelling. Inherits from :class:`SNES_Stokes`.\n\nMomentum equation:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\tau} - p \\mathbf{I}\n    \\right]}_{\\mathbf{F}} = \\underbrace{\\mathbf{f}}_{\\mathbf{h}}\n\nContinuity equation:\n\n.. math::\n\n    \\underbrace{\\nabla \\cdot \\mathbf{u}}_{\\mathbf{h}_p} = 0\n\nThe flux term is a deviatoric stress :math:`\\boldsymbol{\\tau}` related\nto velocity gradients :math:`\\nabla \\mathbf{u}` through a viscosity\ntensor :math:`\\eta`, plus a volumetric (pressure) part :math:`p`:\n\n.. math::\n\n    \\mathbf{F}: \\quad \\boldsymbol{\\tau} = \\frac{\\eta}{2}\n    \\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\nThe constraint equation :math:`\\mathbf{h}_p = 0` is incompressible flow\nby default but can be set to any function of :math:`\\mathbf{u}` and\n:math:`\\nabla \\cdot \\mathbf{u}`.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nvelocityField : MeshVariable, optional\n    Mesh variable for velocity. Created automatically if not provided.\npressureField : MeshVariable, optional\n    Mesh variable for pressure. Created automatically if not provided.\ndegree : int, default=2\n    Polynomial degree for velocity elements.\norder : int, default=2\n    Order parameter (typically same as degree).\np_continuous : bool, default=True\n    If False, use discontinuous pressure elements.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator (may be used in child classes).\n\nAttributes\n----------\nu : MeshVariable\n    Velocity field unknown :math:`\\mathbf{u}`.\np : MeshVariable\n    Pressure field unknown :math:`p`.\nbodyforce : sympy.Expr\n    Body force term :math:`\\mathbf{f}`.\npenalty : float\n    Augmented Lagrangian penalty parameter :math:`\\lambda`.\nsaddle_preconditioner : sympy.Expr\n    Preconditioner for saddle point system (default: :math:`1/\\eta`).\n\nNotes\n-----\n- The viscosity tensor :math:`\\boldsymbol{\\eta}` is set via the\n  ``constitutive_model`` property\n- For viscoelastic problems, the flux term contains stress history\n  tracked on a particle swarm\n- Augmented Lagrangian approach adds :math:`\\lambda \\nabla \\cdot \\mathbf{u}`\n  to penalize incompressibility\n- Pressure element order determines mixed FEM integration order\n\nSee Also\n--------\nSNES_Stokes : Base Stokes solver.\nuw.constitutive_models.ViscoElasticPlasticFlowModel : Constitutive model for VE flow.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1285,
    "signature": "class SNES_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Scalar projection solver for mapping functions to mesh variables.\n\nSolves :math:`u = \\tilde{f}` where :math:`\\tilde{f}` is a function that\ncan be evaluated within an element and :math:`u` is a mesh variable with\nassociated shape functions.\n\nTypically used to obtain a continuous representation of a function not\nwell-defined at mesh nodes (e.g., derivatives or flux components). More\nbroadly, it is a projection from one basis to another.\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla u \\right]}_{\\mathbf{F}}\n    - \\underbrace{\\left[ u - \\tilde{f} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    Target mesh variable for the projection.\nscalar_Field : MeshVariable, optional\n    Alternative name for the target field.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nsolver_name : str, optional\n    Name for the solver instance.\nverbose : bool, default=False\n    Enable verbose output.\n\nAttributes\n----------\nuw_function : sympy.Expr\n    The function :math:`\\tilde{f}` to project.\nsmoothing : float\n    The regularization parameter :math:`\\alpha`.\n\nSee Also\n--------\nSNES_Vector_Projection : Vector field projection.\nSNES_Tensor_Projection : Tensor field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Vector_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1404,
    "signature": "class SNES_Vector_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Vector projection solver for mapping vector functions to mesh variables.\n\nSolves :math:`\\mathbf{u} = \\tilde{\\mathbf{f}}` where :math:`\\tilde{\\mathbf{f}}`\nis a vector function that can be evaluated within an element and\n:math:`\\mathbf{u}` is a vector mesh variable with associated shape functions.\n\nTypically used to obtain a continuous representation of a vector function\nnot well-defined at mesh nodes (e.g., gradient or flux vectors).\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla \\mathbf{u}\n    \\right]}_{\\mathbf{F}} - \\underbrace{\\left[ \\mathbf{u}\n    - \\tilde{\\mathbf{f}} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable, optional\n    Target vector mesh variable for the projection.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nverbose : bool, default=False\n    Enable verbose output.\n\nAttributes\n----------\nuw_function : sympy.Matrix\n    The vector function :math:`\\tilde{\\mathbf{f}}` to project.\nsmoothing : float\n    The regularization parameter :math:`\\alpha`.\n\nSee Also\n--------\nSNES_Projection : Scalar field projection.\nSNES_Tensor_Projection : Tensor field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Tensor_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1542,
    "signature": "class SNES_Tensor_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Tensor projection solver for mapping tensor functions to mesh variables.\n\nSolves :math:`\\mathbf{u} = \\tilde{\\mathbf{f}}` where :math:`\\tilde{\\mathbf{f}}`\nis a tensor-valued function that can be evaluated within an element and\n:math:`\\mathbf{u}` is a tensor mesh variable with associated shape functions.\n\nTypically used to obtain a continuous representation of a tensor function\nnot well-defined at mesh nodes (e.g., stress or strain tensors).\n\nThe projection is implemented by solving:\n\n.. math::\n\n    -\\nabla \\cdot \\underbrace{\\left[ \\alpha \\nabla \\mathbf{u}\n    \\right]}_{\\mathbf{F}} - \\underbrace{\\left[ \\mathbf{u}\n    - \\tilde{\\mathbf{f}} \\right]}_{\\mathbf{h}} = 0\n\nThe term :math:`\\mathbf{F}` provides optional smoothing regularization.\nSetting :math:`\\alpha = 0` gives a pure L2 projection.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\ntensor_Field : MeshVariable, optional\n    Target tensor mesh variable for the projection.\nscalar_Field : MeshVariable, optional\n    Scalar work variable used internally.\ndegree : int, default=2\n    Polynomial degree for the finite element space.\nverbose : bool, default=False\n    Enable verbose output.\n\nNotes\n-----\nCurrently implemented component-wise as there is no native solver\nfor tensor unknowns.\n\nSee Also\n--------\nSNES_Projection : Scalar field projection.\nSNES_Vector_Projection : Vector field projection.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_AdvectionDiffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1687,
    "signature": "class SNES_AdvectionDiffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Advection-diffusion equation solver using semi-Lagrangian Crank-Nicolson.\n\nImplements the characteristics-based method described in Spiegelman & Katz (2006):\n\n.. math::\n\n    \\underbrace{\\frac{\\partial u}{\\partial t} + \\left( \\mathbf{v} \\cdot \\nabla\n    \\right) u}_{\\dot{u}} - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa}\n    \\nabla u \\right]}_{\\mathbf{F}} = \\underbrace{f}_{\\mathbf{h}}\n\nThe flux term :math:`\\mathbf{F}` relates diffusive fluxes to gradients in\n:math:`u`. Advective fluxes along the velocity field :math:`\\mathbf{v}` are\nhandled in the :math:`\\dot{u}` term.\n\nThe time derivative :math:`\\dot{u}` involves upstream sampling to find\n:math:`u^*`, the value of :math:`u` at points which later arrive at mesh\nnodes. This is achieved using a hidden swarm variable advected backwards\nfrom nodal points automatically during solve.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable\n    Mesh variable for the transported scalar.\nV_fn : MeshVariable or sympy.Basic\n    Velocity field for advection.\norder : int, default=1\n    Time integration order (1 or 2).\nrestore_points_func : callable, optional\n    Function to restore particles to valid domain.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for the unknown.\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nu : MeshVariable\n    The scalar unknown.\nf : sympy.Expr\n    Volumetric source term.\n\nNotes\n-----\n- The diffusivity :math:`\\kappa` is set via the ``constitutive_model`` property\n- Sources :math:`f` can be any sympy expression involving mesh/swarm variables\n\nReferences\n----------\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson\nalgorithm for the numerical solution of advection-diffusion problems.\n*Geochemistry, Geophysics, Geosystems*, 7(4).\nhttps://doi.org/10.1029/2005GC001073\n\nSee Also\n--------\nSNES_Diffusion : Pure diffusion solver without advection.\nSNES_Navier_Stokes : Full momentum advection-diffusion.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Diffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2200,
    "signature": "class SNES_Diffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusion equation solver using mesh-based finite elements.\n\nSolves the scalar diffusion equation:\n\n.. math::\n\n    \\underbrace{\\frac{\\partial u}{\\partial t}}_{\\dot{f}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\boldsymbol{\\kappa} \\nabla u\n    \\right]}_{\\mathbf{F}} = \\underbrace{f}_{h}\n\nThe flux term :math:`\\mathbf{F}` relates diffusive fluxes to gradients\nin the unknown :math:`u`.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nu_Field : MeshVariable\n    Mesh variable for the diffusing scalar.\norder : int, default=1\n    Time integration order.\ntheta : float, default=0.0\n    Time integration parameter (0=explicit, 0.5=Crank-Nicolson, 1=implicit).\nevalf : bool, default=False\n    Numerically evaluate symbolic expressions during setup.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : Eulerian_DDt, SemiLagrangian_DDt, or Lagrangian_DDt, optional\n    Time derivative operator for the unknown.\nDFDt : Eulerian_DDt, SemiLagrangian_DDt, or Lagrangian_DDt, optional\n    Time derivative operator for the flux.\n\nAttributes\n----------\nu : MeshVariable\n    The scalar unknown.\nf : sympy.Expr\n    Volumetric source term.\n\nNotes\n-----\n- The diffusivity :math:`\\kappa` is set via the ``constitutive_model`` property\n- Sources :math:`f` can be any sympy expression involving mesh/swarm variables\n\nSee Also\n--------\nSNES_AdvectionDiffusion : Adds advection transport.\nSNES_Poisson : Steady-state diffusion (no time derivative).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_NavierStokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2576,
    "signature": "class SNES_NavierStokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Navier-Stokes equation solver with momentum advection.\n\nProvides a solver for the Navier-Stokes (vector advection-diffusion) equation\nsimilar to the Semi-Lagrange Crank-Nicolson method (Spiegelman & Katz, 2006)\nbut using distributed upstream sampling from a swarm variable.\n\n.. math::\n\n    \\underbrace{\\frac{\\partial \\mathbf{u}}{\\partial t}\n    + \\left( \\mathbf{u} \\cdot \\nabla \\right) \\mathbf{u}}_{\\dot{\\mathbf{u}}}\n    - \\nabla \\cdot \\underbrace{\\left[ \\frac{\\boldsymbol{\\eta}}{2}\n    \\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n    - p \\mathbf{I} \\right]}_{\\mathbf{F}} = \\underbrace{\\mathbf{f}}_{\\mathbf{h}}\n\nThe flux term :math:`\\mathbf{F}` relates viscous stresses to velocity gradients.\nAdvective momentum transport is handled in the :math:`\\dot{\\mathbf{u}}` term.\n\nThe time derivative :math:`\\dot{\\mathbf{u}}` involves upstream sampling to find\n:math:`\\mathbf{u}^*`, representing velocity at the start of the timestep. This is\nachieved using a swarm variable that carries history information along flow paths.\n\nParameters\n----------\nmesh : Mesh\n    The computational mesh.\nvelocityField : MeshVariable\n    Mesh variable for velocity.\npressureField : MeshVariable\n    Mesh variable for pressure.\nrho : float or sympy.Expr\n    Fluid density.\norder : int, default=1\n    Time integration order.\ntheta : float, default=0.5\n    Time integration parameter.\np_continuous : bool, default=True\n    If False, use discontinuous pressure elements.\nverbose : bool, default=False\n    Enable verbose output.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for velocity.\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Time derivative operator for stress.\n\nAttributes\n----------\nu : MeshVariable\n    Velocity field unknown.\np : MeshVariable\n    Pressure field unknown.\nrho : sympy.Expr\n    Fluid density.\nbodyforce : sympy.Expr\n    Body force term :math:`\\mathbf{f}`.\n\nNotes\n-----\n- The viscosity :math:`\\eta` is set via the ``constitutive_model`` property\n- High-order shape functions (cubic or higher) are recommended for accurate\n  history term interpolation\n- The user must supply and update the swarm variable representing :math:`\\mathbf{u}^*`\n\nReferences\n----------\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson\nalgorithm for the numerical solution of advection-diffusion problems.\n*Geochemistry, Geophysics, Geosystems*, 7(4).\nhttps://doi.org/10.1029/2005GC001073\n\nSee Also\n--------\nSNES_Stokes : Steady-state Stokes flow (no inertia).\nSNES_AdvectionDiffusion : Scalar advection-diffusion.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "AnisotropicDiffusionModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1490,
    "signature": "class AnisotropicDiffusionModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Constitutive_Model",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 103,
    "signature": "class Constitutive_Model",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Base class for constitutive laws relating gradients to fluxes.\n\nConstitutive laws relate gradients in the unknowns to fluxes of quantities\n(for example, heat fluxes are related to temperature gradients through a\nthermal conductivity). This class is a base class for building Underworld\nconstitutive laws.\n\nIn a scalar problem, the relationship is:\n\n.. math::\n\n    q_i = k_{ij} \\frac{\\partial T}{\\partial x_j}\n\nand the constitutive parameters describe :math:`k_{ij}`. The template\nassumes :math:`k_{ij} = \\delta_{ij}`.\n\nIn a vector problem (such as the Stokes problem), the relationship is:\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{\\partial u_k}{\\partial x_l}\n\nbut is usually written to eliminate the anti-symmetric part of the\ndisplacement or velocity gradients:\n\n.. math::\n\n    t_{ij} = c_{ijkl} \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nand the constitutive parameters describe :math:`c_{ijkl}`. The template\nassumes :math:`k_{ij} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})`\nwhich is the 4th rank identity tensor accounting for symmetry in the flux\nand the gradient terms.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscousFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 431,
    "signature": "class ViscousFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscous flow constitutive model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination. This results in an\nisotropic (but not necessarily homogeneous or linear) relationship between\n:math:`\\tau` and the velocity gradients.\n\nYou can also supply :math:`\\eta_{IJ}`, the Mandel form of the constitutive\ntensor, or :math:`\\eta_{ijkl}`, the rank-4 tensor.\n\nThe Mandel constitutive matrix is available in ``viscous_model.C`` and the\nrank-4 tensor form is in ``viscous_model.c``.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 630,
    "signature": "class ViscoPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoplastic flow constitutive model with yield stress.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination. This results in an\nisotropic (but not necessarily homogeneous or linear) relationship between\n:math:`\\tau` and the velocity gradients.\n\nIn a viscoplastic model, this viscosity is defined to cap the value of the\noverall stress at a value known as the *yield stress*. In this constitutive\nlaw, we assume that the yield stress is a scalar limit on the 2nd invariant\nof the stress. A general, anisotropic model needs to define the yield surface\ncarefully and only a subset of possible cases is available in Underworld.\n\nThis constitutive model is a convenience function that simplifies the code\nat run-time but can be reproduced by using the appropriate SymPy functions\nin the standard viscous constitutive model. **If you see** ``not~yet~defined``\n**in the definition of the effective viscosity, this means you have not yet\ndefined all the required functions.** The behaviour is to default to the\nstandard viscous constitutive law if yield terms are not specified.\n\nThe Mandel constitutive matrix is available in ``viscoplastic_model.C`` and the rank-4 tensor form is\nin `viscoplastic_model.c`.  Apply the constitutive model using:\n\n---",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ViscoElasticPlasticFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 817,
    "signature": "class ViscoElasticPlasticFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Viscoelastic-plastic flow constitutive model.\n\nThe stress (flux term) is given by:\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination. This results in an\nisotropic (but not necessarily homogeneous or linear) relationship between\n:math:`\\tau` and the velocity gradients. You can also supply :math:`\\eta_{IJ}`,\nthe Mandel form of the constitutive tensor, or :math:`\\eta_{ijkl}`, the rank-4 tensor.\n\nThe Mandel constitutive matrix is available in `viscous_model.C` and the rank 4 tensor form is\nin `viscous_model.c`.  Apply the constitutive model using:",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DiffusionModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1391,
    "signature": "class DiffusionModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Diffusion (Fourier/Fick) constitutive model.\n\n.. math::\n\n    q_{i} = \\kappa_{ij} \\cdot \\frac{\\partial \\phi}{\\partial x_j}\n\nwhere :math:`\\kappa` is a diffusivity, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination.\n\nExamples\n--------\n>>> diffusion_model = DiffusionModel(dim)\n>>> diffusion_model.material_properties = diffusion_model.Parameters(\n...     diffusivity=diffusivity_fn\n... )\n>>> scalar_solver.constitutive_model = diffusion_model\n>>> flux = diffusion_model.flux(gradient_matrix)",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "GenericFluxModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1550,
    "signature": "class GenericFluxModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A generic constitutive model with symbolic flux expression.\n\nExample usage:\n```python\ngrad_phi = sympy.Matrix([sp.Symbol(\"\u2202\u03c6/\u2202x\"), sp.Symbol(\"\u2202\u03c6/\u2202y\")])\nflux_expr = sympy.Matrix([[kappa_11, kappa_12], [kappa_21, kappa_22]]) * grad_phi\n\nmodel = GenericFluxModel(dim=2)\nmodel.flux = flux_expr\nscalar_solver.constititutive_model = model\n```",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "DarcyFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1624,
    "signature": "class DarcyFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Darcy flow constitutive model for porous media.\n\n.. math::\n\n    q_{i} = \\kappa_{ij} \\cdot \\left( \\frac{\\partial \\phi}{\\partial x_j} - s \\right)\n\nwhere :math:`\\kappa` is the permeability, a scalar constant, SymPy function,\nUnderworld mesh variable, or any valid combination. :math:`s` is the body\nforce 'source' of pressure gradients.\n\nExamples\n--------\n>>> darcy_model = DarcyFlowModel(dim)\n>>> darcy_model.material_properties = darcy_model.Parameters(\n...     permeability=permeability_fn\n... )\n>>> scalar_solver.constitutive_model = darcy_model\n>>> flux = darcy_model.flux",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "TransverseIsotropicFlowModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1751,
    "signature": "class TransverseIsotropicFlowModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Transversely isotropic (anisotropic) viscous flow model.\n\n.. math::\n\n    \\tau_{ij} = \\eta_{ijkl} \\cdot \\frac{1}{2} \\left[ \\frac{\\partial u_k}{\\partial x_l}\n    + \\frac{\\partial u_l}{\\partial x_k} \\right]\n\nwhere :math:`\\eta` is the viscosity tensor defined as:\n\n.. math::\n\n    \\eta_{ijkl} = \\eta_0 \\cdot I_{ijkl} + (\\eta_0-\\eta_1) \\left[ \\frac{1}{2} \\left[\n    n_i n_l \\delta_{jk} + n_j n_k \\delta_{il} + n_i n_l \\delta_{jk}\n    + n_j n_l \\delta_{ik} \\right] - 2 n_i n_j n_k n_l \\right]\n\nand :math:`\\hat{\\mathbf{n}} \\equiv \\{n_i\\}` is the unit vector defining\nthe local orientation of the weak plane (a.k.a. the director).\n\nThe Mandel constitutive matrix is available in ``viscous_model.C`` and the\nrank-4 tensor form is in ``viscous_model.c``.\n\nExamples\n--------\n>>> viscous_model = TransverseIsotropicFlowModel(dim)\n>>> viscous_model.material_properties = viscous_model.Parameters(\n...     eta_0=viscosity_fn,\n...     eta_1=weak_viscosity_fn,\n...     director=orientation_vector_fn\n... )\n>>> solver.constitutive_model = viscous_model\n>>> tau = viscous_model.flux(gradient_matrix)\n---",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "MultiMaterialConstitutiveModel",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1945,
    "signature": "class MultiMaterialConstitutiveModel",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Multi-material constitutive model using level-set weighted flux averaging.\n\nMathematical Foundation:\n\n.. math::\n\n    \\mathbf{f}_{\\text{composite}}(\\mathbf{x}) = \\sum_{i=1}^{N}\n    \\phi_i(\\mathbf{x}) \\cdot \\mathbf{f}_i(\\mathbf{x})\n\nCritical Architecture:\n\n- Solver owns Unknowns (including :math:`D\\mathbf{F}/Dt` stress history)\n- All constituent models share solver's Unknowns\n- Composite flux becomes stress history for all materials",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "poisson_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 220,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f1 residual term (weighted integration) - scalar function",
      "f1 residual term (integration by parts / gradients)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 251,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle UWQuantity with units - enforce \"units everywhere\" principle",
      "Extract the plain value",
      "If ND scaling is active, scale the constant",
      "The source term should have same dimensionality as the unknown field",
      "Access via self.Unknowns.u (Poisson) or self.Unknowns.DuDt.u (Stokes)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 312,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "darcy_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 436,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f1 residual term (weighted integration)",
      "f1 residual term (integration by parts / gradients)",
      "Flow calculation"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 449,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 453,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "darcy_flux",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 458,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 463,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 467,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 700,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p0 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 714,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 891,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 917,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Convert UWQuantity objects to SymPy expressions before Matrix creation",
      "If UWQuantity contains a Matrix, extract the scalar element"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 957,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 989,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1211,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1376,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1380,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1385,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1389,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "projection_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1491,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "residual terms - defines the problem:",
      "solve for a best fit to the continuous mesh",
      "variable given the values in self.function",
      "F0 is left in place for the user to inject",
      "non-linear constraints if required"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1514,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1518,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1523,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1527,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1533,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1537,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1611,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Loop over the components of the tensor. If this is a symmetric",
      "tensor, we'll usually be given the 1d form to prevent duplication",
      "if self.t_field.sym_1d.shape != self.uw_function.shape:",
      "raise ValueError(",
      "\"Tensor shapes for uw_function and MeshVariable are not the same\""
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1642,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1656,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1670,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1674,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1854,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1868,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "adv_diff_slcn_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1881,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1908,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1967,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2357,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2371,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2385,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2389,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2394,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2398,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2754,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "I think this should be bdf(1) ... the higher order",
      "terms are introduced through the adams_moulton fluxes"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2772,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "We can flag to only do this if the constitutive model has been updated",
      "Is the else condition useful - other than to prevent a crash ?",
      "Yes, because then it can just live on the Stokes solver ..."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "PF0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2802,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "navier_stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2817,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p1 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2830,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2834,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2839,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2843,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2848,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2852,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2857,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2863,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2867,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2871,
    "signature": "(self, DuDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DuDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2879,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2883,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2887,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2893,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2897,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2902,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2906,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2912,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2916,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 231,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the Poisson equation.\n\nThe source term :math:`f` appears on the right-hand side:\n\n.. math::\n    \\nabla \\cdot (\\kappa \\nabla u) = f\n\nReturns\n-------\nsympy.Matrix\n    Source term expression (scalar, shape ``(1, 1)``).\n\nSee Also\n--------\nconstitutive_model : Provides the diffusivity :math:`\\kappa`.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 472,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, verbose: bool = False, _force_setup: bool = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.\ntimestep:\n    value used to evaluate inertial contribution",
    "harvested_comments": [
      "Solve pressure",
      "Now solve flow field",
      "self._v_projector.petsc_options[\"snes_rtol\"] = 1.0e-6",
      "self._v_projector.petsc_options.delValue(\"ksp_monitor\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 718,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Symmetric strain rate tensor from velocity gradients.\n\nThe strain rate tensor :math:`\\dot{\\varepsilon}` is computed as:\n\n.. math::\n    \\dot{\\varepsilon}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}\n    + \\frac{\\partial u_j}{\\partial x_i}\\right)\n\nReturns\n-------\nsympy.Matrix\n    Symmetric tensor of shape ``(dim, dim)`` where ``dim`` is the\n    mesh dimensionality.\n\nSee Also\n--------\nstrainrate_1d : Voigt notation (vector) form.\nstress_deviator : Deviatoric stress computed from strain rate.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 741,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Strain rate in Voigt notation (vector form).\n\nConverts the symmetric strain rate tensor to Voigt notation for\nuse in constitutive model calculations. In 2D, returns a 3-component\nvector; in 3D, a 6-component vector.\n\nReturns\n-------\nsympy.Matrix\n    Strain rate in Voigt notation.\n\nSee Also\n--------\nstrainrate : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_star_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 760,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Historical strain rate in Voigt notation (for viscoelastic models).\n\nUsed in viscoelastic formulations where the stress depends on\nboth current and historical strain rates.\n\nReturns\n-------\nsympy.Matrix\n    Historical strain rate in Voigt notation.\n\nSee Also\n--------\nstrainrate_1d : Current strain rate.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 778,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deviatoric stress tensor from the constitutive model.\n\nThe deviatoric stress :math:`\\boldsymbol{\\tau}` is the traceless part\nof the stress tensor, computed by the constitutive model from the\nstrain rate:\n\n.. math::\n    \\boldsymbol{\\tau} = \\boldsymbol{\\eta} : \\dot{\\boldsymbol{\\varepsilon}}\n\nFor a Newtonian fluid: :math:`\\boldsymbol{\\tau} = 2\\eta\\dot{\\boldsymbol{\\varepsilon}}`\n\nReturns\n-------\nsympy.Matrix\n    Deviatoric stress tensor of shape ``(dim, dim)``.\n\nSee Also\n--------\nstress : Total stress (deviatoric + pressure).\nconstitutive_model : Provides the viscosity relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 803,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Deviatoric stress in Voigt notation.\n\nReturns\n-------\nsympy.Matrix\n    Deviatoric stress in Voigt notation.\n\nSee Also\n--------\nstress_deviator : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 818,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total Cauchy stress tensor.\n\nThe total stress combines the deviatoric stress and pressure:\n\n.. math::\n    \\boldsymbol{\\sigma} = \\boldsymbol{\\tau} - p\\mathbf{I}\n\nwhere :math:`\\boldsymbol{\\tau}` is the deviatoric stress and\n:math:`p` is the pressure (positive in compression).\n\nReturns\n-------\nsympy.Matrix\n    Total stress tensor of shape ``(dim, dim)``.\n\nSee Also\n--------\nstress_deviator : Deviatoric (traceless) part.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 841,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Total stress in Voigt notation.\n\nReturns\n-------\nsympy.Matrix\n    Total stress in Voigt notation.\n\nSee Also\n--------\nstress : Full tensor form.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 856,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Velocity divergence.\n\nFor incompressible flow, this should be zero:\n\n.. math::\n    \\nabla \\cdot \\mathbf{u} = 0\n\nReturns\n-------\nsympy.Expr\n    Scalar divergence expression.\n\nNotes\n-----\nNon-zero divergence indicates compressibility or mass sources/sinks.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 876,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constraint equation for the saddle-point system.\n\nBy default, this is the incompressibility constraint\n:math:`\\nabla \\cdot \\mathbf{u} = 0`. Can be modified for\ncompressible or other constrained formulations.\n\nReturns\n-------\nsympy.Expr\n    Constraint expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 897,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Body force vector (source term).\n\nThe volumetric body force :math:`\\mathbf{f}` appears on the\nright-hand side of the momentum equation:\n\n.. math::\n    -\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}\n\nCommon examples include gravity (:math:`\\rho\\mathbf{g}`) or\nbuoyancy forces.\n\nReturns\n-------\nUWexpression\n    Body force vector expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 937,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Preconditioner for the Schur complement in the saddle-point system.\n\nFor the Stokes system, the default preconditioner is :math:`1/\\eta`\n(inverse viscosity), which approximates the Schur complement\n:math:`\\mathbf{S} \\approx \\mathbf{B}\\mathbf{A}^{-1}\\mathbf{B}^T`.\n\nReturns\n-------\nsympy.Expr\n    Preconditioner expression (typically inverse viscosity).\n\nNotes\n-----\nA good preconditioner significantly improves convergence of the\niterative solver. For variable viscosity, use the local viscosity.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 963,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Augmented Lagrangian penalty parameter.\n\nThe penalty :math:`\\lambda` adds a term to the weak form that\npenalizes non-zero divergence:\n\n.. math::\n    \\lambda \\int (\\nabla \\cdot \\mathbf{u})(\\nabla \\cdot \\mathbf{v}) \\, dV\n\nThis improves convergence for incompressible flow without\nchanging the solution (since :math:`\\nabla \\cdot \\mathbf{u} = 0`\nat convergence).\n\nReturns\n-------\nUWexpression\n    Penalty parameter (typically a large constant, e.g., ``1e6 * eta``).\n\nNotes\n-----\nSet to zero for standard Stokes without augmentation.\nTypical values are ``O(10^6)`` times the characteristic viscosity.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1003,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the Stokes solver.\n\nThe Stokes equations are quasi-static (no time derivative \u2202v/\u2202t),\nso there is no diffusive CFL constraint. The only relevant timescale\nis the advective one: how long it takes material to cross an element.\n\nThis method computes a per-element timestep:\n    dt_i = h_i / |v_i|\n\nwhere h_i is the element radius and v_i is the velocity at the element\ncentroid, then returns the global minimum. This is more accurate than\nusing global max velocity with global min element size, especially for\nnon-uniform meshes with spatially varying velocity.\n\nReturns:\n    Pint Quantity or float: The advective timestep with physical time units\n    if a model with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "Evaluate velocity at element centroids (consistent with AdvDiff)",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii",
      "Note: .magnitude returns physical units, which would be wrong here",
      "Plain UWQuantity without units context - use magnitude"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1218,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1891,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Source term for the advection-diffusion equation.\n\nThe source :math:`f` appears on the right-hand side:\n\n.. math::\n    \\frac{\\partial u}{\\partial t} + \\mathbf{V} \\cdot \\nabla u\n    = \\nabla \\cdot (\\kappa \\nabla u) + f\n\nReturns\n-------\nsympy.Matrix\n    Source term expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1913,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Velocity field for advection.\n\nThe advection velocity :math:`\\mathbf{V}` transports the scalar\nfield :math:`u`. Can be a MeshVariable or symbolic expression.\n\nReturns\n-------\nsympy.Matrix\n    Velocity vector expression.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1927,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the velocity function for advection.\n\nParameters:\n-----------\nvalue : uw.discretisation.MeshVariable or sympy.Basic\n    Velocity field as either a MeshVariable or sympy expression",
    "harvested_comments": [
      "Mark as needing setup when velocity changes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1943,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Timestep for time integration.\n\nThe timestep :math:`\\Delta t` controls the temporal discretization.\nFor explicit advection, this should satisfy the CFL condition:\n\n.. math::\n    \\Delta t < \\frac{h}{|\\mathbf{V}|}\n\nwhere :math:`h` is the element size and :math:`|\\mathbf{V}|` is the\nvelocity magnitude.\n\nReturns\n-------\nUWexpression\n    Timestep value.\n\nSee Also\n--------\nestimate_dt : Computes a stable timestep automatically.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2011,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the advection-diffusion solver.\n\nThis is an implicit solver so the returned :math:`\\delta t` is the\nminimum of:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for diffusion across an element\n- :math:`\\delta t_{\\textrm{adv}}`: typical element-crossing time for a fluid parcel\n\nReturns\n-------\npint.Quantity or float\n    The recommended timestep with physical time units if a model\n    with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2143,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, _evalf = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing.",
      "Invalidate cached data views - PETSc may have replaced underlying buffers",
      "This ensures .data and .array properties return fresh data from PETSc"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2442,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the diffusion solver.\n\nThis solver only has a diffusive component, so the returned\n:math:`\\delta t` is:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for diffusion across an element\n\nReturns\n-------\npint.Quantity or float\n    The diffusive timestep with physical time units if a model\n    with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2517,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, evalf: bool = False, _force_setup: bool = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "self._flux =  self.constitutive_model.flux.T",
      "self._flux_star =  self._flux.copy()",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2921,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, _evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2987,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Estimate an appropriate timestep for the Navier-Stokes solver.\n\nThis is an implicit solver, so the returned :math:`\\delta t` should\nbe interpreted as:\n\n- :math:`\\delta t_{\\textrm{diff}}`: typical time for vorticity diffusion across an element\n- :math:`\\delta t_{\\textrm{adv}}`: typical element-crossing time for a fluid parcel\n\nThe Navier-Stokes equations include momentum diffusion via kinematic\nviscosity :math:`\\nu = \\eta/\\rho`, so the diffusive timestep is computed\nfrom this quantity.\n\nReturns\n-------\ntuple\n    (:math:`\\delta t_{\\textrm{diff}}`, :math:`\\delta t_{\\textrm{adv}}`)",
    "harvested_comments": [
      "## required modules",
      "For Navier-Stokes, diffusivity is the kinematic viscosity: \u03bd = \u03b7/\u03c1",
      "Use the unified .K property from the constitutive model (returns viscosity)",
      "Evaluate the viscosity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "validate_parameters",
    "kind": "function",
    "file": "src/underworld3/constitutive_models.py",
    "line": 60,
    "signature": "(symbol, input, default = None, allow_number = True, allow_expression = True)",
    "parameters": [
      {
        "name": "symbol",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "input",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "default",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "allow_number",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "allow_expression",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "CRITICAL: Check for UWexpression FIRST, before checking sympy.Basic",
      "UWexpression inherits from sympy.Symbol, so it would match the Basic check",
      "and cause double-wrapping, losing unit information",
      "Already a UWexpression - return as-is, no wrapping needed",
      "Convert UWQuantity to UWexpression - this is the beautiful symmetry!"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Unknowns",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 256,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "Unknowns",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 261,
    "signature": "(self, unknowns)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 273,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 277,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "return mesh.vector.gradient(self.Unknowns.u.sym)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 283,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 287,
    "signature": "(self, DuDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DuDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 296,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 301,
    "signature": "(self, DFDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DFDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 526,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 557,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 738,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "detect if values we need are defined or are placeholder symbols",
      "Don't put conditional behaviour in the constitutive law",
      "when it is not needed",
      "# Question is, will sympy reliably differentiate something",
      "# with so many Max / Min statements. The smooth version would"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "plastic_correction",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 781,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": null,
    "harvested_comments": [
      "The yield criterion in this case is assumed to be a bound on the second invariant of the stress"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "ve_effective_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 982,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "the dt_elastic defaults to infinity, t_relax to zero,",
      "so this should be well behaved in the viscous limit",
      "Note, 1st order only here but we should add higher order versions of this",
      "1st Order version (default)",
      "2nd Order version (need to ask for this one)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "t_relax",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1021,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "shear modulus defaults to infinity so t_relax goes to zero",
      "in the viscous limit"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "order",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1031,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "order",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1035,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1042,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_2star",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1049,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Check if we have enough information in DFDt to update _stress_star,",
      "otherwise it will be defined as zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "E_eff",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1062,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "E_eff_inv_II",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1089,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1097,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1101,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "detect if values we need are defined or are placeholder symbols",
      "# Do we want this to be an expression of its own ? If so, define above in __init__() and",
      "# make sure it is updated in this call, rather than being replaced.",
      "# Why is it p**2 here ?",
      "p = self.plastic_correction()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "plastic_correction",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1175,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "The yield criterion in this case is assumed to be a bound on the second invariant of the stress"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "is_elastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1369,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "If any of these is not defined, elasticity is switched off"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "is_viscoplastic",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1381,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1443,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1447,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1509,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "diffusivity",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1513,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Accept shape (dim, 1) or (1, dim)",
      "Validate each component using validate_parameters",
      "Store the validated diffusivity as a diagonal matrix"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1582,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1586,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Accept shape (dim, 1) or (1, dim)",
      "Flatten and validate"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1609,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "if self._flux is None:",
      "raise RuntimeError(\"Flux expression has not been set.\")"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GenericFluxModel",
    "is_public": true
  },
  {
    "name": "s",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1686,
    "signature": "(inner_self)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "s",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1690,
    "signature": "(inner_self, value: sympy.Matrix)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": "sympy.Matrix",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Update expression content in-place to preserve object identity",
      "Cannot use validate_parameters() as it doesn't handle matrices",
      "UWexpression.sym setter handles sympy.Matrix directly"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1698,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": true
  },
  {
    "name": "grad_u",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1859,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "create_unique_symbol",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 210,
    "signature": "(self, base_symbol, value, description)",
    "parameters": [
      {
        "name": "base_symbol",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "description",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create a unique symbol name for constitutive model parameters.\n\nSymbol naming priority:\n1. If material_name is set: \u03b7 \u2192 \u03b7_{material_name}\n2. Else if multiple instances of same class: \u03b7 \u2192 \u03b7^{(n)}\n3. Else: use base symbol as-is\n\nParameters\n----------\nbase_symbol : str\n    The base LaTeX symbol name (e.g., r\"\\eta\", r\"\\kappa\")\nvalue : float or expression\n    The initial value for the symbol\ndescription : str\n    Description of the parameter\n\nReturns\n-------\nUWexpression\n    Expression with unique symbol name",
    "harvested_comments": [
      "Priority 1: User-specified material name (subscript notation)",
      "Priority 2: Multiple instances of same class (superscript notation)",
      "Priority 3: First/only instance - clean symbol"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 267,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The constitutive property for this flow law",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "C",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 312,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The matrix form of the constitutive model (the `c` property)\nthat relates fluxes to gradients.\nFor scalar problem, this is the matrix representation of the rank 2 tensor.\nFor vector problems, the Mandel form of the rank 4 tensor is returned.\nNOTE: this is an immutable object that is _a view_ of the underlying tensor",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "c",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 331,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The tensor form of the constitutive model that relates fluxes to gradients. In scalar\nproblems, `c` and `C` are equivalent (matrices), but in vector problems, `c` is a\nrank 4 tensor. NOTE: `c` is the canonical form of the constitutive relationship.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 345,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "flux_1d",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 376,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. Returns the Voigt form that is flattened so as to\nmatch the PETSc field storage pattern for symmetric tensors.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 514,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 521,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective stiffness parameter (viscosity for viscous flow)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1232,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux. For viscoelasticity, the",
    "harvested_comments": [
      "if self.is_viscoplastic:",
      "plastic_scale_factor = sympy.Max(1, self.plastic_overshoot())",
      "stress /= plastic_scale_factor"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress_projection",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1248,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "viscoelastic stress projection (no plastic response)",
    "harvested_comments": [
      "This is a scalar viscosity ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "stress",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1272,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "viscoelastic stress projection (no plastic response)",
    "harvested_comments": [
      "This is a scalar viscosity ..."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1740,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": true
  },
  {
    "name": "viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1845,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1852,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Whatever the consistutive model defines as the effective value of viscosity\nin the form of an uw.expression",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": true
  },
  {
    "name": "flux",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2052,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Compute level-set weighted average of constituent model fluxes.\n\nCRITICAL: This composite flux becomes the stress history that\nall constituent models (including elastic ones) will read via\n``DFDt.psi_star[0]`` in the next time step.",
    "harvested_comments": [
      "Get reference flux shape from first model",
      "Compute normalization factor to ensure partition of unity",
      "Get normalized level-set function for material i",
      "Get flux contribution from constituent model i",
      "Add weighted contribution to composite flux"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": true
  },
  {
    "name": "K",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2092,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Effective stiffness using level-set weighted harmonic average.\n\nFor composite materials, harmonic averaging gives the correct effective\nstiffness for preconditioning: 1/K_eff = \u03a3(\u03c6\u1d62 * (1/K\u1d62)) / \u03a3(\u03c6\u1d62)",
    "harvested_comments": [
      "Harmonic average: 1/K_eff = \u03a3(\u03c6\u1d62 * (1/K\u1d62)) / \u03a3(\u03c6\u1d62)",
      "Compute normalization factor to ensure partition of unity",
      "Get normalized level-set function for material i",
      "Get stiffness from constituent model i",
      "Add weighted contribution to inverse stiffness"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": true
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 180,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, verbose = False, degree = 2, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Keep track",
      "# Parent class will set up default values etc",
      "default values for properties"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 381,
    "signature": "(self, mesh: uw.discretisation.Mesh, h_Field: Optional[uw.discretisation.MeshVariable] = None, v_Field: Optional[uw.discretisation.MeshVariable] = None, degree: int = 2, verbose = False, DuDt = None, DFDt = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "h_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "v_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "# Set up the projection operator that",
      "# solves the flow rate",
      "If we add smoothing, it should be small"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 628,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Not used in Stokes, but may be used in NS, VE etc",
      "User-facing operations are matrices / vectors by preference",
      "by default, incompressibility constraint",
      "this attrib records if we need to setup the problem (again)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1165,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, order: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "DuDt Not used in VE, but may be in child classes",
      "Stokes is parent (will not build DuDt or DFDt)",
      "VE time-order"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1336,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1451,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero vector"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1589,
    "signature": "(self, mesh: uw.discretisation.Mesh, tensor_Field: uw.discretisation.MeshVariable = None, scalar_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "tensor_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "scalar_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1763,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, V_fn: Union[uw.discretisation.MeshVariable, sympy.Basic], order: int = 1, restore_points_func: Callable = None, verbose = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "V_fn",
        "type_hint": "Union[uw.discretisation.MeshVariable, sympy.Basic]",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Should be a sympy function",
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2262,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, order: int = 1, theta: float = 0.0, evalf: Optional[bool] = False, verbose = False, DuDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything",
      "## by default - it's the template / skeleton"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2665,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: uw.discretisation.MeshVariable, pressureField: uw.discretisation.MeshVariable, rho: Optional[float] = 0.0, restore_points_func: Callable = None, order: Optional[int] = 2, p_continuous: Optional[bool] = False, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "rho",
        "type_hint": "Optional[float]",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values and load u_Field into the solver",
      "These are unique to the advection solver",
      "self._E = self.mesh.vector.strain_tensor(self.u.sym)",
      "## sets up DuDt and DFDt",
      "# ._setup_history_terms()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1491,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1565,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 245,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 483,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nNow uses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 683,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\n`sympy.oo` (infinity) for default values ensures that sympy.Min simplifies away\nthe conditionals when they are not required.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 884,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1412,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nNow uses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1646,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for scalar permeability.\nMatrix-valued `s` remains instance-level (special case).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_Parameters",
    "kind": "class",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1802,
    "signature": "class _Parameters",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Any material properties that are defined by a constitutive relationship are\ncollected in the parameters which can then be defined/accessed by name in\nindividual instances of the class.\n\nUses Parameter descriptor pattern for automatic lazy evaluation preservation\nwith unit-aware quantities.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1752,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2252,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2653,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 251,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 468,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "viscosity property and init the parent(s)",
      "In this case, nothing seems to be needed.",
      "The viscosity is completely defined",
      "in terms of the Parameters"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 506,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 663,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "non-paramter properties that we want to",
      "use in other expressions and init the parent(s)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 733,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 839,
    "signature": "(self, unknowns, order = 1, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# We just need to add the expressions for the stress history terms in here.\\",
      "# They are properties to hold expressions that are persistent for this instance",
      "# (i.e. we only update the value, not the object)",
      "Store material_name before creating expressions (needed by create_unique_symbol)",
      "This may not be defined at initialisation time, set to None until used"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 946,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Internal symbols for stress history (not parameters, internal state)",
      "# The following expressions are containers for derived/computed values.",
      "# They have @property calls to retrieve / calculate them.",
      "# We keep them as expression containers for lazy evaluation."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1435,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1492,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Set default diffusivity as an identity matrix wrapped in an expression",
      "Store the validated diffusivity as a diagonal matrix"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1566,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1668,
    "signature": "(inner_self, _owning_model, permeabililty: Union[float, sympy.Function] = 1)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "permeabililty",
        "type_hint": "Union[float, sympy.Function]",
        "default": "1",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Note: typo in param name preserved for compatibility",
      "Row matrix (1, dim) to match grad_u from jacobian"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1787,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "All this needs to do is define the",
      "viscosity property and init the parent(s)",
      "In this case, nothing seems to be needed.",
      "The viscosity is completely defined",
      "in terms of the Parameters"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1835,
    "signature": "(inner_self, _owning_model)",
    "parameters": [
      {
        "name": "inner_self",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "_owning_model",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_Parameters",
    "is_public": false
  },
  {
    "name": "_apply_unit_aware_scaling",
    "kind": "function",
    "file": "src/underworld3/systems/solvers.py",
    "line": 73,
    "signature": "(dt_nondimensional, field, mesh)",
    "parameters": [
      {
        "name": "dt_nondimensional",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "field",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Helper function to apply unit-aware scaling to timestep estimates.\n\nDetects the units of the velocity field and applies appropriate time scaling\nto convert nondimensional timestep to physical time units.\n\nParameters\n----------\ndt_nondimensional : float or np.ndarray\n    The nondimensional timestep estimate\nfield : MeshVariable or SymPy expression (often a Matrix)\n    The velocity field - units are detected from this\nmesh : Mesh\n    The mesh (may have reference to model with time scales)\n\nReturns\n-------\nfloat or UWQuantity\n    Timestep with physical time units if detectable, otherwise nondimensional",
    "harvested_comments": [
      "Extract a component from field if it's a Matrix (common for velocity)",
      "Extract first component: V_fn[0] or V_fn[0,0]",
      "Try to get units from the field expression",
      "Field has units - verify it has time dimension (as expected for velocity)",
      "Get dimensionality: e.g., {'[length]': 1, '[time]': -1} for velocity"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 147,
    "signature": "(self, unknowns, material_name: str = None)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_name",
        "type_hint": "str",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize a constitutive model.\n\nParameters\n----------\nunknowns : UnknownSet\n    The solver's unknowns (velocity, pressure, etc.)\nmaterial_name : str, optional\n    A distinguishing name for this material's symbols.\n    If provided, symbols will be subscripted: \u03b7 \u2192 \u03b7_{name}\n    Useful when bundling multiple models in MultiMaterialModel.",
    "harvested_comments": [
      "Define / identify the various properties in the class but leave",
      "the implementation to child classes. The constitutive tensor is",
      "defined as a template here, but should be instantiated via class",
      "properties as required.",
      "We provide a function that converts gradients / gradient history terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1963,
    "signature": "(self, unknowns, material_swarmVariable: IndexSwarmVariable, constitutive_models: list, normalize_levelsets: bool = False)",
    "parameters": [
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "material_swarmVariable",
        "type_hint": "IndexSwarmVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "constitutive_models",
        "type_hint": "list",
        "default": null,
        "description": ""
      },
      {
        "name": "normalize_levelsets",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Parameters\n----------\nunknowns : UnknownSet\n    The solver's authoritative unknowns (:math:`\\mathbf{u}`,\n    :math:`D\\mathbf{F}/Dt`, :math:`D\\mathbf{u}/Dt`).\nmaterial_swarmVariable : IndexSwarmVariable\n    Index variable tracking material distribution on particles.\nconstitutive_models : list of Constitutive_Model\n    Pre-configured constitutive models for each material.\nnormalize_levelsets : bool, optional\n    Whether to normalize level-set functions to enforce partition of unity.\n    Set to True if IndexSwarmVariable does not maintain partition of unity.\n    Default: False (assumes IndexSwarmVariable maintains partition of unity)",
    "harvested_comments": [
      "Validate compatibility before initialization",
      "Ensure model count matches material indices",
      "CRITICAL: Share solver's unknowns with all constituent models",
      "Composite model doesn't have its own material_name - constituents do"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 420,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 614,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 797,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_plastic_effective_viscosity",
    "kind": "property",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1136,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# First order ...",
      ".rewrite(sympy.Piecewise)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1335,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "super()._object_viewer()",
      "## Viscous deformation\"))",
      "### Elastic deformation\"))",
      "### Plastic deformation\"))",
      "# Todo: add all the other properties in here"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1476,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1539,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "AnisotropicDiffusionModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1614,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "GenericFluxModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1727,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1929,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2129,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_q",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 355,
    "signature": "(self, ddu)",
    "parameters": [
      {
        "name": "ddu",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generic flux term",
    "harvested_comments": [
      "tensor multiplication"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_reset",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 398,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Flags that the expressions in the consitutive tensor need to be refreshed and also that the\nsolver will need to rebuild the stiffness matrix and jacobians",
    "harvested_comments": [
      "Propagate is_setup flag to solver if we have a reference"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 412,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the identity tensor of appropriate rank (e.g. for projections)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Constitutive_Model",
    "is_public": false
  },
  {
    "name": "_q",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 530,
    "signature": "(self, edot)",
    "parameters": [
      {
        "name": "edot",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Computes the effect of the constitutive tensor on the gradients of the unknowns.\n(always uses the `c` form of the tensor). In general cases, the history of the gradients\nmay be required to evaluate the flux.",
    "harvested_comments": [
      "tensor multiplication"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 566,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [
      "Check for tensor forms first (Mandel matrix or full rank-4 tensor)",
      "Mandel form of constitutive tensor",
      "Full rank-4 tensor",
      "Scalar viscosity case",
      "UWexpression has __getitem__ from MathematicalMixin, making it Iterable,"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscousFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1192,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a viscosity function",
    "harvested_comments": [
      "inner_self = self.Parameters",
      "CRITICAL: Use .sym property to avoid UWexpression array corruption issues",
      "See ViscousFlowModel._build_c_tensor() for detailed explanation"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "ViscoElasticPlasticFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1450,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a diffusivity function",
    "harvested_comments": [
      "Scalar diffusivity case",
      "Use element-wise construction (consistent with ViscousFlowModel pattern)",
      "to handle UWexpression properly and preserve for JIT unwrapping",
      "Diagonal element: kappa",
      "Wrap if bare UWexpression to avoid Iterable check failure"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DiffusionModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1534,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Constructs the anisotropic (diagonal) tensor from the diffusivity vector.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "AnisotropicDiffusionModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1701,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect just a permeability function",
    "harvested_comments": [
      "Scalar permeability case",
      "Use element-wise construction (consistent with ViscousFlowModel and DiffusionModel)",
      "to handle UWexpression properly and preserve for JIT unwrapping",
      "Diagonal element: kappa",
      "Wrap if bare UWexpression to avoid Iterable check failure"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "DarcyFlowModel",
    "is_public": false
  },
  {
    "name": "_build_c_tensor",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 1864,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "For this constitutive law, we expect two viscosity functions\nand a sympy row-matrix that describes the director components n_{i}",
    "harvested_comments": [
      "Use .sym to get sympy expressions from Parameters",
      "Use element-wise construction (same pattern as ViscousFlowModel).",
      "UWexpression has __getitem__ from MathematicalMixin, making it appear",
      "\"Iterable\" to SymPy's array multiplication operator, which rejects it.",
      "Element-wise construction avoids this by creating Mul objects that"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "TransverseIsotropicFlowModel",
    "is_public": false
  },
  {
    "name": "_setup_shared_unknowns",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2005,
    "signature": "(self, constitutive_models, unknowns)",
    "parameters": [
      {
        "name": "constitutive_models",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "unknowns",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Ensure all constituent models share the solver's authoritative unknowns.\nThis is critical for proper stress history management.",
    "harvested_comments": [
      "Share solver's unknowns - this gives access to composite D(F)/Dt history",
      "Validation: Ensure sharing worked correctly",
      "For elastic models, verify DFDt access"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  },
  {
    "name": "_validate_model_compatibility",
    "kind": "method",
    "file": "src/underworld3/constitutive_models.py",
    "line": 2023,
    "signature": "(self, models: list) -> bool",
    "parameters": [
      {
        "name": "models",
        "type_hint": "list",
        "default": null,
        "description": ""
      }
    ],
    "returns": "bool",
    "existing_docstring": "Ensure all constituent models are compatible for flux averaging.\n\nChecks:\n- Same u_dim (scalar vs vector problem compatibility)\n- Same spatial dimension (2D/3D consistency)\n- Compatible flux tensor shapes\n- All models properly initialized",
    "harvested_comments": [
      "Validate model is properly initialized"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "MultiMaterialConstitutiveModel",
    "is_public": false
  }
]