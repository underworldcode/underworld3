[
  {
    "name": "SNES_Poisson",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 105,
    "signature": "class SNES_Poisson",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Poisson Equation Solver\n\nThis class provides functionality for a discrete representation\nof the Poisson equation\n\n$$\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{h}}}\n$$\n\nThe term $\\mathbf{F}$ relates the flux to gradients in the unknown $u$\n\n## Properties\n\n  - The unknown is $u$\n\n  - The diffusivity tensor, $\\kappa$ is provided by setting the `constitutive_model` property to\none of the scalar `uw.constitutive_models` classes and populating the parameters.\nIt is usually a constant or a function of position / time and may also be non-linear\nor anisotropic.\n\n  - $f$ is a volumetric source term",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Darcy",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 253,
    "signature": "class SNES_Darcy",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Darcy Flow Equation Solver\n\nThis class provides functionality for a discrete representation\nof the Groundwater flow equations\n\n$$\n\\color{Green}{\\underbrace{ \\Bigl[  S_s \\frac{\\partial h}{\\partial t} \\Bigr]}_{\\dot{\\mathbf{u}}}} -\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla h  - \\boldsymbol{s}\\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ W \\Bigl] }_{\\mathbf{h}}}\n$$\n\nThe flux term, $\\mathbf{F}$ relates the effective velocity to pressure gradients\n\n$$\n\\boldsymbol{v} = \\left( \\boldsymbol\\kappa \\nabla h  - \\boldsymbol{s} \\right)\n$$\n\nThe time-dependent term $\\dot{\\mathbf{f}}$ is not implemented in this version.\n\n## Properties\n\n  - The unknown is $h$, the hydraulic head\n\n  - The permeability tensor, $\\kappa$ is provided by setting the `constitutive_model` property to\none of the scalar `uw.constitutive_models` classes and populating the parameters.\nIt is usually a constant or a function of position / time and may also be non-linear\nor anisotropic.\n\n  - Volumetric sources for the pressure gradient are supplied through\n    the $s$ property [e.g. $s = \\rho g$ ]\n\n  - $W$ is a pressure source term\n\n  - $S_s$ is the specific storage coefficient\n\n## Notes\n\n  - The solver returns the primary field and also the Darcy flux term (the mean-flow velocity)",
    "harvested_comments": [],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 442,
    "signature": "class SNES_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Stokes equation solver for incompressible viscous flow.\n\nThis class provides functionality for a discrete representation\nof the Stokes flow equations assuming an incompressibility\n(or near-incompressibility) constraint.\n\nThe momentum equation is:\n\n.. math::\n\n    -\\nabla \\cdot \\left[ \\boldsymbol{\\tau} - p \\mathbf{I} \\right] = \\mathbf{f}\n\nwith the incompressibility constraint:\n\n.. math::\n\n    \\nabla \\cdot \\mathbf{u} = 0\n\nThe flux term is a deviatoric stress (:math:`\\boldsymbol{\\tau}`) related to velocity\ngradients (:math:`\\nabla \\mathbf{u}`) through a viscosity tensor :math:`\\eta`, and a\nvolumetric (pressure) part :math:`p`:\n\n.. math::\n\n    \\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\nThe constraint equation gives incompressible flow by default but can be set\nto any function of the unknown :math:`\\mathbf{u}` and :math:`\\nabla \\cdot \\mathbf{u}`.\n\nParameters\n----------\nmesh : uw.discretisation.Mesh\n    The computational mesh.\nvelocityField : uw.discretisation.MeshVariable, optional\n    Pre-existing velocity field. If None, one is created automatically.\npressureField : uw.discretisation.MeshVariable, optional\n    Pre-existing pressure field. If None, one is created automatically.\ndegree : int, optional\n    Polynomial degree for velocity interpolation. Default is 2.\np_continuous : bool, optional\n    If True (default), pressure is continuous. Set False for discontinuous pressure.\nverbose : bool, optional\n    Enable verbose output during solving. Default is False.\nDuDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for velocity (used in derived classes).\nDFDt : SemiLagrangian_DDt or Lagrangian_DDt, optional\n    Material derivative operator for flux (used in viscoelastic models).\n\nAttributes\n----------\nu : MeshVariable\n    The velocity field (accessed via ``solver.Unknowns.u``).\np : MeshVariable\n    The pressure field (accessed via ``solver.Unknowns.p``).\nbodyforce : UWexpression\n    Volumetric body force vector :math:`\\mathbf{f}`.\nconstitutive_model : ConstitutiveModel\n    Viscosity model providing the stress-strain relationship.\npenalty : UWexpression\n    Augmented Lagrangian penalty parameter :math:`\\lambda`.\nsaddle_preconditioner : sympy.Expr\n    Preconditioner for the saddle point system (default: :math:`1/\\eta`).\nconstraints : sympy.Matrix\n    Constraint equation(s), default is :math:`\\nabla \\cdot \\mathbf{u}`.\n\nNotes\n-----\n**Viscosity model**: The viscosity tensor :math:`\\boldsymbol{\\eta}` is provided by\nsetting the ``constitutive_model`` property to one of the ``uw.constitutive_models``\nclasses. It may be constant, spatially varying, non-linear, or anisotropic.\n\n**Augmented Lagrangian**: Setting ``penalty`` to a non-zero value adds\n:math:`\\lambda \\nabla \\cdot \\mathbf{u}` to the weak form, improving convergence\nfor incompressible flow (in addition to the constraint equation).\n\n**Mixed finite elements**: The pressure field interpolation order determines\nthe integration order of the mixed method and is typically lower than the\nvelocity field order.\n\n**Viscoelastic models**: For viscoelastic behaviour, the flux term contains\nstress history tracked on a particle swarm. See :class:`SNES_VE_Stokes`.\n\nSee Also\n--------\nSNES_VE_Stokes : Viscoelastic Stokes solver with flux history.\nSNES_NavierStokes : Navier-Stokes solver with inertial terms.\nuw.constitutive_models : Available viscosity models.\n\nExamples\n--------\n>>> import underworld3 as uw\n>>> mesh = uw.meshing.UnstructuredSimplexBox(minCoords=(0,0), maxCoords=(1,1), cellSize=0.1)\n>>> stokes = uw.systems.Stokes(mesh, degree=2)\n>>> stokes.constitutive_model = uw.constitutive_models.ViscousFlowModel()\n>>> stokes.constitutive_model.Parameters.viscosity = 1.0\n>>> stokes.bodyforce = [0, -1]  # gravity\n>>> stokes.solve()",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_VE_Stokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 812,
    "signature": "class SNES_VE_Stokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# ViscoElastic Stokes Equation Solver\n\nThis class provides functionality for a discrete representation\nof the Stokes flow equations assuming an incompressibility\n(or near-incompressibility) constraint and with a flux history\nterm included to allow for viscoelastic modelling.\n\nAll other functionality is inherited from SNES_Stokes\n\n$$\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[\n                \\boldsymbol{\\tau} -  p \\mathbf{I} \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{f} \\Bigl] }_{\\mathbf{h}}}\n$$\n\n$$\n\\underbrace{\\Bigl[ \\nabla \\cdot \\mathbf{u} \\Bigr]}_{\\mathbf{h}_p} = 0\n$$\n\nThe flux term is a deviatoric stress ( $\\boldsymbol{\\tau}$ ) related to velocity gradients\n  ( $\\nabla \\mathbf{u}$ ) through a viscosity tensor, $\\eta$, and a volumetric (pressure) part $p$\n\n$$\n    \\mathbf{F}: \\quad \\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n$$\n\nThe constraint equation, $\\mathbf{h}_p = 0$ is incompressible flow by default but can be set\nto any function of the unknown  $\\mathbf{u}$ and  $\\nabla\\cdot\\mathbf{u}$\n\n## Properties\n\n  - The unknowns are velocities $\\mathbf{u}$ and a pressure-like constraint paramter $\\mathbf{p}$\n\n  - The viscosity tensor, $\\boldsymbol{\\eta}$ is provided by setting the `constitutive_model` property to\none of the scalar `uw.constitutive_models` classes and populating the parameters.\nIt is usually a constant or a function of position / time and may also be non-linear\nor anisotropic.\n\n  - $\\mathbf f$ is a volumetric source term (i.e. body forces)\n  and is set by providing the `bodyforce` property.\n\n  - An Augmented Lagrangian approach to application of the incompressibility\nconstraint is to penalise incompressibility in the Stokes equation by adding\n$ \\lambda \\nabla \\cdot \\mathbf{u} $ when the weak form of the equations is constructed.\n(this is in addition to the constraint equation, unlike in the classical penalty method).\nThis is activated by setting the `penalty` property to a non-zero floating point value which adds\nthe term in the `sympy` expression.\n\n  - A preconditioner is usually required for the saddle point system and this is provided\nthrough the `saddle_preconditioner` property. The default choice is $1/\\eta$ for a scalar viscosity function.\n\n## Notes\n\n  - For problems with viscoelastic behaviour, the flux term contains the stress history as well as the\n    stress and this term is a Lagrangian quantity that has to be tracked on a particle swarm.\n\n  - The interpolation order of the `pressureField` variable is used to determine the integration order of\nthe mixed finite element method and is usually lower than the order of the `velocityField` variable.\n\n  - It is possible to set discontinuous pressure variables by setting the `p_continous` option to `False`",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1000,
    "signature": "class SNES_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Projection Solver\n\nSolves $u = \\tilde{f}$ where $\\tilde{f}$ is a function that can be evaluated within an element and\n$u$ is a `meshVariable` with associated shape functions. Typically, the projection is used to obtain a\ncontinuous representation of a function that is not well defined at the mesh nodes. For example, functions of\nthe spatial derivatives of one or more `meshVariable` (e.g. components of fluxes) can be mapped to continuous\nvariables with a projection. More broadly it is a projection from one basis to another and its limitations should be\nevaluated within that context.\n\nThe projection implemented by creating a solver for this problem\n\n$$\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla u \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ u - \\tilde{f} \\Bigl] }_{\\mathbf{h}}} = 0\n$$\n\nWhere the term $\\mathbf{F}$ provides a smoothing regularization. $\\alpha$ can be zero.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Vector_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1091,
    "signature": "class SNES_Vector_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Projection Solver (Vector Variable)\n\nSolves $\\mathbf{u} = \\tilde{\\mathbf{f}}$ where $\\tilde{\\mathbf{f}}$ is a vector function that can be evaluated within an element and\n$\\mathbf{u}$ is a vector `meshVariable` with associated shape functions. Typically, the projection is used to obtain a\ncontinuous representation of a function that is not well defined at the mesh nodes. For example, functions of\nthe spatial derivatives of one or more `meshVariable` (e.g. components of fluxes) can be mapped to continuous\nvariables with a projection. More broadly it is a projection from one basis to another and its limitations should be\nevaluated within that context.\n\nThe projection is implemented by creating a solver for this problem\n\n$$\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla \\mathbf{u} \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{u} - \\tilde{\\mathbf{f}} \\Bigl] }_{\\mathbf{h}}} = 0\n$$\n\nWhere the term $\\mathbf{F}$ provides a smoothing regularization. $\\alpha$ can be zero.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Tensor_Projection",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1205,
    "signature": "class SNES_Tensor_Projection",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Projection Solver (Tensor Variable)\n\nSolves $\\mathbf{u} = \\tilde{\\mathbf{f}}$ where $\\tilde{\\mathbf{f}}$ is a tensor-valued function that can be evaluated within an element and\n$\\mathbf{u}$ is a tensor `meshVariable` with associated shape functions. Typically, the projection is used to obtain a\ncontinuous representation of a function that is not well defined at the mesh nodes. For example, functions of\nthe spatial derivatives of one or more `meshVariable` (e.g. components of fluxes) can be mapped to continuous\nvariables with a projection. More broadly it is a projection from one basis to another and its limitations should be\nevaluated within that context.\n\nThe projection implemented by creating a solver for this problem\n\n$$\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla \\mathbf{u} \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{u} - \\tilde{\\mathbf{f}} \\Bigl] }_{\\mathbf{h}}} = 0\n$$\n\nWhere the term $\\mathbf{F}$ provides a smoothing regularization. $\\alpha$ can be zero.\n\nNote: this is currently implemented component-wise as we do not have a native solver for tensor unknowns.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_AdvectionDiffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1329,
    "signature": "class SNES_AdvectionDiffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Advection-Diffusion Equation Solver (Scalar Variable)\n\nThis class provides a solver for the scalar Advection-Diffusion equation using the characteristics based Semi-Lagrange Crank-Nicholson method\nwhich is described in Spiegelman & Katz, (2006).\n\n$$\n\\color{Green}{\\underbrace{ \\Bigl[ \\frac{\\partial u}{\\partial t} + \\left( \\mathbf{v} \\cdot \\nabla \\right) u \\Bigr]}_{\\dot{\\mathbf{u}}}} -\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{h}}}\n$$\n\nThe term $\\mathbf{F}$ relates diffusive fluxes to gradients in the unknown $u$. The advective flux that results from having gradients along\nthe direction of transport (given by the velocity vector field $\\mathbf{v}$ ) are included in the $\\dot{\\mathbf{u}}$ term.\n\nThe term $\\dot{\\mathbf{u}}$ involves upstream sampling to find the value $u^*$ which represents the value of $u$ at\nthe points which later arrive at the nodal points of the mesh. This is achieved using a \"hidden\"\nswarm variable which is advected backwards from the nodal points automatically during the `solve` phase.\n\n## Properties\n\n  - The unknown is $u$.\n\n  - The velocity field is $\\mathbf{v}$ and is provided as a `sympy` function to allow operations such as time-averaging to be\n    calculated in situ (e.g. `V_Field = v_solution.sym`) **NOTE: no it's not.\n\n  - The diffusivity tensor, $\\kappa$ is provided by setting the `constitutive_model` property to\n    one of the scalar `uw.constitutive_models` classes and populating the parameters.\n    It is usually a constant or a function of position / time and may also be non-linear\n    or anisotropic.\n\n  - Volumetric sources of $u$ are specified using the $f$ property and can be any valid combination of `sympy` functions of position and\n    `meshVariable` or `swarmVariable` types.\n\n## References\n\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution of advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_Diffusion",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1773,
    "signature": "class SNES_Diffusion",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Diffusion Equation Solver (Scalar Variable)\n\nThis class provides a solver for the scalar Diffusion equation using mesh-based finite elements.\n\n$$\n\\color{Green}{\\underbrace{ \\Bigl[ \\frac{\\partial u}{\\partial t} - \\left( \\mathbf{v} \\cdot \\nabla \\right) u \\Bigr]}_{\\dot{\\mathbf{f}}}} -\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{f}}}\n$$\n\nThe term $\\mathbf{F}$ relates diffusive fluxes to gradients in the unknown $u$.\n\n## Properties\n\n  - The unknown is $u$.\n\n  - The diffusivity tensor, $\\kappa$ is provided by setting the `constitutive_model` property to\n    one of the scalar `uw.constitutive_models` classes and populating the parameters.\n    It is usually a constant or a function of position / time and may also be non-linear\n    or anisotropic.\n\n  - Volumetric sources of $u$ are specified using the $f$ property and can be any valid combination of `sympy` functions of position and\n    `meshVariable` or `swarmVariable` types.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "SNES_NavierStokes",
    "kind": "class",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2123,
    "signature": "class SNES_NavierStokes",
    "parameters": [],
    "returns": null,
    "existing_docstring": "# Navier-Stokes Equation Solver\n\nThis class provides a solver for the Navier-Stokes (vector Advection-Diffusion) equation which is similar to that\nused in the Semi-Lagrange Crank-Nicholson method (Spiegelman & Katz, 2006) but using a\ndistributed sampling of upstream values taken from an arbitrary swarm variable.\n\n$$\n\\color{Green}{\\underbrace{ \\Bigl[ \\frac{\\partial \\mathbf{u} }{\\partial t} +\n                                  \\left( \\mathbf{u} \\cdot \\nabla \\right) \\mathbf{u} \\ \\Bigr]}_{\\dot{\\mathbf{u}}}} -\n    \\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\frac{\\boldsymbol{\\eta}}{2} \\left(\n                \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right) - p \\mathbf{I} \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{f} \\Bigl] }_{\\mathbf{h}}}\n$$\n\nThe term $\\mathbf{F}$ relates diffusive fluxes to gradients in the unknown $u$. The advective flux that results from having gradients along\nthe direction of transport (given by the velocity vector field $\\mathbf{v}$ ) are included in the $\\dot{\\mathbf{u}}$ term.\n\nThe term $\\dot{\\mathbf{u}}$ involves upstream sampling to find the value $u^{ * }$ which represents the value of $u$ at\nthe beginning of the timestep. This is achieved using a `swarmVariable` that carries history information along the flow path.\nA dense sampling is required to achieve similar accuracy to the original SLCN approach but it allows the use of a single swarm\nfor history tracking of variables with different interpolation order and for material tracking. The user is required to supply\n**and update** the swarmVariable representing $u^{ * }$\n\n## Properties\n\n  - The unknown is $u$.\n\n  - The history variable is $u^*$ and is provided in the form of a `sympy` function. It is the user's responsibility to keep this\n    variable updated.\n\n  - The diffusivity tensor, $\\kappa$ is provided by setting the `constitutive_model` property to\n    one of the scalar `uw.constitutive_models` classes and populating the parameters.\n    It is usually a constant or a function of position / time and may also be non-linear\n    or anisotropic.\n\n  - Volumetric sources of $u$ are specified using the $f$ property and can be any valid combination of `sympy` functions of position and\n    `meshVariable` or `swarmVariable` types.\n\n## Notes\n\n  - The solver requires relatively high order shape functions to accurately interpolate the history terms.\n    Spiegelman & Katz recommend cubic or higher degree for $u$ but this is not checked.\n\n## References\n\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution\nof advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "KDTree",
    "kind": "class",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 17,
    "signature": "cdef class KDTree:",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "Mesh",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 149,
    "signature": "class Mesh",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh class for uw - documentation needed",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "poisson_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 173,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f1 residual term (weighted integration) - scalar function",
      "f1 residual term (integration by parts / gradients)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 184,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 188,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle UWQuantity with units - enforce \"units everywhere\" principle",
      "Extract the plain value",
      "If ND scaling is active, scale the constant",
      "The source term should have same dimensionality as the unknown field",
      "Access via self.Unknowns.u (Poisson) or self.Unknowns.DuDt.u (Stokes)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 249,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": true
  },
  {
    "name": "darcy_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 353,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f1 residual term (weighted integration)",
      "f1 residual term (integration by parts / gradients)",
      "Flow calculation"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 366,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 370,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "darcy_flux",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 375,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 380,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "v",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 384,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 617,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p0 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "CM_is_setup",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 631,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 635,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 639,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "strainrate_star_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 643,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 648,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "strainrate, strain-rate history"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_deviator_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 652,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 656,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "stress_1d",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 660,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 664,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "E = self.strainrate",
      "divergence = E.trace()",
      "return divergence"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 672,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 676,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 682,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 686,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Convert UWQuantity objects to SymPy expressions before Matrix creation",
      "If UWQuantity contains a Matrix, extract the scalar element"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 706,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 710,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 716,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 720,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 926,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1063,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1067,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1072,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1076,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": true
  },
  {
    "name": "projection_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1154,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "residual terms - defines the problem:",
      "solve for a best fit to the continuous mesh",
      "variable given the values in self.function",
      "F0 is left in place for the user to inject",
      "non-linear constraints if required"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1177,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "smoothing",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1181,
    "signature": "(self, smoothing_factor)",
    "parameters": [
      {
        "name": "smoothing_factor",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1186,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1190,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1196,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "uw_weighting_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1200,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1253,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Loop over the components of the tensor. If this is a symmetric",
      "tensor, we'll usually be given the 1d form to prevent duplication",
      "if self.t_field.sym_1d.shape != self.uw_function.shape:",
      "raise ValueError(",
      "\"Tensor shapes for uw_function and MeshVariable are not the same\""
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1284,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1298,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1312,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "uw_scalar_function",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1316,
    "signature": "(self, user_uw_function)",
    "parameters": [
      {
        "name": "user_uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1473,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1487,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "adv_diff_slcn_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1500,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1510,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1514,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1519,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1539,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1543,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1907,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1921,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "backward compatibility"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1935,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1939,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1944,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1948,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Handle Pint Quantities with time dimensions",
      "This is a Pint Quantity - check if it has time dimensions",
      "Convert physical time to nondimensional using model time scale",
      "Physical time / time scale = nondimensional time",
      "Must use to_reduced_units() to convert both quantities"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "F0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2276,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "I think this should be bdf(1) ... the higher order",
      "terms are introduced through the adams_moulton fluxes"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "F1",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2294,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "We can flag to only do this if the constitutive model has been updated",
      "Is the else condition useful - other than to prevent a crash ?",
      "Yes, because then it can just live on the Stokes solver ..."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "PF0",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2324,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "navier_stokes_problem_description",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2339,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "f0 residual term",
      "f1 residual term",
      "p1 residual term"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2352,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "delta_t",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2356,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2361,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "rho",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2365,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2370,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "f",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2374,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "div_u",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2379,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "strainrate",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2385,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2389,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DuDt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2393,
    "signature": "(self, DuDt_value: Union[SemiLagrangian_DDt, Lagrangian_DDt])",
    "parameters": [
      {
        "name": "DuDt_value",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "DFDt",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2401,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2405,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "constraints",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2409,
    "signature": "(self, constraints_matrix)",
    "parameters": [
      {
        "name": "constraints_matrix",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2415,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "bodyforce",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2419,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2424,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "saddle_preconditioner",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2428,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "property",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2434,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "penalty",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2438,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 389,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, verbose: bool = False, _force_setup: bool = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.\ntimestep:\n    value used to evaluate inertial contribution",
    "harvested_comments": [
      "Solve pressure",
      "Now solve flow field",
      "self._v_projector.petsc_options[\"snes_rtol\"] = 1.0e-6",
      "self._v_projector.petsc_options.delValue(\"ksp_monitor\")"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 734,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate advective timestep for the Stokes solver.\n\nThe Stokes equations are quasi-static (no time derivative \u2202v/\u2202t),\nso there is no diffusive CFL constraint. The only relevant timescale\nis the advective one: how long it takes material to cross an element.\n\nThis method computes a per-element timestep:\n    dt_i = h_i / |v_i|\n\nwhere h_i is the element radius and v_i is the velocity at the element\ncentroid, then returns the global minimum. This is more accurate than\nusing global max velocity with global min element size, especially for\nnon-uniform meshes with spatially varying velocity.\n\nReturns:\n    Pint Quantity or float: The advective timestep with physical time units\n    if a model with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "Evaluate velocity at element centroids (consistent with AdvDiff)",
      "If vel is unit-aware (UnitAwareArray), nondimensionalise it to get",
      "consistent nondimensional values that match mesh._radii",
      "Note: .magnitude returns physical units, which would be wrong here",
      "Plain UWQuantity without units context - use magnitude"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 933,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": true
  },
  {
    "name": "V_fn",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1523,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the velocity function for advection.\n\nParameters:\n-----------\nvalue : uw.discretisation.MeshVariable or sympy.Basic\n    Velocity field as either a MeshVariable or sympy expression",
    "harvested_comments": [
      "Mark as needing setup when velocity changes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1587,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate timestep for the advection-diffusion solver.\n\nThis is an implicit solver so the $\\delta_t$ returned is the minimum of:\n\n    - ${\\delta t}_\\textrm{diff}$: typical time for the diffusion front to propagate across an element\n    - ${\\delta t}_\\textrm{adv}$: typical element-crossing time for a fluid parcel\n\nReturns:\n    Pint Quantity or float: The recommended timestep with physical time units\n    if a model with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1716,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, _evalf = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing.",
      "Invalidate cached data views - PETSc may have replaced underlying buffers",
      "This ensures .data and .array properties return fresh data from PETSc"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1992,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate timestep for the diffusion solver.\n\nThis solver only has a diffusive component, so the $\\delta_t$ returned is:\n\n    - ${\\delta t}_\\textrm{diff}$: typical time for the diffusion front to propagate across an element\n\nReturns:\n    Pint Quantity or float: The diffusive timestep with physical time units\n    if a model with reference scales is available, otherwise nondimensional.",
    "harvested_comments": [
      "## required modules",
      "Use the unified .K property from the constitutive model",
      "This provides diffusivity for diffusion models",
      "Evaluate the diffusivity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2064,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, evalf: bool = False, _force_setup: bool = False, verbose = False)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "self._flux =  self.constitutive_model.flux.T",
      "self._flux_star =  self._flux.copy()",
      "Update History / Flux History terms",
      "SemiLagrange and Lagrange may have different sequencing."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": true
  },
  {
    "name": "solve",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2443,
    "signature": "(self, zero_init_guess: bool = True, timestep: float = None, _force_setup: bool = False, verbose = False, _evalf = False, order = None)",
    "parameters": [
      {
        "name": "zero_init_guess",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "timestep",
        "type_hint": "float",
        "default": "None",
        "description": ""
      },
      {
        "name": "_force_setup",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "_evalf",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Generates solution to constructed system.\n\nParams\n------\nzero_init_guess:\n    If `True`, a zero initial guess will be used for the\n    system solution. Otherwise, the current values of `self.u` will be used.",
    "harvested_comments": [
      "this will force an initialisation because the functions need to be updated",
      "Update SemiLagrange Flux terms"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "estimate_dt",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2509,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Calculates an appropriate timestep for the given\nmesh and viscosity configuration. This is an implicit solver\nso the $\\delta_t$ should be interpreted as:\n\n    - ${\\delta t}_\\textrm{diff}: a typical time for the diffusion of vorticity across an element\n    - ${\\delta t}_\\textrm{adv}: a typical element-crossing time for a fluid parcel\n\nThe Navier-Stokes equations include momentum diffusion via kinematic viscosity\n(\u03bd = \u03b7/\u03c1), so the diffusive timestep is computed from this quantity.\n\nreturns: (${\\delta t}_\\textrm{diff}$, ${\\delta t}_\\textrm{adv}$)",
    "harvested_comments": [
      "## required modules",
      "For Navier-Stokes, diffusivity is the kinematic viscosity: \u03bd = \u03b7/\u03c1",
      "Use the unified .K property from the constitutive model (returns viscosity)",
      "Evaluate the viscosity (handles constant and spatially-varying cases)",
      "If diffusivity is unit-aware (UnitAwareArray), nondimensionalise it to get"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": true
  },
  {
    "name": "n",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 86,
    "signature": "def n(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "ndim",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 90,
    "signature": "def ndim(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "kdtree_points",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 160,
    "signature": "def kdtree_points(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "find_closest_point",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 170,
    "signature": "def find_closest_point(self,\n                          const double[:,::1] coords not None:   numpy.ndarray):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "find_closest_n_points",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 215,
    "signature": "def find_closest_n_points(self,\n                  const int nCount                    :   numpy.int64,\n                  const double[: ,::1] coords not None:   numpy.ndarray):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "query",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 273,
    "signature": "def query(self,\n             coords,\n             k=1,\n             sqr_dists=True,\n    ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 336,
    "signature": "def rbf_interpolator_local(self,\n            coords,\n            data,\n            nnn = 4,\n            p=2,\n            verbose = False,\n        ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "old_rbf_interpolator_local_from_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 348,
    "signature": "def old_rbf_interpolator_local_from_kdtree(self,\n            coords,\n            data,\n            nnn = 4,\n            verbose = False,\n        ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "old_rbf_interpolator_local_to_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 409,
    "signature": "def old_rbf_interpolator_local_to_kdtree(self,\n                    coords,\n                    data,\n                    nnn = 4,\n                    verbose = False,\n                    weights = None\n                ):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "rbf_interpolator_local_from_kdtree",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 476,
    "signature": "def rbf_interpolator_local_from_kdtree(self, coords, data, nnn, p, verbose):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 34,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "nuke_coords_and_rebuild",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 994,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)",
      "let's go ahead and do an initial projection from linear (the default)",
      "to linear. this really is a nothing operation, but a",
      "side effect of this operation is that coordinate DM DMField is",
      "converted to the required `PetscFE` type. this may become necessary"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "CoordinateSystem",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1368,
    "signature": "(self) -> CoordinateSystem",
    "parameters": [],
    "returns": "CoordinateSystem",
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "checkpoint_xdmf",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2778,
    "signature": "(filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Identify the mesh file. Use the",
      "# zeroth one if this option is turned off",
      "# Obtain the mesh information",
      "We only use a subset of the possible cell types",
      "# Create the header"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "extend_enum",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 35,
    "signature": "(inherited)",
    "parameters": [
      {
        "name": "inherited",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "clone",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 585,
    "signature": "(self, name, varsymbol)",
    "parameters": [
      {
        "name": "name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "rbf_interpolate",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 863,
    "signature": "(self, new_coords, meth = 0, p = 2, verbose = False, nnn = None, rubbish = None)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "meth",
        "type_hint": null,
        "default": "0",
        "description": ""
      },
      {
        "name": "p",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "nnn",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "rubbish",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "An inverse-distance mapping is quite robust here ... as long",
      "as long we take care of the case where some nodes coincide (likely if used mesh2mesh)",
      "Use non-dimensional coordinates for internal RBF interpolation KDTree"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "load_from_h5_plex_vector",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1160,
    "signature": "(self, filename: str, data_name: Optional[str] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Ensure vectors are initialized"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "divergence",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2692,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "gradient",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2698,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "curl",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2704,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "jacobian",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2710,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# validate if this is a vector ?"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "build_index",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 155,
    "signature": "def build_index(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": "\n        Build the kd-tree index.\n",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "dim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 683,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "The mesh dimensionality.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "cdim",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 690,
    "signature": "(self) -> int",
    "parameters": [],
    "returns": "int",
    "existing_docstring": "The mesh dimensionality.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "element",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 697,
    "signature": "(self) -> dict",
    "parameters": [],
    "returns": "dict",
    "existing_docstring": "The element information of the mesh (no mixed meshes in uw3) so this\napplies to every cell of the `mesh dmplex object`",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_scale",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 706,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "Length scale for non-dimensionalization.\n\nThis property is IMMUTABLE after mesh creation to ensure synchronization\nwith all spatial operators (gradient, divergence, curl, etc.).\n\nThe length scale is derived from model reference quantities at mesh creation:\n- Priority 1: `domain_depth` from `model.set_reference_quantities()`\n- Priority 2: `length` from `model.set_reference_quantities()`\n- Default: 1.0 (no scaling)\n\nReturns\n-------\nfloat\n    Length scale value for non-dimensionalization\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_depth=uw.quantity(100, \"km\"))\n>>> mesh = uw.meshing.UnstructuredSimplexBox(...)\n>>> mesh.length_scale\n100000.0  # meters\n\nSee Also\n--------\nlength_units : Units string for length scale",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "length_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 737,
    "signature": "(self) -> str",
    "parameters": [],
    "returns": "str",
    "existing_docstring": "Unit string for the length scale.\n\nReturns\n-------\nstr\n    Units for the length scale (e.g., \"meter\", \"kilometer\")\n\nExamples\n--------\n>>> mesh.length_units\n'kilometer'",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 753,
    "signature": "(self, level = 0)",
    "parameters": [
      {
        "name": "level",
        "type_hint": null,
        "default": "0",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Displays mesh information at different levels.\n\nParameters\n----------\nlevel : int (0 default)\n    The display level.\n    0, for basic mesh information (variables and boundaries), while level=1 displays detailed mesh information (including PETSc information)",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "Display coordinate units if set",
      "Display length scale for non-dimensionalization",
      "Only if notebook and serial",
      "Total number of cells"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "view_parallel",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 927,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "returns the break down of boundary labels from each processor",
    "harvested_comments": [
      "{self.instance}: {self.name}\\n\")",
      "# Boundary information on each proc",
      "## goes through each processor and gets the label size"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "clone_dm_hierarchy",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 978,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Clone the dm hierarchy on the mesh",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "update_lvec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1096,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This method creates and/or updates the mesh variable local vector.\nIf the local vector is already up to date, this method will do nothing.",
    "harvested_comments": [
      "create the local vector (memory chunk) and attach to original dm",
      "push avar arrays into the parent dm array",
      "The field decomposition seems to fail if coarse DMs are present",
      "traverse subdms, taking user generated data in the subdm",
      "local vec, pushing it into a global sub vec"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "lvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1135,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "Returns a local Petsc vector containing the flattened array\nof all the mesh variables.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1278,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Dummy access manager that provides deferred sync for backward compatibility.\nUses NDArray_With_Callback.delay_callbacks_global() internally.\n\nThis is a compatibility wrapper that allows existing code using the access()\ncontext manager to work with the new direct-access variable interfaces.\nAll variable modifications are deferred and synchronized at context exit.\n\nParameters\n----------\nwriteable_vars\n    Variables that will be modified (ignored - all variables are writable\n    with the new interface, this parameter is kept for API compatibility)\n\nReturns\n-------\nContext manager that defers variable synchronization until exit\n\nNotes\n-----\nThis method is deprecated. New code should access variable.data or\nvariable.array directly without requiring an access context.",
    "harvested_comments": [
      "Use NDArray_With_Callback global delay context for deferred sync",
      "This triggers all accumulated callbacks from all variables"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1328,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "The mesh coordinate system.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma_N",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1335,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "The mesh coordinate system.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "Gamma",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1342,
    "signature": "(self) -> sympy.vector.CoordSys3D",
    "parameters": [],
    "returns": "sympy.vector.CoordSys3D",
    "existing_docstring": "The mesh coordinate system.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "X",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1349,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Coordinate system object with symbolic coordinates and data access.\n\nReturns the CoordinateSystem object which provides:\n- mesh.X[0] - Symbolic x-coordinate function\n- mesh.X.coords - Coordinate data array (same as mesh.points)\n- mesh.X.units - Coordinate units (same as mesh.units)\n- x, y = mesh.X - Unpacking symbolic coordinates\n\nFor backward compatibility, the CoordinateSystem behaves like\na symbolic matrix for indexing and iteration.\n\nReturns:\n    CoordinateSystem: Coordinate system with symbolic and data access",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "r",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1372,
    "signature": "(self) -> Tuple[sympy.vector.BaseScalar]",
    "parameters": [],
    "returns": "Tuple[sympy.vector.BaseScalar]",
    "existing_docstring": "The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "rvec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1379,
    "signature": "(self) -> sympy.vector.Vector",
    "parameters": [],
    "returns": "sympy.vector.Vector",
    "existing_docstring": "The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1395,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of mesh element vertex coordinates.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.data`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nThis is an alias for mesh.points (which is also deprecated).",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1414,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh node coordinates in physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n    ``mesh.points`` is deprecated in favor of ``mesh.X.coords``\n    (coordinate-system-aware interface).\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from internal model coordinates\nto physical coordinates for user access.\n\nWhen the mesh has coordinate units specified, returns a unit-aware array.\n\nReturns:\n    numpy.ndarray or UnitAwareArray: Node coordinates (with units if specified)",
    "harvested_comments": [
      "Apply scaling to convert model coordinates to physical coordinates",
      "Wrap with unit-aware array if units are specified"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1456,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set mesh node coordinates from physical units.\n\n.. deprecated:: 0.99.0\n    Use :attr:`X.coords` instead.\n\nWhen the mesh has coordinate scaling applied (via model units),\nthis property automatically converts from physical coordinates\nto internal model coordinates for PETSc storage.\n\nArgs:\n    value (numpy.ndarray or UnitAwareArray): Node coordinates in physical units",
    "harvested_comments": [
      "PRINCIPLE (2025-11-27): When units are active, require unit-aware input",
      "to avoid ambiguity about whether values are dimensional or non-dimensional.",
      "Plain array assigned when units are active - ambiguous",
      "Handle unit-aware input",
      "Extract numerical value from unit-aware object"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_coordinates",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1526,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh coordinates in physical units.\n\nReturns the mesh coordinate array scaled to physical units using\nthe model's length scale. Requires the mesh to be associated with\na model that has reference quantities set.\n\nReturns\n-------\nUWQuantity or None\n    Coordinates in physical units, or None if no model scaling available\n\nExamples\n--------\n>>> model.set_reference_quantities(domain_length=1000*uw.units.km, ...)\n>>> mesh = uw.meshing.StructuredQuadBox(...)\n>>> physical_coords = mesh.physical_coordinates  # In kilometers",
    "harvested_comments": [
      "In kilometers"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_bounds",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1551,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh bounds in physical units.\n\nReturns the mesh bounding box scaled to physical units using\nthe model's length scale.\n\nReturns\n-------\ntuple of UWQuantity or None\n    (min_coords, max_coords) in physical units, or None if no model scaling\n\nExamples\n--------\n>>> physical_min, physical_max = mesh.physical_bounds\n>>> print(f\"Domain: {physical_min} to {physical_max}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "physical_extent",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1582,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Mesh spatial extent in physical units.\n\nReturns the mesh size (max - min) in each dimension scaled to physical units.\n\nReturns\n-------\nUWQuantity or None\n    Extent in physical units, or None if no model scaling\n\nExamples\n--------\n>>> extent = mesh.physical_extent\n>>> print(f\"Domain size: {extent}\")",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1610,
    "signature": "(self, filename: str, index: int, outputPath: Optional[str] = '', meshVars: Optional[list] = [], swarmVars: Optional[list] = [], meshUpdates: bool = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write the selected mesh, variables and swarm variables (as proxies) for later visualisation.\nAn xdmf file is generated and the overall package can then be read by paraview or pyvista.\nVertex values (on the mesh points) are stored for all variables regardless of their interpolation order",
    "harvested_comments": [
      "check the directory where we will write checkpoint",
      "get directory",
      "check if path exists",
      "easier to debug abs",
      "check if we have write access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "petsc_save_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1681,
    "signature": "(self, index: int, meshVars: Optional[list] = [], outputPath: Optional[str] = '')",
    "parameters": [
      {
        "name": "index",
        "type_hint": "int",
        "default": null,
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": "Optional[str]",
        "default": "''",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Use PETSc to save the mesh and mesh vars in a h5 and xdmf file.\n\nParameters\n----------\nmeshVars:\n    List of UW mesh variables to save. If left empty then just the mesh is saved.\nindex :\n    An index which might correspond to the timestep or output number (for example).\noutputPath :\n    Path to save the data. If left empty it will save the data in the current working directory.",
    "harvested_comments": [
      "## save mesh vars",
      "### create petsc viewer",
      "## Empty meshVars will save just the mesh"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write_checkpoint",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1727,
    "signature": "(self, filename: str, meshUpdates: bool = True, meshVars: Optional[list] = [], swarmVars: Optional[list] = [], index: Optional[int] = 0, unique_id: Optional[bool] = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "meshUpdates",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "meshVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "swarmVars",
        "type_hint": "Optional[list]",
        "default": "[]",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "0",
        "description": ""
      },
      {
        "name": "unique_id",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write data in a format that can be restored for restarting the simulation\nThe difference between this and the visualisation is 1) the parallel section needs\nto be stored to reload the data correctly, and 2) the visualisation information (vertex form of fields)\nis not stored. This routines uses dmplex *VectorView and *VectorLoad functionality",
    "harvested_comments": [
      "The mesh checkpoint is the same as the one required for visualisation",
      "Checkpoint file",
      "Store the parallel-mesh section information for restoring the checkpoint.",
      "v._gvec.view(viewer) # would add viz information plus a duplicate of the data",
      "should not be required"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1789,
    "signature": "(self, filename: str, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh data to the specified hdf5 file.\n\n\nParameters\n----------\nfilename :\n    The filename for the mesh checkpoint file.\nindex :\n    Not yet implemented. An optional index which might\n    correspond to the timestep (for example).",
    "harvested_comments": [
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "viewer.pushTimestepping(viewer)",
      "viewer.setTimestep(index)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vtk",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1854,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Save mesh to the specified file",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "generate_xdmf",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1863,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method generates an xdmf schema for the specified file.\n\nThe filename of the generated file will be the same as the hdf5 file\nbut with the `xmf` extension.\n\nParameters\n----------\nfilename :\n    File name of the checkpointed hdf5 file for which the\n    xdmf schema will be written.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1885,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "block_vars",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1894,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "A list of variables recorded on the mesh.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "points_in_domain",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2340,
    "signature": "(self, points, strict_validation = True)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "strict_validation",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in this domain.\nUses a mesh-boundary skeletonization array to determine whether the point is\ninside the boundary or outside. If close to the boundary, it checks if points\nare in a cell.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\nstrict_validation : bool\n    Whether to perform strict validation near boundaries",
    "harvested_comments": [
      "Convert points to model coordinates using the unified conversion function",
      "This handles all coordinate formats: plain numbers, unit-aware coordinates, lists, tuples, arrays",
      "_convert_coords_to_si now converts to model coordinates (despite the name)",
      "and handles all the complexity of extracting values from unit-aware coordinates",
      "# This choice of distance needs some more thought"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2394,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Note, the nearest point may not be all\nthat close by - use get_closest_local_cells to filter out points\nthat are (probably) not within any local cell.\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n    Plain numbers are assumed to be in model coordinates.\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model coordinates",
      "Simply extract raw values - np.asarray handles unit-aware objects correctly",
      "## returns an empty 1D array if no coords are provided",
      "CRITICAL: Must return 1D array, not 2D, for Cython buffer compatibility"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "test_if_points_in_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2511,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test\n\nReturns\n-------\nnumpy.ndarray\n    Boolean array indicating if points are in cells",
    "harvested_comments": [
      "Convert points to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_closest_local_cells",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2546,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Convert coords to model units using the elegant protocol",
      "Extract numerical values for internal mesh operations",
      "Call internal implementation"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius_old",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2644,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_min_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2661,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global minimum distance from any cell centroid to a face.\nIt wraps to the PETSc `DMPlexGetMinRadius` routine. The petsc4py equivalent always\nreturns zero.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "get_max_radius",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2677,
    "signature": "(self) -> float",
    "parameters": [],
    "returns": "float",
    "existing_docstring": "This method returns the global maximum distance from any cell centroid to a face.",
    "harvested_comments": [
      "# Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and",
      "# does not obtain the minimum radius for the mesh."
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2692,
    "signature": "(self, uw_function, uw_meshVariable, basis = None)",
    "parameters": [
      {
        "name": "uw_function",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "uw_meshVariable",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "basis",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Returns various norms on the mesh for the provided function.\n  - size\n  - mean\n  - min\n  - max\n  - sum\n  - L2 norm\n  - rms\n\n  NOTE: this currently assumes scalar variables !",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_mask_from_label",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2728,
    "signature": "(self, label_name, label_value)",
    "parameters": [
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Extract single label value and make a point mask - note: this produces a mask on the mesh points and\nassumes a 1st order mesh. Cell labels are not respected in this function.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "register_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2754,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Register swarm as dependent on this mesh for coordinate change notifications",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "unregister_swarm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2758,
    "signature": "(self, swarm)",
    "parameters": [
      {
        "name": "swarm",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unregister swarm (called during swarm cleanup)",
    "harvested_comments": [
      "WeakSet handles weak references internally, just remove the swarm directly"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": true
  },
  {
    "name": "meshVariable_lookup_by_symbol",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2996,
    "signature": "(mesh, sympy_object)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sympy_object",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Given a sympy object, scan the mesh variables in `mesh` to find the\nlocation (meshvariable, component in the data array) corresponding to the symbol\nor return None if not found",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "petsc_dm_find_labeled_points_local",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 3013,
    "signature": "(dm, label_name, label_value, sectionIndex = False, verbose = False)",
    "parameters": [
      {
        "name": "dm",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "label_value",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sectionIndex",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Identify local points associated with \"Label\"\n\ndm -> expects a petscDM object\nlabel_name -> \"String Name for Label\"\nsectionIndex -> False: leave points as indexed by the relevant section on the dm\n                True: index into the local coordinate array\n\nNOTE: Assumes uniform element types",
    "harvested_comments": [
      "print(f\"Label: {label_name} / {label_value}\")",
      "print(f\"points: {pStart}: {pEnd}\")",
      "print(f\"edges : {eStart}: {eEnd}\")",
      "print(f\"faces : {fStart}: {fEnd}\")",
      "print(f\"\", flush=True)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": true
  },
  {
    "name": "units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 407,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Return the units associated with this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "units",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 412,
    "signature": "(self, value)",
    "parameters": [
      {
        "name": "value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set the units for this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "has_units",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 417,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this variable has units.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "dimensionality",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 422,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Get the dimensionality of this variable.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_raw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 598,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Pack data array to PETSc using traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\ndata_array : numpy.ndarray\n    Array data in traditional flat format (-1, num_components)\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "Convert to expected shape: (-1, num_components)",
      "Direct PETSc access (following mesh.access pattern)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Direct assignment to PETSc vec (like mesh.access does at line 1156)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "pack_uw_data_to_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 652,
    "signature": "(self, data_array, sync = True)",
    "parameters": [
      {
        "name": "data_array",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced pack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nCRITICAL: This is the entry point where dimensional data enters PETSc storage.\nAll unit conversion and non-dimensionalization must happen here.\n\nParameters\n----------\ndata_array : numpy.ndarray or UWQuantity or UnitAwareArray\n    Array data to pack into mesh field. Can have units (will be converted).\nsync : bool\n    Whether to sync parallel operations (default True)",
    "harvested_comments": [
      "STEP 1: Handle unit conversion for incoming data",
      "This is CRITICAL for the array setter to work correctly with units",
      "Check if data has units (UWQuantity or UnitAwareArray)",
      "Data has units - need to convert and extract magnitude",
      "Convert incoming units to variable's units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_raw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 755,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Unpack data from PETSc in traditional data shape (-1, num_components).\nDirect PETSc access without access() context for backward compatibility.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in traditional flat format (-1, num_components)",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Sync parallel operations if requested"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "unpack_uw_data_from_petsc",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 804,
    "signature": "(self, squeeze = True, sync = True)",
    "parameters": [
      {
        "name": "squeeze",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "sync",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Enhanced unpack method that directly accesses mesh data without access() context.\nDesigned for the new meshVariable.array interface.\n\nParameters\n----------\nsqueeze : bool\n    Whether to remove singleton dimensions (default True)\nsync : bool\n    Whether to sync parallel operations (default True)\n\nReturns\n-------\nnumpy.ndarray\n    Array data in correct shape for the variable",
    "harvested_comments": [
      "Direct PETSc access (following mesh.access pattern at line 1156)",
      "Ensure vector is available",
      "Mark mesh DM as initialized (replaces old _accessed flag logic)",
      "Get data directly from PETSc vec (like mesh.access does)",
      "Unpack data using same layout as original method"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "save",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 888,
    "signature": "(self, filename: str, name: Optional[str] = None, index: Optional[int] = None)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      },
      {
        "name": "name",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "index",
        "type_hint": "Optional[int]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Append variable data to the specified mesh hdf5\ndata file. The file must already exist.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file. It\n    must already exist.\nname :\n    Textual name for dataset. In particular, this\n    will be used for XDMF generation. If not\n    provided, the variable name will be used.\nindex :\n    Not currently supported. An optional index which\n    might correspond to the timestep (for example).",
    "harvested_comments": [
      "Keep vector available for future access",
      "# JM:To enable timestep recording, the following needs to be called.",
      "# I'm unsure if the corresponding xdmf functionality is enabled via",
      "# the PETSc xdmf script.",
      "PetscViewerHDF5PushTimestepping(cviewer)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "write",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 970,
    "signature": "(self, filename: str)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": "str",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Write variable data to the specified mesh hdf5\ndata file. The file will be over-written.\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.\n\nParameters\n----------\nfilename :\n    The filename of the mesh checkpoint file",
    "harvested_comments": [
      "Keep vector available for future access",
      "Variable coordinates - let's put those in the file to",
      "make it a standalone \"swarm\"",
      "# Add variable unit metadata to standalone file",
      "Use preferred selective_ranks pattern for unit metadata"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "read_timestep",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1068,
    "signature": "(self, data_filename, data_name, index, outputPath = '', verbose = False)",
    "parameters": [
      {
        "name": "data_filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "data_name",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "index",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "outputPath",
        "type_hint": null,
        "default": "''",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a mesh variable from an arbitrary vertex-based checkpoint file\nand reconstruct/interpolate the data field accordingly. The data sizes / meshes can be\ndifferent and will be matched using a kd-tree / inverse-distance weighting\nto the new mesh.",
    "harvested_comments": [
      "Fix this to match the write_timestep function",
      "mesh.write_timestep( \"test\", meshUpdates=False, meshVars=[X], outputPath=\"\", index=0)",
      "swarm.write_timestep(\"test\", \"swarm\", swarmVars=[var], outputPath=\"\", index=0)",
      "check if data_file exists",
      "Keep vector available for future access"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "fn",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1190,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists (deprecated)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "ijk",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1197,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the (i,j,k) spatial view of this variable if it exists",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1204,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to the sympy.Matrix view of this variable",
    "harvested_comments": [
      "Note: Scaling is applied during unwrap(), not here"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sym_1d",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1212,
    "signature": "(self) -> sympy.Basic",
    "parameters": [],
    "returns": "sympy.Basic",
    "existing_docstring": "The handle to a flattened version of the sympy.Matrix view of this variable.\nAssume components are stored in the same order that sympy iterates entries in\na matrix except for the symmetric tensor case where we store in a Voigt form",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mesh",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1398,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The mesh this variable belongs to (accessed via weak reference).\nRaises RuntimeError if the mesh has been garbage collected.",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "vec",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1415,
    "signature": "(self) -> PETSc.Vec",
    "parameters": [],
    "returns": "PETSc.Vec",
    "existing_docstring": "The corresponding PETSc local vector for this variable.",
    "harvested_comments": [
      "Ensure vector is initialized when accessed"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "old_data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1429,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "TESTING: Original data property implementation.\nNumpy proxy array to underlying variable data.\nNote that the returned array is a proxy for all the *local* nodal\ndata, and is provided as 1d list.\n\nFor both read and write, this array can only be accessed via the\nmesh `access()` context manager.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1444,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view of canonical data with automatic format conversion.\nShape: (N, a, b) for tensor shape (a, b).\n\nThis property is ALWAYS a view of the canonical .data property.\nNo direct PETSc access - all changes delegate back to canonical storage.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "data",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2114,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Canonical data storage with PETSc synchronization.\nShape: (-1, num_components) - flat format for backward compatibility.\n\nThis is the ONLY property that handles PETSc synchronization to avoid conflicts.\nThe .array property uses this as its underlying storage with format conversion.\n\nReturns\n-------\nNDArray_With_Callback\n    Array with shape (-1, num_components) with automatic PETSc synchronization",
    "harvested_comments": [
      "Cache and reuse canonical data object to avoid field access conflicts",
      "Use direct __dict__ check to avoid potential attribute access issues",
      "Create the single canonical data array with PETSc sync"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2202,
    "signature": "(self, array_value)",
    "parameters": [
      {
        "name": "array_value",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Set variable data using pack method to handle shape transformation.",
    "harvested_comments": [
      "Use pack method to handle proper data transformation and shape conversion"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "min",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2256,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable minimum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of minimum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "max",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2284,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable maximum value.\nReturns the value only (not the rank). For multi-component variables,\nreturns a tuple of maximum values for each component.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "sum",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2312,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable sum value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "norm",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2340,
    "signature": "(self, norm_type) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "norm_type",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable norm value.\n\nnorm_type: type of norm, one of\n    - 0: NORM 1 ||v|| = sum_i | v_i |. ||A|| = max_j || v_*j ||\n    - 1: NORM 2 ||v|| = sqrt(sum_i |v_i|^2) (vectors only)\n    - 3: NORM INFINITY ||v|| = max_i |v_i|. ||A|| = max_i || v_i* ||, maximum row sum\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "mean",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2373,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable mean value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw non-dimensional values from PETSc",
      "Dimensionalise using units system"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "std",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2400,
    "signature": "(self) -> Union[float, tuple]",
    "parameters": [],
    "returns": "Union[float, tuple]",
    "existing_docstring": "The global variable standard deviation value.\n\nWhen units are enabled (model.has_units() == True), returns UWQuantity\nwith proper dimensionality.",
    "harvested_comments": [
      "Sync local\u2192global to ensure global vector has latest data",
      "Get raw values from PETSc",
      "For scalar: std = sqrt((sum(x^2)/n) - (sum(x)/n)^2)",
      "Create a temporary vector for x^2 computation",
      "Calculate variance: E[x^2] - (E[x])^2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2456,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Universal statistics method for all variable types.\n\nReturns various statistical measures appropriate for the variable type.\nFor scalars: standard statistical measures.\nFor vectors: magnitude-based statistics.\nFor tensors: Frobenius norm and invariant-based measures.\n\nReturns\n-------\ndict\n    Dictionary containing statistical measures:\n    - 'type': Variable type ('scalar', 'vector', 'tensor')\n    - 'components': Number of components\n    - 'size': Number of elements\n    - 'mean': Mean value (scalar) or magnitude mean (vector/tensor)\n    - 'min': Minimum value (scalar) or magnitude min (vector/tensor)\n    - 'max': Maximum value (scalar) or magnitude max (vector/tensor)\n    - 'sum': Sum of all values\n    - 'norm2': L2 norm\n    - 'rms': Root mean square\n\n    Additional keys for vectors/tensors:\n    - 'magnitude_*': Statistics on vector magnitude\n    - 'frobenius_*': Statistics on tensor Frobenius norm (for tensors)\n\nNote: This is a COLLECTIVE operation - all MPI ranks must call it.",
    "harvested_comments": [
      "This uses a private work MeshVariable and the various norms defined there but",
      "could either be simplified to just use petsc vectors, or extended to",
      "compute integrals over the elements which is in line with uw1 and uw2"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2622,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "The array of variable vertex coordinates for this variable's DOF locations.\n\nReturns coordinates for this variable's specific degree-of-freedom locations,\nwhich may differ from mesh coordinate variable locations if the degrees differ.\n\nWhen mesh has reference quantities set, returns unit-aware coordinates in meters.",
    "harvested_comments": [
      "Get non-dimensional [0-1] model coordinates for this variable's specific DOF locations",
      "If mesh has units, dimensionalise to physical coordinates",
      "Dimensionalise using the proper units system",
      "Specify length dimensionality since coords have dimension [length]",
      "No units - return non-dimensional coordinates"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "coords_nd",
    "kind": "property",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2652,
    "signature": "(self) -> numpy.ndarray",
    "parameters": [],
    "returns": "numpy.ndarray",
    "existing_docstring": "Non-dimensional [0-1] coordinates for this variable's DOF locations.\n\nReturns raw model coordinates from PETSc without any unit wrapping.\nThis is the coordinate system used by internal KDTree indexing, evaluation,\nand other algorithmic operations.\n\nFor user-facing operations with physical units, use `.coords` which returns\ndimensional coordinates when the model has reference quantities set.\n\nReturns\n-------\nndarray\n    Non-dimensional [0-1] coordinates, shape (N, dim)\n\nExamples\n--------\n>>> # Internal algorithmic use - KDTree indexing\n>>> kd_tree = uw.kdtree.KDTree(var.coords_nd)\n>>>\n>>> # User-facing display with dimensional units\n>>> print(f\"Positions: {var.coords}\")  # Shows meters, km, etc.\n\nNotes\n-----\nThis is a zero-copy operation that returns a view of the cached coordinate\narray directly from the mesh. No memory allocation or copying occurs.\n\nSee Also\n--------\ncoords : Dimensional coordinates with unit wrapping (user-facing)",
    "harvested_comments": [
      "Internal algorithmic use - KDTree indexing",
      "User-facing display with dimensional units",
      "Shows meters, km, etc.",
      "Direct access to non-dimensional coordinates from mesh cache",
      "This is a ZERO-COPY operation - returns cached array directly"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": true
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 133,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, verbose = False, degree = 2, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Keep track",
      "# Parent class will set up default values etc",
      "default values for properties"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Poisson",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 298,
    "signature": "(self, mesh: uw.discretisation.Mesh, h_Field: Optional[uw.discretisation.MeshVariable] = None, v_Field: Optional[uw.discretisation.MeshVariable] = None, degree: int = 2, verbose = False, DuDt = None, DFDt = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "h_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "v_Field",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "# Set up the projection operator that",
      "# solves the flow rate",
      "If we add smoothing, it should be small"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Darcy",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 545,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Not used in Stokes, but may be used in NS, VE etc",
      "User-facing operations are matrices / vectors by preference",
      "by default, incompressibility constraint",
      "this attrib records if we need to setup the problem (again)"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 880,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: Optional[uw.discretisation.MeshVariable] = None, pressureField: Optional[uw.discretisation.MeshVariable] = None, degree: Optional[int] = 2, order: Optional[int] = 2, p_continuous: Optional[bool] = True, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "Optional[uw.discretisation.MeshVariable]",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "True",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "DuDt Not used in VE, but may be in child classes",
      "Stokes is parent (will not build DuDt or DFDt)",
      "VE time-order"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_VE_Stokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1023,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1114,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Default: project zero vector"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Vector_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1231,
    "signature": "(self, mesh: uw.discretisation.Mesh, tensor_Field: uw.discretisation.MeshVariable = None, scalar_Field: uw.discretisation.MeshVariable = None, degree = 2, verbose = False)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "tensor_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "scalar_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Tensor_Projection",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1382,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, V_fn: Union[uw.discretisation.MeshVariable, sympy.Basic], order: int = 1, restore_points_func: Callable = None, verbose = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "V_fn",
        "type_hint": "Union[uw.discretisation.MeshVariable, sympy.Basic]",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Should be a sympy function",
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1812,
    "signature": "(self, mesh: uw.discretisation.Mesh, u_Field: uw.discretisation.MeshVariable, order: int = 1, theta: float = 0.0, evalf: Optional[bool] = False, verbose = False, DuDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "u_Field",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "theta",
        "type_hint": "float",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "evalf",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[Eulerian_DDt, SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values etc",
      "default values for properties",
      "These are unique to the advection solver",
      "## Setup the history terms ... This version should not build anything",
      "## by default - it's the template / skeleton"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2187,
    "signature": "(self, mesh: uw.discretisation.Mesh, velocityField: uw.discretisation.MeshVariable, pressureField: uw.discretisation.MeshVariable, rho: Optional[float] = 0.0, restore_points_func: Callable = None, order: Optional[int] = 2, p_continuous: Optional[bool] = False, verbose: Optional[bool] = False, DuDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None, DFDt: Union[SemiLagrangian_DDt, Lagrangian_DDt] = None)",
    "parameters": [
      {
        "name": "mesh",
        "type_hint": "uw.discretisation.Mesh",
        "default": null,
        "description": ""
      },
      {
        "name": "velocityField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "pressureField",
        "type_hint": "uw.discretisation.MeshVariable",
        "default": null,
        "description": ""
      },
      {
        "name": "rho",
        "type_hint": "Optional[float]",
        "default": "0.0",
        "description": ""
      },
      {
        "name": "restore_points_func",
        "type_hint": "Callable",
        "default": "None",
        "description": ""
      },
      {
        "name": "order",
        "type_hint": "Optional[int]",
        "default": "2",
        "description": ""
      },
      {
        "name": "p_continuous",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": "Optional[bool]",
        "default": "False",
        "description": ""
      },
      {
        "name": "DuDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      },
      {
        "name": "DFDt",
        "type_hint": "Union[SemiLagrangian_DDt, Lagrangian_DDt]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Parent class will set up default values and load u_Field into the solver",
      "These are unique to the advection solver",
      "self._E = self.mesh.vector.strain_tensor(self.u.sym)",
      "## sets up DuDt and DFDt",
      "# ._setup_history_terms()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "_BaseMeshVariable",
    "kind": "class",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 47,
    "signature": "class _BaseMeshVariable",
    "parameters": [],
    "returns": null,
    "existing_docstring": "The MeshVariable class generates a variable supported by a finite element mesh and the\nunderlying sympy representation that makes it possible to construct expressions that\ndepend on the values of the MeshVariable.\n\nTo set / read nodal values, use the numpy interface via the 'data' property.\n\nParameters\n----------\nvarname :\n    A text name for this variable. Use an R-string if a latex-expression is used\nmesh :\n    The supporting underworld mesh.\nnum_components :\n    The number of components this variable has.\n    For example, scalars will have `num_components=1`,\n    while a 2d vector would have `num_components=2`.\nvtype :\n    Optional. The underworld variable type for this variable.\n    If not defined it will be inferred from `num_components`\n    if possible.\ndegree :\n    The polynomial degree for this variable.\nvarsymbol:\n    Over-ride the varname with a symbolic form for printing etc (latex). Should be an R-string.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1371,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_AdvectionDiffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 1802,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_Diffusion",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/systems/solvers.py",
    "line": 2175,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# feedback on this instance"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "SNES_NavierStokes",
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 157,
    "signature": "(self, plex_or_meshfile, degree = 1, simplex = True, coordinate_system_type = None, qdegree = 2, markVertices = None, useRegions = None, useMultipleTags = None, filename = None, refinement = None, refinement_callback = None, coarsening = None, coarsening_callback = None, return_coords_to_bounds = None, boundaries = None, boundary_normals = None, name = None, units = None, verbose = False, *args, **kwargs)",
    "parameters": [
      {
        "name": "plex_or_meshfile",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "simplex",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "coordinate_system_type",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "qdegree",
        "type_hint": null,
        "default": "2",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "filename",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "refinement_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "coarsening_callback",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_coords_to_bounds",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundaries",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "boundary_normals",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "name",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "*args",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "**kwargs",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Get coordinate units from model (not user parameter)",
      "The model owns the unit system - all meshes use the same units",
      "Ignore user-provided units parameter, get from model instead",
      "Set units from model",
      "Lock model units now that a mesh has been created"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_apply_unit_aware_scaling",
    "kind": "function",
    "file": "src/underworld3/systems/solvers.py",
    "line": 24,
    "signature": "(dt_nondimensional, field, mesh)",
    "parameters": [
      {
        "name": "dt_nondimensional",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "field",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Helper function to apply unit-aware scaling to timestep estimates.\n\nDetects the units of the velocity field and applies appropriate time scaling\nto convert nondimensional timestep to physical time units.\n\nParameters\n----------\ndt_nondimensional : float or np.ndarray\n    The nondimensional timestep estimate\nfield : MeshVariable or SymPy expression (often a Matrix)\n    The velocity field - units are detected from this\nmesh : Mesh\n    The mesh (may have reference to model with time scales)\n\nReturns\n-------\nfloat or UWQuantity\n    Timestep with physical time units if detectable, otherwise nondimensional",
    "harvested_comments": [
      "Extract a component from field if it's a Matrix (common for velocity)",
      "Extract first component: V_fn[0] or V_fn[0,0]",
      "Try to get units from the field expression",
      "Field has units - verify it has time dimension (as expected for velocity)",
      "Get dimensionality: e.g., {'[length]': 1, '[time]': -1} for velocity"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__init__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 130,
    "signature": "(self, varname = None, mesh = None, num_components = None, vtype = None, degree = 1, continuous = True, varsymbol = None, _register = True, units = None, units_backend = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": null,
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Initialize MeshVariable (only called for NEW objects).\n\nRetrieves initialization parameters from __new__ and handles DM reconstruction.",
    "harvested_comments": [
      "Only initialize if this is a new object (not returned existing)",
      "Already initialized",
      "Get parameters - either from __new__ (via _init_params) or direct arguments",
      "Parameters from __new__ method",
      "Direct initialization (should not happen with __new__ pattern, but for safety)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__cinit__",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 59,
    "signature": "def __cinit__( self,\n                   points_input not None:   numpy.ndarray ) :",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__dealloc__",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 81,
    "signature": "def __dealloc__(self):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_convert_coords_to_tree_units",
    "kind": "method",
    "file": "src/underworld3/ckdtree.pyx",
    "line": 92,
    "signature": "def _convert_coords_to_tree_units(self, coords):",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1144,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_DS",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1960,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "Build this from the PETScDS rather than the SWARM",
      "self._index.build_index()"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1983,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "Use raw internal array for KD-tree construction (avoid unit-aware wrapping)",
      "for face in range(cell_num_faces):",
      "points = self.dm.getTransitiveClosure(cell_faces[face])[0][",
      "-face_num_points:"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_build_kd_tree_index_PIC",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2065,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "# Bootstrapping - the kd-tree is needed to build the index but",
      "# the index is also used in the kd-tree.",
      "Create a temp swarm which we'll use to populate particles",
      "at gauss points. These will then be used as basis for",
      "kd-tree indexing back to owning cells."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_domain_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2636,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_data_layout",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1242,
    "signature": "(self, i, j = None)",
    "parameters": [
      {
        "name": "i",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "j",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_setup_ds",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1287,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "self.clean_name ## Filling up the options database",
      "only active if discontinuous",
      "Check if this is the first field or if we need to rebuild the DM",
      "(needed to ensure Section is properly synchronized with field list)",
      "DM already has fields - need to rebuild to sync Section"
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_set_vec",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1379,
    "signature": "(self, available)",
    "parameters": [
      {
        "name": "available",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [
      "not sure if required, but to be sure.",
      "This is set for checkpointing."
    ],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "__del__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1391,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": null,
    "harvested_comments": [],
    "status": "none",
    "needs": [
      "NEEDS_OVERVIEW",
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_from_gmsh",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 47,
    "signature": "(filename, comm = None, markVertices = False, useRegions = True, useMultipleTags = True)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "markVertices",
        "type_hint": null,
        "default": "False",
        "description": ""
      },
      {
        "name": "useRegions",
        "type_hint": null,
        "default": "True",
        "description": ""
      },
      {
        "name": "useMultipleTags",
        "type_hint": null,
        "default": "True",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a Gmsh .msh file from `filename`.\n\n:kwarg comm: Optional communicator to build the mesh on (defaults to\n    COMM_WORLD).",
    "harvested_comments": [
      "# NOTE: - this should be smart enough to serialise the msh conversion",
      "# and then read back in parallel via h5.  This is currently done",
      "# by every gmesh mesh",
      "This option allows objects to be in multiple physical groups",
      "Rather than just the first one found."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_from_plexh5",
    "kind": "function",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 117,
    "signature": "(filename, comm = None, return_sf = False)",
    "parameters": [
      {
        "name": "filename",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "comm",
        "type_hint": null,
        "default": "None",
        "description": ""
      },
      {
        "name": "return_sf",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Read a dmplex .h5 file from `filename` provided.\n\ncomm: Optional communicator to build the mesh on (defaults to\nCOMM_WORLD).",
    "harvested_comments": [
      "h5plex = PETSc.DMPlex().createFromFile(filename, comm=comm)",
      "Do this as well"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": null,
    "is_public": false
  },
  {
    "name": "_deform_mesh",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1148,
    "signature": "(self, new_coords: numpy.ndarray, verbose = False)",
    "parameters": [
      {
        "name": "new_coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      },
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This method will update the mesh coordinates and reset any cached coordinates in\nthe mesh and in equation systems that are registered on the mesh.\n\nThe coord array that is passed in should match the shape of self.data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_legacy_access",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1165,
    "signature": "(self, *writeable_vars)",
    "parameters": [
      {
        "name": "*writeable_vars",
        "type_hint": "'MeshVariable'",
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This context manager makes the underlying mesh variables data available to\nthe user. The data should be accessed via the variables `data` handle.\n\nAs default, all data is read-only. To enable writeable data, the user should\nspecify which variable they wish to modify.\n\nParameters\n----------\nwriteable_vars\n    The variables for which data write access is required.\n\nExample\n-------\n>>> import underworld3 as uw\n>>> someMesh = uw.discretisation.FeMesh_Cartesian()\n>>> with someMesh._deform_mesh():\n...     someMesh.data[0] = [0.1,0.1]\n>>> someMesh.data[0]\narray([ 0.1,  0.1])",
    "harvested_comments": [
      "Invalidate DMInterpolation cache when DM structure changes",
      "if already accessed within higher level context manager, continue.",
      "set flag so variable status can be known elsewhere",
      "add to de-access list to rewind this later",
      "create & set vec"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_var",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1900,
    "signature": "(self, var)",
    "parameters": [
      {
        "name": "var",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [
      "if array already created, return."
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_coords_for_basis",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 1915,
    "signature": "(self, degree, continuous)",
    "parameters": [
      {
        "name": "degree",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "This function returns the vertex array for the\nprovided variable. If the array does not already exist,\nit is first created and then returned.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2121,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each mesh face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the plane\ndefined by a face (i.e. same side or other side as the cell centroid). If we are inside\nfor all faces in a convex polyhedron, then we are inside the cell.\n\nInternal Coordinate System Access Pattern\n------------------------------------------\nThis method uses `self._coords` (raw PETSc array) instead of `self.data`\nor `self.X.coords` (unit-wrapped properties) for performance and correctness:\n\n1. **Guard at boundaries**: External interfaces use unit-aware properties\n2. **Raw access internally**: Internal geometric calculations use `self._coords`\n3. **Performance**: Avoids UnitAwareArray overhead in tight loops\n4. **Correctness**: Prevents unit conversion issues in geometric operations\n\nThis is the recommended pattern for internal mesh operations that manipulate\ncoordinates directly.",
    "harvested_comments": [
      "def mesh_face_skeleton_kdtree(mesh):",
      "All elements in our mesh are a single type",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)",
      "Compute face normal from point coordinates (already plain numpy arrays)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_test_if_points_in_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2216,
    "signature": "(self, points, cells)",
    "parameters": [
      {
        "name": "points",
        "type_hint": null,
        "default": null,
        "description": ""
      },
      {
        "name": "cells",
        "type_hint": null,
        "default": null,
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Determine if the given points lie in the suggested cells.\nUses a mesh skeletonization array to determine whether the point is\nwith the convex polygon / polyhedron defined by a cell.\n\nExact if applied to a linear mesh, approximate otherwise.\n\nParameters\n----------\npoints : array-like\n    Coordinate array in any physical unit system (will be auto-converted)\ncells : array-like\n    Cell indices to test",
    "harvested_comments": [
      "Internal version - points assumed to already be in model units"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_mark_local_boundary_faces_inside_and_out",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2255,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create a collection of control point pairs that are slightly inside\nand slightly outside each boundary-defining face (mirrors to each other). This\nallows a fast lookup of whether we on the inside or outside of the domain.\nWe cannot ensure convexity, so this is approximate when close to the boundary",
    "harvested_comments": [
      "Use raw array for internal calculations",
      "3D simplex case (probably also OK for hexes)",
      "Control points near centroid",
      "Control points closer to face nodes"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_closest_local_cells_internal",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2438,
    "signature": "(self, coords: numpy.ndarray) -> numpy.ndarray",
    "parameters": [
      {
        "name": "coords",
        "type_hint": "numpy.ndarray",
        "default": null,
        "description": ""
      }
    ],
    "returns": "numpy.ndarray",
    "existing_docstring": "This method uses a kd-tree algorithm to find the closest\ncells to the provided coords. For a regular mesh, this should\nbe exactly the owning cell, but if the mesh is deformed, this\nis not guaranteed. Also compares the distance from the cell to the\npoint - if this is larger than the \"cell size\" then returns -1\n\nParameters:\n-----------\ncoords:\n    An array of the coordinates for which we wish to determine the\n    closest cells. This should be a 2-dimensional array of\n    shape (n_coords,dim) in any physical unit system (will be auto-converted).\n\nReturns:\n--------\nclosest_cells:\n    An array of indices representing the cells closest to the provided\n    coordinates. This will be a 1-dimensional array of\n    shape (n_coords).",
    "harvested_comments": [
      "Internal version - coords assumed to already be in model units",
      "Create index if required",
      "We need to filter points that lie outside the mesh but",
      "still are allocated a nearby element by this distance-only check.",
      "Part 2 - try to find the lost points by walking nearby cells"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_sizes",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2583,
    "signature": "(self, verbose = False)",
    "parameters": [
      {
        "name": "verbose",
        "type_hint": null,
        "default": "False",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Obtain the (local) mesh radii and centroids using kdtree distances\nThis routine is called when the mesh is built / rebuilt",
    "harvested_comments": [
      "Use raw internal array for internal mesh operations (avoid unit-aware wrapping)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_get_mesh_centroids",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2617,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Obtain and cache the (local) mesh centroids using underworld swarm technology.\nThis routine is called when the mesh is built / rebuilt\n\nThe global cell number corresponding to a centroid is (supposed to be)\nself.dm.getCellNumbering().array.min() + index",
    "harvested_comments": [
      ") = petsc_discretisation.petsc_fvm_get_local_cell_sizes(self)"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "_increment_mesh_version",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh.py",
    "line": 2763,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Manually increment mesh version to notify swarms of coordinate changes.\nThis is called automatically when mesh.points is modified, but can be\ncalled manually if coordinates are changed through other means.",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS",
      "NEEDS_RETURNS"
    ],
    "parent_class": "Mesh",
    "is_public": false
  },
  {
    "name": "__new__",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 76,
    "signature": "(cls, varname: Union[str, list], mesh: 'Mesh', num_components: Union[int, tuple] = None, vtype: Optional['uw.VarType'] = None, degree: int = 1, continuous: bool = True, varsymbol: Union[str, list] = None, _register: bool = True, units: Optional[str] = None, units_backend: Optional[str] = None)",
    "parameters": [
      {
        "name": "varname",
        "type_hint": "Union[str, list]",
        "default": null,
        "description": ""
      },
      {
        "name": "mesh",
        "type_hint": "'Mesh'",
        "default": null,
        "description": ""
      },
      {
        "name": "num_components",
        "type_hint": "Union[int, tuple]",
        "default": "None",
        "description": ""
      },
      {
        "name": "vtype",
        "type_hint": "Optional['uw.VarType']",
        "default": "None",
        "description": ""
      },
      {
        "name": "degree",
        "type_hint": "int",
        "default": "1",
        "description": ""
      },
      {
        "name": "continuous",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "varsymbol",
        "type_hint": "Union[str, list]",
        "default": "None",
        "description": ""
      },
      {
        "name": "_register",
        "type_hint": "bool",
        "default": "True",
        "description": ""
      },
      {
        "name": "units",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      },
      {
        "name": "units_backend",
        "type_hint": "Optional[str]",
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Create or return existing MeshVariable instance.\n\nHandles object uniqueness and mesh DM state management.",
    "harvested_comments": [
      "# Check if already defined (return existing object)",
      "NOTE: DM reconstruction is now handled in _setup_ds() - no snapshotting needed here",
      "Create new instance",
      "Store parameters for __init__"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_variable_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 431,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for variable data.\nFollows the same pattern as mesh.points implementation.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Create NDArray_With_Callback (following mesh._points pattern)",
      "Allow operations like existing arrays",
      "Single callback function (following mesh_update_callback pattern)",
      "Only act on data-changing operations (following mesh.points pattern)",
      "Prevent recursion by checking if we're already in a callback"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_flat_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 494,
    "signature": "(self, initial_data = None)",
    "parameters": [
      {
        "name": "initial_data",
        "type_hint": null,
        "default": "None",
        "description": ""
      }
    ],
    "returns": null,
    "existing_docstring": "Factory function to create NDArray_With_Callback for backward-compatible flat data.\nReturns data in shape (-1, num_components) using pack_raw/unpack_raw methods.\n\nParameters\n----------\ninitial_data : numpy.ndarray, optional\n    Initial data for the array. If None, fetches current data from PETSc.\n\nReturns\n-------\nNDArray_With_Callback\n    Array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Use unpack_raw to get flat format (-1, num_components)",
      "Create NDArray_With_Callback for flat data",
      "Allow operations like existing arrays",
      "Callback for flat data format",
      "Only act on data-changing operations"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_object_viewer",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 556,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "This will substitute specific information about this object",
    "harvested_comments": [
      "feedback on this instance"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1454,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create array view of canonical data using appropriate conversion strategy.\n\nStrategy depends on variable complexity:\n- Scalars/Vectors: Simple reshape operations\n- 2D+ Tensors: Complex pack/unpack operations\n\nReturns\n-------\nArrayView\n    Array-like object that delegates changes back to canonical data",
    "harvested_comments": [],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_is_simple_variable",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1472,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Check if this is a simple scalar/vector variable (not a complex tensor)",
    "harvested_comments": [],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_simple_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1476,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for scalars/vectors using simple reshape operations",
    "harvested_comments": [
      "Simple reshape: (-1, num_components) -> (N, a, b)",
      "For simple variables, reshape to (N, a, b) format",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_tensor_array_view",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 1804,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Array view for complex tensors using pack/unpack operations",
    "harvested_comments": [
      "Use complex pack/unpack for tensor layouts",
      "Apply dimensionalization if needed",
      "Check if variable has units and model has reference quantities",
      "Variable has units - wrap with UnitAwareArray",
      "Get variable units (needed for both branches)"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_create_canonical_data_array",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2135,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Create the single canonical data array with PETSc synchronization for MeshVariable.\nThis is the ONLY method that creates arrays with PETSc callbacks.\n\nHandles mesh-specific requirements like locking and ghost value synchronization.\n\nReturns\n-------\nNDArray_With_Callback\n    Canonical array object with callback for automatic PETSc synchronization",
    "harvested_comments": [
      "Ensure PETSc vector is available",
      "Get direct access to PETSc vector in packed format",
      "Create NDArray_With_Callback with proper shape and data",
      "Single canonical callback for PETSc synchronization",
      "Only act on data-changing operations"
    ],
    "status": "partial",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_dimensionalise_stat",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2211,
    "signature": "(self, value: Union[float, tuple]) -> Union[float, tuple]",
    "parameters": [
      {
        "name": "value",
        "type_hint": "Union[float, tuple]",
        "default": null,
        "description": ""
      }
    ],
    "returns": "Union[float, tuple]",
    "existing_docstring": "Helper to dimensionalise statistical values using uw.dimensionalise().\n\nTakes non-dimensional value(s) from PETSc and converts to dimensional\nform using the variable's units and model reference quantities.\n\nParameters\n----------\nvalue : float or tuple\n    Non-dimensional value(s) from PETSc\n\nReturns\n-------\nfloat, tuple, or UWQuantity\n    Dimensionalised value(s) if units are enabled, else unchanged",
    "harvested_comments": [
      "Check if units mode is enabled",
      "Backward compatible - no units mode or variable has no units",
      "Extract dimensionality from units",
      "self.units is already a Pint Unit object with .dimensionality attribute",
      "Pint Unit object - extract dimensionality directly"
    ],
    "status": "complete",
    "needs": [],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_scalar_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2519,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for scalar variables (original implementation).",
    "harvested_comments": [
      "Now returns value directly, not tuple",
      "Now returns value directly, not tuple"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_vector_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2543,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for vector variables using magnitude.",
    "harvested_comments": [
      "Create temporary scalar variable for magnitude",
      "Compute magnitude: |v| = sqrt(v\u00b7v)",
      "Get scalar stats on magnitude",
      "Update with vector-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  },
  {
    "name": "_tensor_stats",
    "kind": "method",
    "file": "src/underworld3/discretisation/discretisation_mesh_variables.py",
    "line": 2581,
    "signature": "(self)",
    "parameters": [],
    "returns": null,
    "existing_docstring": "Statistics for tensor variables using Frobenius norm.",
    "harvested_comments": [
      "Create temporary scalar variable for Frobenius norm",
      "Compute Frobenius norm: ||A||_F = sqrt(sum(A_ij^2))",
      "Get scalar stats on Frobenius norm",
      "Update with tensor-specific info",
      "Cleanup temporary variable"
    ],
    "status": "minimal",
    "needs": [
      "NEEDS_PARAMETERS"
    ],
    "parent_class": "_BaseMeshVariable",
    "is_public": false
  }
]