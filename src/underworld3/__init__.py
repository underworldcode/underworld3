"""## Underworld3 Python package

`Underworld3` is a finite element, particle-in-cell geodynamics code that produces
mathematically self-describing models through an interface with `sympy` Underworld3 builds upon the `PETSc`
parallel finite element and solver package, using their `petsc4py` library.

A common pattern for building `underworld3` models is to develop python scripts in notebook-friendly form
(e.g. with `jupytext`) which are thoroughly documented through markdown descriptions. `underworld` objects
are similarly documented so that their underlying algorithmic and mathemcical structure can be examined in
a notebook.

`python` scripts built this way will also be compatible with `mpirun` for parallel execution.

## Documentation

The underworld documentation is in two parts: the user manual / theory manual is a hand-written document that is built from this repository automatically
from the sources in the `Jupyterbook` directory. This api documentation is autogenerated from the code and its annotations. There are two version of
each documentation package that are published online. The main (stable) branch

- https://underworldcode.github.io/underworld3/main/index.html
- https://underworldcode.github.io/underworld3/main_api/underworld3/index.html

The development branch has similar documentation:

- https://underworldcode.github.io/underworld3/development/index.html
- https://underworldcode.github.io/underworld3/development_api/underworld3/index.html

## Building / installation

Refer to the Dockerfile for uw3 build instructions.

To install from the repository
```shell
./scripts/compile.sh
```

An in-place installation may be helpful for developers (as distinct from above)
(`scripts/compile.sh` is a convenience wrapper to `pip install`)

```shell
pip install -e . --no-build-isolation
```

To clean the git repository or all files ... be careful.
```shell
./scripts/clean.sh
```

## Testing and documentation

Run the `pytest` testing suite with
```shell
./scripts/test.sh
```

This API documentation is build with
```shell
./scripts/build_api_docs.sh
```
Open `uw3_api_docs/index.html` to browse.

## To uninstall

```shell
pip uninstall underworld3
```

"""

from mpi4py import MPI  # for initialising MPI
import petsc4py as _petsc4py
import sys

_petsc4py.init(sys.argv)

from petsc4py import PETSc

# pop the default petsc Signal handler to let petsc errors appear in python
# unclear if this is the appropriate way see discussion
# https://gitlab.com/petsc/petsc/-/issues/1066

PETSc.Sys.popErrorHandler()

options = PETSc.Options()
options["options_left"] = 0

try:
    from ._version import __version__
except ImportError:
    __version__ = "Unknown"  # check src/underworld3/_version.py


def view():
    from IPython.display import Latex, Markdown, display
    from textwrap import dedent
    import inspect

    ## Docstring (static)
    docstring = dedent(__doc__)
    # docstring = docstring.replace("$", "$").replace("$", "$")
    display(Markdown(docstring))

    return


# PETSc.Log().begin()

# Bundle these utils
# Needed everywhere
import underworld3.mpi
from .mpi import pprint, selective_ranks, collective_operation, CollectiveOperationError
from ._var_types import *
from .utilities._petsc_tools import *
from .utilities._nb_tools import *
from .utilities._utils import auditor

from .utilities import _api_tools

# from underworld3.utilities import _api_tools
from .utilities._utils import auditor

import underworld3.adaptivity
import underworld3.coordinates
import underworld3.discretisation
import underworld3.meshing
import underworld3.constitutive_models
import underworld3.function
import underworld3.maths
import underworld3.swarm
import underworld3.systems
import underworld3.maths
import underworld3.utilities
import underworld3.model
import underworld3.parameters
import underworld3.materials
import underworld3.discretisation.persistence

from .model import Model, create_model, get_default_model, reset_default_model, ThermalConvectionConfig, create_thermal_convection_model
from .parameters import ParameterRegistry, ParameterType
from .materials import MaterialRegistry, MaterialProperty
from .constitutive_models import MultiMaterialConstitutiveModel
from .function import quantity

# Currently on binder, pykdtree is hanging - fallback to previous implementation
# import underworld3.kdtree
import underworld3.ckdtree as kdtree
import underworld3.cython
import underworld3.scaling
import underworld3.visualisation
import numpy as _np

# Units support
from .utilities import (
    UnitAwareMixin,
    UnitAwareMathematicalMixin,
    UnitsBackend,
    PintBackend,
    make_units_aware,
)

# High-level units utilities
from . import units as _units_module  # Keep module for internal use
from .units import (
    check_units_consistency,
    get_dimensionality,
    units_of,
    non_dimensionalise,
    dimensionalise,
    create_quantity,
    convert_units,
    is_dimensionless,
    has_units,
    same_units,
    validate_expression_units,
    enforce_units_consistency,
)

# Make units registry easily accessible (remove scaling terminology)
# Users can now do uw.units.K, uw.units.Pa, etc. instead of uw.scaling.units.K
from .scaling import units

# Add view() method to units registry following established pattern
def _units_view():
    """Display units registry information following the established view() pattern."""
    try:
        from IPython.display import Markdown, display

        content = f"""## Units Registry

The Underworld3 units registry provides access to physical units for dimensional analysis.

### Common Units Examples:
- **Temperature**: `uw.units.K`, `uw.units.celsius`, `uw.units.degC`
- **Pressure**: `uw.units.Pa`, `uw.units.bar`, `uw.units.atm`
- **Length**: `uw.units.m`, `uw.units.cm`, `uw.units.km`
- **Time**: `uw.units.s`, `uw.units.year`, `uw.units.Ma` (million years)
- **Viscosity**: `uw.units.Pa * uw.units.s`
- **Velocity**: `uw.units.cm / uw.units.year`

### Usage:
```python
# Create quantities
temperature = 1500 * uw.units.K
viscosity = 1e21 * uw.units.Pa * uw.units.s
velocity = 5 * uw.units.cm / uw.units.year

# Set model reference quantities
model.set_reference_quantities(
    mantle_temperature=temperature,
    mantle_viscosity=viscosity
)
```

**Total units available**: {len([attr for attr in dir(units) if not attr.startswith('_')])}
"""
        display(Markdown(content))
    except ImportError:
        # Fallback for non-Jupyter environments
        print("Underworld3 Units Registry")
        print("=" * 30)
        print(f"Total units available: {len([attr for attr in dir(units) if not attr.startswith('_')])}")
        print("\nCommon units:")
        print("  Temperature: uw.units.K, uw.units.celsius")
        print("  Pressure: uw.units.Pa, uw.units.bar")
        print("  Length: uw.units.m, uw.units.cm, uw.units.km")
        print("  Time: uw.units.s, uw.units.year")
        print("\nUsage:")
        print("  temperature = 1500 * uw.units.K")
        print("  viscosity = 1e21 * uw.units.Pa * uw.units.s")

# Attach view method to units registry
units.view = _units_view

# Scale factor context manager
from contextlib import contextmanager

# Global flag for scaled symbols
_scaled_symbols_active = False

@contextmanager
def _apply_scaling():
    """
    Internal context manager that enables automatic scaling during unwrap operations.

    This is an implementation detail. Users should use uw.unwrap(expr, apply_scaling=True) instead.
    """
    global _scaled_symbols_active
    old_value = _scaled_symbols_active
    _scaled_symbols_active = True
    try:
        yield
    finally:
        _scaled_symbols_active = old_value

def _is_scaling_active():
    """Check if scaled symbols context is active."""
    return _scaled_symbols_active

# Backward compatibility aliases (deprecated)
scaled_symbols = _apply_scaling  # For backward compatibility - deprecated, use uw.unwrap(expr, apply_scaling=True)

def unwrap(fn, keep_constants=True, return_self=True, apply_scaling=False):
    """
    Unwrap expressions with optional automatic scaling.

    Parameters:
    -----------
    fn : expression
        The expression to unwrap
    keep_constants : bool, default=True
        Whether to keep constants in the unwrapped expression
    return_self : bool, default=True
        Whether to return self if no unwrapping is needed
    apply_scaling : bool, default=False
        Whether to automatically apply scale factors to variables with units

    Example:
        model = uw.Model()
        model.set_reference_quantities(mantle_temperature=1500*uw.scaling.units.K)

        temperature = uw.discretisation.MeshVariable("T", mesh, 1, units="K")
        expr = uw.function.expression("heat", 2 * temperature.sym, "heat equation")

        # Normal unwrap
        result = uw.unwrap(expr)

        # Unwrap with automatic scaling
        scaled_result = uw.unwrap(expr, apply_scaling=True)
    """
    from .function.expressions import unwrap as _unwrap

    if apply_scaling:
        with _apply_scaling():
            return _unwrap(fn, keep_constants, return_self)
    else:
        return _unwrap(fn, keep_constants, return_self)


# Enhanced variables with units and mathematical operations (internal use only)
from .discretisation.enhanced_variables import (
    # EnhancedMeshVariable,  # Hidden - use uw.discretisation.MeshVariable
    # EnhancedSwarmVariable,  # Hidden - use uw.swarm.SwarmVariable
    create_enhanced_mesh_variable,
    create_enhanced_swarm_variable,
)

# Make MeshVariable available at top level (this is the enhanced version)
from .discretisation import MeshVariable


def synchronised_array_update(context_info="user operations"):
    """
    Context manager for synchronised array updates across multiple variables.

    Batches multiple array assignments together and defers PETSc synchronization
    until the end of the context, ensuring atomic updates and better performance.

    Example
    -------
    with uw.synchronised_array_update():
        velocity.array[...] = new_velocity_values
        pressure.array[...] = new_pressure_values
        temperature.array[...] = new_temperature_values
    # All arrays are synchronized here

    Parameters
    ----------
    context_info : str
        Optional description of the update context for debugging

    Returns
    -------
    Context manager for delayed callback execution
    """
    return utilities.NDArray_With_Callback.delay_callbacks_global(context_info)


# get the id for this installation of uw, if not there, create it
try:
    from ._uwid import uwid as _id
except:
    import uuid as _uuid

    _id = str(_uuid.uuid4())

###########################################
####### For User telemetry metrics ########

# setup metrics function *only* if we are rank==0.
# Metric can be disables by setting UW_NO_USAGE_METRICS env var.
# TODO: confirm not other condition like tests?
if underworld3.mpi.rank == 0:

    def _sendData():

        import os

        # disable collection of data if requested
        if "UW_NO_USAGE_METRICS" not in os.environ:
            # get platform info
            import platform

            sysinfo = platform.system()
            sysinfo += "__" + platform.machine()
            # check if docker
            if os.path.isfile("/.dockerinit"):
                sysinfo += "__docker"

            event_dict = {
                "properties": {
                    "version": underworld3.__version__,
                    "platform": sysinfo,
                    "run_size": underworld3.mpi.size,
                    "distinct_id": _id,
                }
            }

            # send info async
            import threading

            thread = threading.Thread(
                target=underworld3.utilities._utils.postHog,
                args=("import_uw3", event_dict),
            )
            thread.daemon = True
            thread.start()

    try:
        _sendData()
    except:  # continue quietly if something above failed
        pass

####### END User telemetry metrics ########

# Info for JIT modules.
# These dicts should be populated by submodules
# which define cython/c based classes.
# We use ordered dictionaries because the
# ordering can be important when linking in libraries.
# Note that actually what we want is an ordered set (which Python
# doesn't natively provide). Hence for the key/value pair,
# the value is always set to `None`.

from collections import OrderedDict as _OD

_libfiles = _OD()
_libdirs = _OD()
_incdirs = _OD({_np.get_include(): None})

## -------------------------------------------------------------

# pdoc3 over-rides. pdoc3 has a strange path-traversal algorithm
# that seems to have trouble finding modules if we move this
# dictionary to any other location in the underworld3 tree

__pdoc__ = {}

# Cython files cannot be documented. We should move pure
# python out of these files if we can

__pdoc__["cython"] = False
# __pdoc__["function.analytic"] = False

# Here we nuke some of the placeholders in the parent class so that they do not mask the
# child class modifications

__pdoc__["systems.constitutive_models.Constitutive_Model.Parameters"] = False

# Note: SymPy converter registration approach doesn't work reliably in strict mode
# The better approach is to ensure UWexpression arithmetic operations return SymPy objects
# This is handled by the __rmul__, __radd__ etc. methods in the mathematical mixin
