[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Underworld3 Quick Start Guide",
    "section": "",
    "text": "Installation Guide\nWelcome to Underworld3, a mathematically self-describing, finite-element code for geodynamic modelling. This quick-start guide has basic installation instructions and a brief introduction to some of the concepts in the Underworld3 code.\nAll Underworld3 source code is released under the LGPL-3 open source licence. This covers all files in underworld3 constituting the Underworld3 Python module. Notebooks, stand-alone documentation and Python scripts which show how the code is used and run are licensed under the Creative Commons Attribution 4.0 International License.\nThe quickest option is not to install anything but click on the rocket icon (top right) to launch our notebook examples on mybinder.org.\nIf do you want to install the code on your own machine, we recommend using miniconda and mamba. Create a separate virtual environment and install the code from source. More details on how to do that are in the Installation Instructions",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#sample-code",
    "href": "index.html#sample-code",
    "title": "Underworld3 Quick Start Guide",
    "section": "Sample Code",
    "text": "Sample Code\nUnderworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nIt’s a good first step after you install the code to look at the examples notebooks. When you are happy that things are working OK, you can move along to look at the full documentation or the benchmarking repository.\nThe notebooks introduce the concept of meshing to describe the domain and boundary conditions for a model and progress through Eulerian data containers, symbolic operators (functions, compositions, derivatives, evaluations). The examples move on to the template PDE solvers for scalar and vector problems (in this case the Poisson equation and the Stokes equation) and time dependent, coupled problems (a simple convection example in an annulus geometry). They cover constitutive models, boundary conditions and visualisation. The final examples deal with Lagrangian data containers (particle swarms), first transporting them in a velocity field, and second, accessing the symbolic forms of their data for use in underworld expressions.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#learn-more",
    "href": "index.html#learn-more",
    "title": "Underworld3 Quick Start Guide",
    "section": "Learn More",
    "text": "Learn More\nunderworld3 is a research code under continual development and the examples in the notebooks provided with the code only touch upon the extent of its capabilities. Read the Next Steps page to find out how to learn more about underworld3, how to get in touch with the development team, and how to become part of the underworld community.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Underworld3 Quick Start Guide",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nThe Underworld codes represent more than two decades of programming effort by many developers including a wide community of contributors from the open-source community.\nAs a community-driven development team, we first acknowledge many contributions made through pull-requests to our repositories and direct submission of codes and examples. The underworldcode organisation on GitHub records all such contributions to the software and the underworld community on GitHub tracks the exchange of information and models.\nDirect funding support has been provided by:\n\nAuScope provides direct support for the core development team behind the underworld codes and the underworld cloud suite of tools. AuScope is funded by the Australian Government through the National Collaborative Research Infrastructure Strategy, NCRIS.\nThe development and testing of our codes is also supported by computational resources provided by the Australian Government through the National Computing Infrastructure (NCI) under the National Computational Merit Allocation Scheme.\nThe Australian Research Council (ARC) supported the development of novel algorithms, computational methods and applications under the Discovery Project and Linkage Project programs. AuScope funding was used to make these methods widely and freely available in the underworld codes. Direct support for Underworld was provided by ARC Industrial Transformation Research Hub Program (The Basin Genesis Hub)\n\nIn-kind support has also come from the institution that host Underworld developers including: the Australian National University, Monash University, The University of Melbourne, The University of Sydney and the CSIRO.\nUnderworld3 relies extensively upon the PETSc, sympy, numpy and cython packages and the jupyter notebook system. We acknowledge the enormous development effort required to build and maintain essential community infrastructure of this calibre and we extend our thanks to include the building blocks of each of these components that are too numerous to acknowledge individually.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#licensing-and-re-use",
    "href": "index.html#licensing-and-re-use",
    "title": "Underworld3 Quick Start Guide",
    "section": "Licensing and re-use",
    "text": "Licensing and re-use\nAll of our software is released under open source licence and all documentation and worked examples are released with a creative commons licence. We are passionate about having our software used and code reuse is strongly encouraged in the interest of scientific reproducibility and replicability. The developers are active researchers and scientists whose livelihood depends on their creative talents and the acknowledgement of their work. Please respect the effort that goes into developing software and tutorials by citing our work and collaborating on publication with new applications of our software when you can.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "Underworld3 Quick Start Guide",
    "section": "Background",
    "text": "Background\n\n\nBalay, S., S. Abhyankar, M. Adams, S. Benson, J. Brown, P. Brune, K.\nBuschelman, et al. 2024. “PETSc/TAO Users\nManual V.3.21.” ANL–21/39-Rev-3.21, 2337606, 188499. https://doi.org/10.2172/2337606.\n\n\nBehnel, Stefan, Robert Bradshaw, Craig Citro, Lisandro Dalcin, Dag\nSverre Seljebotn, and Kurt Smith. 2011. “Cython: The\nBest of Both Worlds.” Computing in Science &\nEngineering 13 (2): 31–39. https://doi.org/10.1109/mcse.2010.118.\n\n\nBeucher, Romain, Louis Moresi, Julian Giordani, John Mansour, Dan\nSandiford, Rebecca Farrington, Luke Mondy, et al. 2019.\n“UWGeodynamics: A Teaching and Research\nTool for Numerical Geodynamic Modelling.” Journal of Open\nSource Software, April. https://doi.org/10.21105/joss.01136.\n\n\nDalcin, Lisandro D., Rodrigo R. Paz, Pablo A. Kler, and Alejandro\nCosimo. 2011. “Parallel Distributed Computing Using\nPython.” Advances in Water Resources 34\n(9): 1124–39. https://doi.org/10.1016/j.advwatres.2011.04.013.\n\n\nGranger, Brian E., and Fernando Perez. 2021. “Jupyter:\nThinking and Storytelling With Code and\nData.” Computing in Science &\nEngineering 23 (2): 7–14. https://doi.org/10.1109/MCSE.2021.3059263.\n\n\nKnepley, Matthew G., Jed Brown, Karl Rupp, and Barry F. Smith. 2013.\n“Achieving High Performance with Unified\nResidual Evaluation.” arXiv:1309.1204 [Cs],\nSeptember. https://arxiv.org/abs/1309.1204.\n\n\nMansour, John, Julian Giordani, Louis Moresi, Romain Beucher, Owen\nKaluza, Mirko Velic, Rebecca Farrington, Steve Quenette, and Adam Beall.\n2020. “Underworld2: Python Geodynamics Modelling for\nDesktop, HPC and Cloud.”\nJournal of Open Source Software 5 (47): 1797. https://doi.org/10.21105/joss.01797.\n\n\nMeurer, Aaron, Christopher P. Smith, Mateusz Paprocki, Ondřej Čertík,\nSergey B. Kirpichev, Matthew Rocklin, AmiT Kumar, et al. 2017.\n“SymPy: Symbolic Computing in\nPython.” PeerJ Computer Science 3\n(January): e103. https://doi.org/10.7717/peerj-cs.103.\n\n\nMoresi, L., F. Dufour, and H.-B. Mühlhaus. 2003. “A\nLagrangian Integration Point Finite Element Method for\nLarge Deformation Modeling of Viscoelastic Geomaterials.”\nJournal of Computational Physics 184 (2): 476–97. https://doi.org/10.1016/S0021-9991(02)00031-1.\n\n\nMoresi, L., S. Quenette, V. Lemiale, C. Mériaux, B. Appelbe, and H. -B.\nMühlhaus. 2007. “Computational Approaches to Studying Non-Linear\nDynamics of the Crust and Mantle.” Physics of the Earth and\nPlanetary Interiors, Computational Challenges in the\nEarth Sciences, 163 (1): 69–82. https://doi.org/10.1016/j.pepi.2007.06.009.\n\n\nZhong, S. J., D. A. Yuen, L. N. Moresi, and M. G. Knepley. 2015.\n“7.05 - Numerical Methods for Mantle\nConvection.” In Treatise on Geophysics\n(Second Edition), edited by Gerald Schubert, 197–222.\nOxford: Elsevier. https://doi.org/10.1016/B978-0-444-53802-4.00130-5.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "NextSteps.html",
    "href": "NextSteps.html",
    "title": "Next Steps",
    "section": "",
    "text": "Underworld Documentation and Examples\nIn addition to the notebooks in this brief set of examples, there are a number of sources of information on using Underworld3 that you can access:\n\nThe Underworld Website / Blog\nThe API documentation (all the modules and functions and their full sets of arguments) is automatically generated from the source code and uses the same rich markdown content as the notebook help text.\nThe API documentation (development branch)\nThe underworld3 GitHub repository is the most active development community for the code.\n\n\n\nBenchmarks\nThe Underworld3 Benchmarks Repository is a useful place to find community benchmarks coded in underworld3 along with accuracy and convergence analysis. This is an open repository where you can make a pull request with new benchmark submissions once you get the hang of things.\n\n\nThe Underworld Community\nThe Underworld Community organisation on Github is a collection of contributed repositories from the underworld user community for all versions of the code and now includes scripts for underworld3.\n\n\nParallel Execution\nUnderworld3 is inherently parallel and designed for high performance computing. The symbolic layer is a relatively thin veneer that sits on top of the PETSc machinery. A script that has been developed in jupyter should be transferrable to an HPC environment with no changes (except that inherently serial operations such as visualisation and model reduction are best left to postprocessing / co-processing).\nWe recommend installing jupytext which allows either a seamless two-way conversion (or pairing) between the ipynb format and an annotated python script, or the ability to work entirely with annoted python scripts and not use ipynb at all. The python form does not store the output of notebook cells but there are advantages to this when scripts are under version control.\nAlmost all of our notebook examples are annotated python for this reason.An exception is the collection of notebooks in this quick-start guide because we want to show you the rendered output in the static web pages.\n    mpirun -np 1024 python3 Modelling_Script.py -uw_resolution 96\nThe main difference between the notebook development environment and HPC is the lack of interactivity, particularly in sending parameters to the script at launch time. Typically, we expect the HPC version to be running at much higher resolution, or for many more timesteps than the development notebook. We use the PETSc command line parsing machinery to generate notebooks that also can ingest run-time parameters from a script (as above).\n\nParallel scaling / performance\nRunning geodynamic models on a single CPU/processor (i.e. serial) is time-consuming and limits us to low resolution. Underworld is build from the ground-up as a parallel computing solution which means we can easily run large models on high performance computing clusters (HPC); that is, sub-divide the problem into many smaller chunks and use multiple processors to solve each one, taking care to combine and synchronise the answers from each processor to obtain the correct solution to the original problem.\nParallel computation can reduce time we need to wait for the our results to be computed but it does happen at the expense of some overhead The overhead does depend on the nature of the computer we are using but typically we need to think about:\n\nCode complexity: any time we manage computations across different processors, we have additional coding to reassemble the calculations correctly and we need to think about many special cases. For example, integrating a quantity of the surface of a mesh: many processes contribute, some do not, the results have to be computed independently then combined.\nAdditional memory is often required: to manage copies of information that lives on / near boundaries, to store the topology of the decomposed domain and to help navigate the passing of information between processes.\nThe time taken to synchronise results and the work required to keep track of who is doing what, when they are done, and in making sure everyone waits for everyone else. There is a time-cost in actually sending information as part of a synchronisation and a computational cost in ensuring that work is distributed efficiently.\n\nTo determine the efficiency of parallel computation, we introduce the strong scaling test which measures the time taken to solve a problem in parallel compared to the same problem solved in serial. In strong scaling tests, the size of the problem is kept constant, while the number of processors is increased. The reduction in run-time due to the addition of more processors is commonly expressed in terms of the speed-up:\n\\[\n\\textrm{speed up} = \\frac{t(N_{ref})}{t(N)}\n\\]\nwhere \\(t(N_{ref})\\) is the run-time for a reference number of processors, \\(N_{ref}\\), and \\(t(N)\\) is the run-time when \\(N\\) processors are used. In the ideal case, \\(N\\) additional processors should contribute all of its resources in solving the problem and reduce the compute time by a factor of \\(N\\) relative to the reference run time. For example, using \\(2 N_{ref}\\) processors will ideally halve the run-time resulting to a speed-up = 2.\n\n\n\n\n\n\nFigure 2.1: Strong parallel-scaling tests run on Australia’s peak computing system, GADI, at the National Computational Infrastructure. This is a typical High Performance Computing facility with large numbers of dedicated, identical CPUs and fast communication links.\n\n\n\n\n\n\nAdvanced capabilities\nDigging a bit deeper into underworld3, there are many capabilities that require a clear understanding of the concepts that underlie the implementation. The following examples are not plug-and-play, but they do only require python coding using the underworld3 API and no detailed knowledge of petsc4py or PETSc. Get in touch with us if you want to try this sort of thing but can’t figure it out for yourself.\n\nDeforming meshes\nIn Example 8, we made small variations to the mesh to conform to basal topography. We did not remesh, so we had to be careful to apply a smooth, analytic displacement to every node. For more general free-surface models, we need to calculate a smooth function using the computed boundary motions (e.g, solving a poisson equation with known boundary displacements as boundary conditions). We need to step through time and it is common to stabilize the surface motions through a surface integral term that accounts for the interface displacement during the timestep. The example below shows an underworld3 forward model with internal loads timestepped close to isostatic equilibrium.\n\n\n\nStokes flow driven by buoyancy in an annulus defined by two embedded surfaces within an enveloping disk mesh. The surfaces deform in response to the flow. The embedding medium has a very low viscosity but still acts to damp rotational modes. The outer boundary of the disk can be set to a far-field gravitational potential for whole-Earth relaxation models\n\n\nIn a more general case, we need to account to horizontal motions. This is more complicated because the horizontal velocities can be large even when vertical equilibrium is achieved. So we need to solve for the advected component of vertical motion in addition to the local component. Hooray for symbolic algebra !\n\n\nWeak / penalty boundary conditions\nExample 8 introduced the idea of penalty-based boundary conditions where the constraint is weakly enforced by providing a large penalty for violation of the condition. This is very flexible as the penalizing conditions can be adjusted during the run, including changing which part of the boundary is subject to constraints based on the solution or a coupled problem. The channel flow model shown below has a boundary condition that depends on a externally sourced model for ponded material at the base that is derived from a simple topography filling algorithm.\n\n\n\n\nLive Image: Stokes flow in a channel with multiple obstructions. Flow is driven from the inlet (a velocity boundary condition). The geometry was contructed with gmsh. This is an example for education which demonstrates the emergence of an large-scale pressure gradient as a result of the presence of the obstructions, and also the dispersion of tracers through the complicated flow geometry\nThe penalty approach does allow the solution to deviate from the exact value of the boundary condition, in a similar way to the iterative solvers delivering a solution to within a specified tolerance. There are some cases, for example, enforcing plate motions at the surface, where there are uncertainties in the applied boundary conditions and that these uncertainties may vary in space and time.\n\n\nMesh Adaptation\nIt is also possible to use the PETSc mesh adaption capabilities, to refine the resolution of a model where it is most needed and coarsen elsewhere. Dynamically-adapting meshes are possible but the interface is very low level at present, particularly in parallel.\n\n\n\n\nLive Image: Static mesh adaptation to the slope of a field. The driving buoyancy term is a plume-like upwelling and the slope of this field is shown in colour (red high, blue low). Don’t forget to zoom in !\n\n    # t is the driving \"temperature\". We form an isotropic refinement metric from its slope\n\n    refinement_fn = 1.0 + sympy.sqrt(\n          t.diff(x) ** 2\n        + t.diff(y) ** 2\n        + t.diff(z) ** 2\n    )\n\n    icoord, meshA = adaptivity.mesh_adapt_meshVar(mesh0, refinement_fn, Metric, redistribute=True)",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Next Steps</span>"
    ]
  },
  {
    "objectID": "Installation.html",
    "href": "Installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "Source code build using mamba\nWe recommend that you use a conda / mamba virtual environment to build underworld3 whenever you want to install on a personal workstation or laptop (linux or macOS).The mamba documentation will help you get started if you are not familiar with the philososphy and practice of this package management system.\nThe underworld3 build / run-time dependencies can be installed using",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#source-code-build-using-mamba",
    "href": "Installation.html#source-code-build-using-mamba",
    "title": "Installation Guide",
    "section": "",
    "text": "(base) % git clone -b development --single-branch https://github.com/underworldcode/underworld3 /path/to/underworld3\n    (base) % cd /path/to/underworld3\n    (base) % mamba env create -n uw3 -f environment.yml\n    (base) % mamba activate uw3\n\n    (uw3) % compile.sh",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#source-code-build-using-mamba-and-existing-petsc",
    "href": "Installation.html#source-code-build-using-mamba-and-existing-petsc",
    "title": "Installation Guide",
    "section": "Source code build using mamba and existing PETSc",
    "text": "Source code build using mamba and existing PETSc\nIf you have an exisiting build of PETSc that you need to use, the following instructions work well. We create the environment as before but remove the pre- installed PETSc and petsc4py.\n    (base) % git clone -b development --single-branch https://github.com/underworldcode/underworld3 /path/to/underworld3\n    (base) % cd /path/to/underworld3\n    (base) % mamba env create -n uw3p -f environment.yml\n    (base) % mamba activate uw3p\n\n    (uw3p) % mamba remove petsc4py\n    (uw3p) % mamba remove petsc\nNext set up PETSc as you like it and build it using the tools within the current mamba virtual environment. Set the PETSC_ARCH environment variable to the name of this virtual environment to keep things from becoming muddled. See PETSc Installation for details on how to configure and build what you need.\n\n    (uw3p) % export PETSC_DIR=/path/to/petsc\n    (uw3p) % export PETSC_ARCH=\"uw3p\"\n    (uw3p) % git clone -b release https://gitlab.com/petsc/petsc.git $PETSC_DIR\n    (uw3p) % cd $PETSC_DIR\n    (uw3p) % # Configure & Build step\nNext we pip install the petsc4py that we just built into the mamba virtual environment. This ensures that petsc4py is available and also that its internal configuration points to the PETSc installation we just created. This way we don’t need to manage environment variables to point to the build that corresponds to a given virtual environment.\n    (uw3p) % mamba install cmake\n    (uw3p) % cd $PETSC_DIR/src/binding/petsc4py\n    (uw3p) % pip install .\nBuilding underworld3 against this version of PETSc should be identical to the mamba version.\n    (uw3p) % cd /path/to/underworld3\n    (uw3p) % compile.sh\n\nDid it work ?\nFirst run the tests:\n    (uw3p) % cd /path/to/underworld3\n    (uw3p) % source test.sh\nIf you have problems, contact us via the underworl3 GitHub issue tracker\n\n\nTo uninstall underworld3\n  (uw3) % pip uninstall underworld3\nAnd to clean the source directory if applicable\n  (uw3) % cd /path/to/underworld3\n  (uw3) % ./clean.sh",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#docker-container",
    "href": "Installation.html#docker-container",
    "title": "Installation Guide",
    "section": "Docker container",
    "text": "Docker container\nWindows users, if you don’t want to create a linux partition, you can use our containers with docker or podman. As the code is still in active development, we are not always able to provide containers for each change to the development branch. We ask that you reach out to us on our GitHub issue tracker to ask for information (use the “question” label).",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Installation.html#hpc-builds",
    "href": "Installation.html#hpc-builds",
    "title": "Installation Guide",
    "section": "HPC builds",
    "text": "HPC builds\nUnderworld3 is inherently parallel and designed for use in high performance computing environments. The symbolic layer is relatively lightweight and should not adversely affect launch time (drawing down libraries from disk) or execution time (very few calculations are done in python itself).\nIn the HPC environment you may find it difficult to control the software stack. You will need to ensure that you can build against PETSc 3.21 or higher, since important functionality that we need is only available from that release onwards. We are happy to provide assistance with builds on specific machines and ask that you contact us through the GitHub issue tracker so that other people are able to browse the issues and their fixes.",
    "crumbs": [
      "About UW3",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Installation Guide</span>"
    ]
  },
  {
    "objectID": "Notebooks/Notebook_Index.html",
    "href": "Notebooks/Notebook_Index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Underworld is designed to be run in the jupyter notebook environment where you can take advantage of jupyter’s rich display capabilities to explore the mathematics of your problem, visualise results and query classes or live objects.\nYou will find it helpful for developing scripts and analysing results. If you use jupytext to write notebooks directly as python scripts, then the same notebook codes will run on a parallel machine with no performance penalty.\nThe notebooks are rendered as html pages in this guide. They are distributed with the source code on GitHub and can be run on binder.\n\n\nNotebook 1 - Meshes\nMeshes: Introduces the mesh discretisation that we use in Underworld3 and how you can build one of the pre-defined meshes. This notebook also show you how to use the pyvista visualisation tools for Underworld3 objects. The mesh holds information on the mesh geometry, boundaries and coordinate systems.\n\n\nNotebook 2 - Mesh Variables\nVariables: Introduces the concept of MeshVariables in Underworld3. These are both data containers and sympy symbolic objects. We show you how to inspect a meshVariable, set the data values in the MeshVariable and visualise them.\n\n\nNotebook 3 - Symbols and sympy\nSymbols: meshVariables are sympy objects that can be composed with other symbolic objects and evaluated numerically when required. They can also be differentiated. Most importantly, sympy can manipulate expressions, simplify them and cancel terms.\n\n\nNotebook 4 - Example: Diffusion Equation\nDiffusion Solver: Introduces the various solver templates that are available in Underworld, starting with a steady-state diffusion problem. The template requires you to set some constitutive properties and define the unknowns. These are handled through subsitution into symbolic forms and the template equation can be inspected before you need to supply concrete expressions.\n\n\nNotebook 5 - Example: Stokes Equation\nStokes Solver: Stokes equation is a more complicated system of equations to solve. This complexity is mostly hidden when you set the problem up. There are some interesting ways to constrain boundary values which are demonstrated using an annulus mesh (curved, free-slip boundaries) and a \\(\\delta\\) function buoyancy source.\n\n\nNotebook 6 - Example: Time Dependence\nTimestepping: Coupled Stokes flow plus thermal advection-diffusion gives a simple convection solver. The timestepping loop is written by hand because usually you will want to do some analysis or output some checkpoints.\n\n\nNotebook 7 - Example: Navier-Stokes Equation\nUnsteady flow Using a passive swarm to track the pattern of flow developing in a pipe after an impulsive application of a boundary condition at the inflow. Particles need to be added to the passive swarm close to the inflow at each timestep.\n\n\nNotebook 8 - Lagrangian Swarm Variables\nSwarm Variables - exploring how they work for specifying material properties with a swarm used to determine element viscosity. We learn how to use swarm variables in expressions generally and for boundary conditions.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorials</span>"
    ]
  },
  {
    "objectID": "Notebooks/1-Meshes.html",
    "href": "Notebooks/1-Meshes.html",
    "title": "Notebook 1: Meshes",
    "section": "",
    "text": "This notebookIntroduces the mesh discretisation that we use in Underworld3 and how you can build one of the pre-defined meshes. This notebook also show you how to use the pyvista visualisation tools for Underworld3 objects. The mesh holds information on the mesh geometry, boundaries and coordinate systems and you can attach data to the mesh (see Notebook 2: Variables).\n\nimport underworld3 as uw\nimport numpy as np\nimport sympy\n\n\nUnderworld meshing module\nUnderworld can read mesh definition files from the gmsh package but there are some constraints on how to specify boundaries if those meshes are to be used to solve numerical problems.\nThe underworld.meshing module has a collection of gmsh (python) examples for common, simple meshes.\n\nmesh = uw.meshing.uw.meshing.CubedSphere(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    numElements=8,\n    refinement=0,\n    simplex=True,\n    verbose=True,\n)\n\nConstructing UW mesh from gmsh .meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexTrue.msh\nMesh refinement levels: 0\nMesh coarsening levels: None\nPopulating mesh coordinates CoordinateSystemType.SPHERICAL\n\n\n\n\nMesh coordinate arrays\nIf you need to check the physical coordinates of the mesh, there is a data array\n    mesh.data\nwhich is a read-only numpy view of the coordinates (on the local segment of the mesh when running in parallel)\n\nmesh.data\n\narray([[ 0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027,  0.57735027, -0.57735027],\n       [-0.57735027, -0.57735027, -0.57735027],\n       ...,\n       [ 0.61340251,  0.4866531 ,  0.41538064],\n       [ 0.56556024,  0.42209717,  0.44274422],\n       [ 0.51755571,  0.41031492,  0.44421012]])\n\n\nThere are other pre-built meshes you can try. This is a cuboid divided into regular tetrahedra:\nmesh_usb = uw.meshing.UnstructuredSimplexBox(\n    minCoords = (-1.0, -1.0, -1.0),\n    maxCoords = (+1.0, +1.0, +1.0),\n    cellSize = 0.2,\n    regular=True,\n    verbose=False,\n)\nand this is a two-dimensional annulus mesh\nmesh_ann = uw.meshing.Annulus(\n    radiusOuter=1.0,\n    radiusInner=0.547,\n    cellSize= 0.5,\n    cellSizeOuter=0.033,\n    cellSizeInner=0.05,\n    verbose=False,\n)\nThe meshing infrastructure for underworld3 is documented here: https://underworldcode.github.io/underworld3/main_api/underworld3/meshing.html\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\n# Try out each one !\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"z\"] = vis.scalar_fn_to_pv_points(pvmesh, mesh.CoordinateSystem.X[2])\npvmesh1 = pvmesh.copy()\n\nif mesh.dim==3:\n    pvmesh_c = pvmesh.clip( normal='z', crinkle=True, inplace=False, origin=(0.0,0.0,0.01))\n\npl = pv.Plotter(window_size=(750, 750))\npl.add_mesh(pvmesh_c, show_edges=True, show_scalar_bar=False, opacity=1.0)\npl.add_mesh(pvmesh1, show_edges=True, show_scalar_bar=False, opacity=0.3)\n\n\n# Save and show the mesh\npl.export_html(\"html5/spherical_mesh_plot.html\") \n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/spherical_mesh_plot.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Spherical shell mesh cut in half and overlain with transparent view of the whole mesh. Cubed sphere discretisation using hexahedral elements\n\n\n\n\nCoordinate systems\nThe mesh has an associated “natural” coordinate system (usually Cartesian), but it may also have other, more convenient, coordinate systems.\nFor example, the spherical mesh above has a Cartesian coordinate system which is the one used to navigate the mesh and describe the location of each point. It also has a spherical \\((r, \\theta, \\phi)\\) system which is symbolic and can be expanded in terms of the Cartesian coordinates.\n\n## The coordinate system\n\nX = mesh.CoordinateSystem.X\nR = mesh.CoordinateSystem.R\n\ndisplay(X)\ndisplay(R)\ndisplay(uw.function.expression.unwrap(R))\n\n\\(\\displaystyle \\left[\\begin{matrix}\\mathrm{x} & \\mathrm{y} & \\mathrm{z}\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}r & \\theta & \\phi\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}} & \\operatorname{acos}{\\left(\\frac{\\mathrm{z}}{\\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2} + \\mathrm{z}^{2}}} \\right)} & \\operatorname{atan}_{2}{\\left(\\mathrm{y},\\mathrm{x} \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nMesh information\nmesh.view() allows you to interrogate the mesh to identify the mesh data structures (which means you can find by name any variable that is automatically constructed by, for example, one of the numerical solvers).\nIt also identifies boundaries of the mesh and their sizes when distributed in parallel. There is a PETSc equivalent which is also called and this contains low-level information on the mesh topology.\n\nmesh.view(1)\n\n\n\nMesh # 0: .meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexTrue.msh\n\n\n\n\n\n\nNumber of cells: 7615\n\nNo variables are defined on the mesh\n\n| Boundary Name            | ID    | Min Size | Max Size |\n| ------------------------------------------------------ |\n| Lower                    | 1     | 1062     | 1062     |\n| Upper                    | 2     | 1062     | 1062     |\n| Null_Boundary            | 666   | 1672     | 1672     |\n| All_Boundaries           | 1001  | 1536     | 1536     |\n| All_Boundaries           | 1001  | 1536     | 1536     |\n| UW_Boundaries            | --    | 5332     | 5332     |\n| ------------------------------------------------------ |\n\n\nDM Object: uw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexTrue.msh 1 MPI process\n  type: plex\nuw_.meshes/uw_cubed_spherical_shell_ro1.0_ri0.547_elts8_plexTrue.msh in 3 dimensions:\n  Number of 0-cells per rank: 1672\n  Number of 1-cells per rank: 10053\n  Number of 2-cells per rank: 15998\n  Number of 3-cells per rank: 7615\nLabels:\n  depth: 4 strata with value/size (0 (1672), 1 (10053), 2 (15998), 3 (7615))\n  All_Boundaries: 1 strata with value/size (1001 (1536))\n  Elements: 1 strata with value/size (99999 (7871))\n  Lower: 1 strata with value/size (1 (1062))\n  Upper: 1 strata with value/size (2 (1062))\n  celltype: 4 strata with value/size (0 (1672), 1 (10053), 3 (15998), 6 (7615))\n  Null_Boundary: 1 strata with value/size (666 (1672))\n  UW_Boundaries: 4 strata with value/size (1 (1062), 2 (1062), 666 (1672), 1001 (1536))\n\n\n\n\nMesh deformation\nYou can adjust the coordinates using:\n    mesh.deform(local_coordinate_array)\nThis rebuilds all the finite element gadgets that live on the mesh but it will not do any remeshing of the points. It is useful for small deformation such as following a free surface but not large-deformation adaptive meshing.\nSee Notebook 8 for a short mesh-deformation example.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Notebook 1: Meshes</span>"
    ]
  },
  {
    "objectID": "Notebooks/2-Variables.html",
    "href": "Notebooks/2-Variables.html",
    "title": "Notebook 2: Variables",
    "section": "",
    "text": "More information\nWe can add discrete “variables” (unknowns associated with the mesh points) to a mesh, assign values to them and build expressions that sympy can understand, manipulate and simplify.\nThis notebook introduces the concept of MeshVariables in Underworld3. These are both data containers and sympy symbolic objects. We show you how to inspect a meshVariable, set the data values in the MeshVariable and visualise them, and build expressions that sympy can understand, manipulate and simplify.\nThis example shows how we can add a scalar field with a single value associated with each mesh node, and a vector field which has quadratic interpolation (points at the nodes plus interpolating points along mesh edges).\nTo set values of the variable, we first have to unlock it using the access context manager, and then we can evaluate a function at the coordinates appropriate to fill up each variable. The locking is a PETSc requirement which is used to make sure data remains synchronised when we run code in parallel.\nVariables are like most underworld and PETSc objects - they can be examined using their view() method. The information that you will see is split into the underworld representation (listed under MeshVariable) and the PETSc representation (listed under FE Data which also includes the numerical values).\nThe meshVariable code is described API docs here.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Notebook 2: Variables</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html",
    "href": "Notebooks/3-Symbolic_Forms.html",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Symbolic forms, derivatives\nUnderworld is deeply integrated with sympy (www.sympy.org) so that any mesh variable can also be used in a sympy expression. We already saw sympy expressions for the coordinates and coordinate directions.\nmeshVariables can be composed with other symbolic objects and evaluated numerically when required. They can also be differentiated. Most importantly, sympy can manipulate expressions, simplify them and cancel terms.\nIn the examples below, we use a simple 2D, Cartesian mesh because it is much simpler to see the various changes.\nAs before, we add discrete variables\nVariables can be part of complicated sympy expressions. It is important to note that all symbols are matrices and sympy can be fussy when it comes to operations with other matrices (scalars are not entirely equivalent to \\(1 \\times 1\\) matrices).\ns.sym[0]+t.sym[0] + v.sym[0]\n\n\\(\\displaystyle { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{T}} }(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0 }(\\mathbf{x})\\)\nDerivatives can be handled explicitly, but the mesh also provides vector operators and these are generally better because they are automatically consistent with the underlying coordinate system for the mesh.\nFor compound expressions of variables, use mesh.vector.curl(expression) but for individual variables, variable.curl() is an equivalent shorthand.\n# grad by hand\ns.sym[0].diff(x) + s.sym[0].diff(y)\n\n\\(\\displaystyle { \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x})\\)\n# grad\ns.gradient()\n\n\\(\\displaystyle \\left[\\begin{matrix}{ \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) & { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x})\\end{matrix}\\right]\\)\nv.curl()\n\n\\(\\displaystyle - { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0,1}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1,0}(\\mathbf{x})\\)\n# curl\nmesh.vector.curl(s.sym * v.sym)\n\n\\(\\displaystyle - { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0,1}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1,0}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1 }(\\mathbf{x}) - { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0 }(\\mathbf{x})\\)\n# v dot grad (scalar)... \nv.sym.dot(mesh.vector.gradient(s.sym))\n\n\\(\\displaystyle { \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0 }(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1 }(\\mathbf{x})\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "href": "Notebooks/3-Symbolic_Forms.html#symbolic-forms-derivatives",
    "title": "Notebook 3: Symbolic forms",
    "section": "",
    "text": "Underworld Expressions\nWe often want to define symbols that represent complicated expressions which do not want to expand when we probe the mathematical formulation.\nAn example might be a constitutive model that has a number of conditional expressions, or a concept such as a timestep which we want to refer to as \\(\\delta t\\) regardless of its current numerical value.\nUnderworld expressions are objects that have a sympy symbolic representation that is only expanded at the time numerical evaluations are required. How about the example above in expression form:\n    curl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    f\"Curl of {v.symbol}\"\n                ) \ncreates an expression object which displays as \\(\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\\) but which also has curl_sv.sym which is the full expression.\nNote: like MeshVariables expressions have unique names and are persistent objects. They are containers for expressions (in the way MeshVariables are containers for numerical information. This means that we can write an expression and change what it represents while it remains part of another expression.\n\ncurl_sv = uw.function.expression(\n                    r\"\\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\",\n                    mesh.vector.curl(s.sym * v.sym),\n                    r\"Curl of S * V ...\"\n                ) \n\ncurl_sv.view()\ndisplay(curl_sv.sym) \n\ncurl_sv + 1\n\nClass: &lt;class ‘underworld3.function.expressions.UWexpression’&gt;\n\n\n\\(\\quad\\)\\(\\displaystyle \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right)\\)\\(=\\)\\(\\displaystyle - { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0,1}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1,0}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1 }(\\mathbf{x}) - { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\quad\\)Description: Curl of S * V …\n\n\n\\(\\displaystyle - { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0,1}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1,0}(\\mathbf{x}) + { \\hspace{ 0.02pt } {\\cal{S}} }_{,0}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 1 }(\\mathbf{x}) - { \\hspace{ 0.02pt } {\\cal{S}} }_{,1}(\\mathbf{x}) { \\hspace{ 0.02pt } {\\mathbf{v}} }_{ 0 }(\\mathbf{x})\\)\n\n\n\\(\\displaystyle \\nabla \\times \\left(\\cal{S} \\mathbf{v}\\right) + 1\\)\n\n\n\n# If you run the cell above multiple times, the object id should not change\nid(curl_sv)\n\n13682572176\n\n\n\n\nUnderworld Sub-expressions\nThe viscosity for a material with a yield stress might look like this:\n\\[\n\\eta_\\textrm{eff} = \\displaystyle \\min\\left({  {\\eta_0} }, \\frac{\\max\\left({ {\\tau_{y}} }, {  {\\tau_{y, \\mathrm{min}}} }\\right)}{2 {  \\dot\\varepsilon_{II} }}\\right)\n\\]\nwhere \\(\\tau_y\\) is a scalar yield stress, and \\(\\dot\\varepsilon_{II}\\) is the second invariant of the strain-rate tensor. Each of these would be a nested Underworld expression.\nTo expand the expression and see inside, we can use\n    expression.unwrap(keep_constants=True)\nwhich reaches down the hierarchy and recursively replaces any expression with its expanded sympy representation. If a symbol represents a constant value (float, int, or sympy number), then it is only replaced if keep_constants is set to False.\n\nviscosity = uw.function.expression(\n                    r\"\\eta_0\",\n                    sympy.sympify(1),\n                    rf\"viscosity\"\n                ) \n\ntau_yield = uw.function.expression(\n                    r\"\\tau_y\",\n                    sympy.sympify(10),\n                    rf\"yield stress\"\n                ) \n\nedot_II = uw.function.expression(\n                    r\"\\dot{\\varepsilon}_{II}\",\n                    sympy.Symbol('epsilon'),\n                    rf\"strain rate invariant\"\n                ) \n\n\nviscosity_eff = uw.function.expression(\n                    r\"\\eta_\\mathrm{eff}\",\n                    sympy.Min(viscosity, tau_yield / (2 * edot_II)),\n                    rf\"Curl of {v.symbol}\"\n                )\n\n\nviscosity_eff.sym\n\n\\(\\displaystyle \\min\\left(\\eta_{0}, \\frac{\\tau_{y}}{2 \\dot{\\varepsilon}_{II}}\\right)\\)\n\n\n\nviscosity_eff.unwrap(keep_constants=True)\n\n\\(\\displaystyle \\min\\left(\\eta_{0}, \\frac{\\tau_{y}}{2 \\epsilon}\\right)\\)\n\n\n\nviscosity_eff.unwrap(keep_constants=False)\n\n\\(\\displaystyle \\min\\left(1, \\frac{5}{\\epsilon}\\right)\\)\n\n\nSymbolic forms can be evaluated at points in the (meshed domain) using uw.function.evaluate. Pure sympy functions can be used to set values in the data container of a meshVariable object\n\nwith mesh.access(s, t):\n    s.data[:,0] = uw.function.evaluate(sympy.cos(3 * sympy.pi * x)**2 , s.coords)\n    t.data[:,0] = uw.function.evaluate(sympy.sin(3 * sympy.pi * y)**2 , t.coords)\n\n\ns.view()\n\nClass: &lt;class ‘underworld3.discretisation._MeshVariable’&gt;\n\n\nMeshVariable:\n\n\n\nsymbol: \\({ \\hspace{ 0.02pt } {\\cal{S}} }\\)\n\n\nshape: \\((1, 1)\\)\n\n\ndegree: \\(1\\)\n\n\ncontinuous: True\n\n\ntype: SCALAR\n\n\n\nFE Data:\n\n\n\nPETSc field id: \\(0\\)\n\n\nPETSc field name: S\n\n\n\narray([[1.        ],\n       [1.        ],\n       [1.        ],\n       ...,\n       [0.79389263],\n       [0.79389263],\n       [0.79389263]])\n\n\n\n# Visualise it / them\n\nimport pyvista as pv\nimport underworld3.visualisation as vis\n\npvmesh = vis.mesh_to_pv_mesh(mesh)\npvmesh.point_data[\"s\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0])\npvmesh.point_data[\"t\"] = vis.scalar_fn_to_pv_points(pvmesh, t.sym[0])\npvmesh.point_data[\"sxt\"] = vis.scalar_fn_to_pv_points(pvmesh, s.sym[0]*t.sym[0])\n\npvmesh.warp_by_scalar(scalars=\"sxt\", factor=0.3, normal=(0,0,1), inplace=True)\n\n# pvmesh.plot(show_edges=True, show_scalar_bar=False)\n\npl = pv.Plotter(window_size=(750, 750))\n\npl.add_mesh(pvmesh, \n            show_edges=True,\n            edge_color=\"#4455FF\",\n            cmap=\"Greys\",\n            scalars=\"sxt\", \n            show_scalar_bar=False)\n\n# Save and show the mesh\n\npl.camera_position = 'yz'\npl.camera.azimuth = 45\npl.camera.elevation = 45\n\npl.export_html(\"html5/sine_squared.html\")\n\n\nfrom IPython.display import IFrame\nIFrame(src=\"html5/sine_squared.html\", width=600, height=400)\n\n\n        \n        \nInteractive Image: Square mesh of triangular elements on which we evaluated a simple sympy function of position\n\n\n\nLazy evaluation of expressions\nGenerally speaking, we use expressions as placeholders for parameters or functions that we know will be needed when it comes to solve a problem, but we can’t be sure that we can specify them at the time we set up the solver.\nIn the code for our solvers, for example, we set up a template with expressions that describe where the parameters of the problem will be and we expect you to fill the details in when we create a new solver-object. These template expressions are protected so that assignment just changes the value that the expression holds, it does not change the symbol or the description (though you can do this if you want).\nThis is a rather contrived example:\n\nR = uw.function.expression(r\"r\\left( \\mathbf{x} \\right)\",\n                           sympy.sqrt(x**2+y**2), \n                           \"distance from origin\")\n\nR1 = R + 1\n\nS = sympy.sqrt(x**2+y**2)\nS1 = S + 1\n               \n\n\nR2 = R.sym + 1\n\n\nS1\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nR.sym = S = sympy.sqrt((x-1)**2 + (y-1)**2)\n\n\nuw.function.expressions.unwrap(R1) # Lazy evaluation \n\n\\(\\displaystyle \\sqrt{\\left(\\mathrm{x} - 1\\right)^{2} + \\left(\\mathrm{y} - 1\\right)^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(S1)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)\n\n\n\nuw.function.expressions.unwrap(R2)\n\n\\(\\displaystyle \\sqrt{\\mathrm{x}^{2} + \\mathrm{y}^{2}} + 1\\)",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "href": "Notebooks/3-Symbolic_Forms.html#exercise-3.1",
    "title": "Notebook 3: Symbolic forms",
    "section": "Exercise 3.1",
    "text": "Exercise 3.1\nHave a look at the visco-plastic constitutive model (template) for Stokes equation\nstokes_solver = uw.systems.solvers.SNES_Stokes(mesh)\nstokes_solver.constitutive_model = uw.constitutive_models.ViscoPlasticFlowModel\nstokes_solver.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes_solver.constitutive_model.Parameters.yield_stress = 100\nYou can examine this expression in more detail using the view method of the stokes_solver.constitutive_model, and you can expand the expression to see how it reduces when sympy needs to evaluate this expression at one or more locations in the domain.\n\nExercise 3.2\nAssignment to an expression object replaces the sympy value but does not change the rest of the object. This is the concept of lazy evaluation which we introduced earlier.\nValidate this using the constititutive model above. Try changing the yield stress or the shear viscosity and see how the expression for the apparent viscosity changes.\ne.g. \n    stokes_solver.constitutive_model.Parameters.shear_viscosity_0 = sympy.exp(-10 * t.sym[0])\n    display(stokes_solver.constitutive_model.viscosity)\nActually, that won’t look different, will it ? You need to expand out the expressions a bit to see it. Try using stokes_solver.constitutive_model.viscosity.unwrap(). This function makes substitutions of all (underworld) sub-expressions in any sympy expression.\nYou can pass keep_constants=False if you want to expand all the numerical values as well. An expression is considered to be a constant if it contains no sub-expressions, MeshVariables, or mesh-coordinates. We usually do not want to have long floating point numbers all over the place when we check an expression except if it’s the values that we want to check.\nTry it !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Notebook 3: Symbolic forms</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers-i-Poisson.html",
    "href": "Notebooks/4-Solvers-i-Poisson.html",
    "title": "Notebook 4: Poisson Equation",
    "section": "",
    "text": "The Poisson (Diffusion) Solver\nIntroduces the various solver templates that are available in Underworld, starting with a steady-state diffusion problem. The template requires you to set some constitutive properties and define the unknowns. These are handled through subsitution into symbolic forms and the template equation can be inspected before you need to supply concrete expressions.\nIn this example, we solve a steady, non-linear, scalar diffusion equation and show how to recover the fluxes\nThere are a number of pre-defined solver systems defined in underworld3 which are templates for orchestrating the underlying PETSc objects. A solver requires us to define the unknown in the form of meshVariables, provide boundary conditions, a constitutive model, and provide uw.functions to define constitutive properties, and driving terms.\nWe will use the Poisson solver for the diffusion equation, and we will use a Projection solver to compute the vertical gradient term.\nThe Projection solvers compute the meshVariable representation of the right hand side of the equation (potentially requiring some smoothing to regularise the problem). This is required when computing numerical values of gradients, for example, where the values are often not formally defined on the mesh points of the meshVariable. This can also be used to transfer information from discontinous variables to continuous representations when you need to visualise a field.\nThe solver classes themselves (the templates for specific solvers) are separately documented, so we can figure out what is needed before we define anything:\nuw.systems.Poisson.view()\n\nPoisson Equation Solver\nThis class provides functionality for a discrete representation of the Poisson equation\n\\[\n\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\kappa \\nabla u \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ f \\Bigl] }_{\\mathbf{h}}}\n\\]\nThe term \\(\\mathbf{F}\\) relates the flux to gradients in the unknown \\(u\\)\n\nProperties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term\nuw.systems.Projection.view()\n\nProjection Solver\nSolves \\(u = \\tilde{f}\\) where \\(\\tilde{f}\\) is a function that can be evaluated within an element and \\(u\\) is a meshVariable with associated shape functions. Typically, the projection is used to obtain a continuous representation of a function that is not well defined at the mesh nodes. For example, functions of the spatial derivatives of one or more meshVariable (e.g. components of fluxes) can be mapped to continuous variables with a projection. More broadly it is a projection from one basis to another and its limitations should be evaluated within that context.\nThe projection implemented by creating a solver for this problem\n\\[\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\boldsymbol\\alpha \\nabla u \\Bigr]}_{\\mathbf{F}}} -\n        \\color{Maroon}{\\underbrace{\\Bigl[ u - \\tilde{f} \\Bigl] }_{\\mathbf{h}}} = 0\n\\]\nWhere the term \\(\\mathbf{F}\\) provides a smoothing regularization. \\(\\alpha\\) can be zero.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/4-Solvers-i-Poisson.html#properties",
    "href": "Notebooks/4-Solvers-i-Poisson.html#properties",
    "title": "Notebook 4: Poisson Equation",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\)\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(f\\) is a volumetric source term",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notebook 4: Poisson Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/5-Solvers-ii-Stokes.html",
    "href": "Notebooks/5-Solvers-ii-Stokes.html",
    "title": "Notebook 5: Stokes Equation",
    "section": "",
    "text": "Solver setup\nIn this example, we solve the Stokes equation for buoyancy-driven, incompressible flow in a creeping, viscous fluid.\n\\[\n-\\nabla \\cdot\n    \\left[\n            \\boldsymbol{\\tau} -  p \\mathbf{I} \\right] =\n     \\rho \\mathbf{g}\n\\]\n\\[\n\\nabla \\cdot \\mathbf{u} = 0\n\\]\n\\(p\\) is pressure. The constitutive law expresses the deviatoric stress ( \\(\\boldsymbol{\\tau}\\) ) in terms of the velocity (\\(\\mathbf{u}\\)) gradients ( \\(\\nabla \\mathbf{u}\\) ) through a viscosity tensor, \\(\\eta\\). \\(p\\) is pressure.\n\\[\n\\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\\]\nA classical problem in geodynamics, is to solve this equation for harmonic forcing at one specific depth (the Greens function or kernels) for which analytic solutions are available in various geometries (e.g. Parsons & Daly, 1981).\nWe have pre-built meshes in underworld3 that have embedded internal surfaces where we can apply the harmonic forcing. This allows us to compute the flow kernels. We’ll use a cylindrical annulus this time and we’ll use free-slip boundary conditions throughout\nWe can obtain unit vectors in the natural coordinate system (here \\(r\\), \\(\\theta\\)) as mesh.CoordinateSystem.unit_e_0, mesh.CoordinateSystem.unit_e_1. There is a null space if we apply the boundary conditions exactly, and so we define a function to represent the null space.\nWe can set solver options via the petsc_options interface on the solver. PETSc provides an enormous variety of solver configurations and options that can be set. Their Guide to Stokes Equation is an illustration of the complexity of the problem and the difficulty in trying to set up a good one-size-fits-all default configuration, particularly when moving to parallel examples.\n# Create a density structure / buoyancy force\n# gravity will vary linearly from zero at the centre\n# of the sphere to (say) 1 at the surface\n\n\n# Null space in velocity (constant v_theta) expressed in x,y coordinates\nv_theta_fn_xy = r * meshball.CoordinateSystem.rRotN.T * sympy.Matrix((0,1))\n\n# Mesh variables for the unknowns\n\nv_soln = uw.discretisation.MeshVariable(\"V0\", meshball, 2, degree=2, varsymbol=r\"{v_0}\")\np_soln = uw.discretisation.MeshVariable(\"p\", meshball, 1, degree=1, continuous=True)\n\nstokes = uw.systems.Stokes(\n    meshball, \n    velocityField=v_soln, \n    pressureField=p_soln,\n)\n\nstokes.constitutive_model = uw.constitutive_models.ViscousFlowModel\nstokes.constitutive_model.Parameters.shear_viscosity_0 = 1\nstokes.tolerance = 1.0e-6\n\nstokes.petsc_options.setValue(\"ksp_monitor\", None)\nstokes.petsc_options.setValue(\"snes_monitor\", None)\nstokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"\nuw.systems.Stokes.view()\n\nStokes Equation Solver\nThis class provides functionality for a discrete representation of the Stokes flow equations assuming an incompressibility (or near-incompressibility) constraint.\n\\[\n-\\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[\n                \\boldsymbol{\\tau} -  p \\mathbf{I} \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{f} \\Bigl] }_{\\mathbf{h}}}\n\\]\n\\[\n\\underbrace{\\Bigl[ \\nabla \\cdot \\mathbf{u} \\Bigr]}_{\\mathbf{h}_p} = 0\n\\]\nThe flux term is a deviatoric stress ( \\(\\boldsymbol{\\tau}\\) ) related to velocity gradients ( \\(\\nabla \\mathbf{u}\\) ) through a viscosity tensor, \\(\\eta\\), and a volumetric (pressure) part \\(p\\)\n\\[\n    \\mathbf{F}: \\quad \\boldsymbol{\\tau} = \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right)\n\\]\nThe constraint equation, \\(\\mathbf{h}_p = 0\\) gives incompressible flow by default but can be set to any function of the unknown \\(\\mathbf{u}\\) and \\(\\nabla\\cdot\\mathbf{u}\\)\n\nProperties\n\nThe unknowns are velocities \\(\\mathbf{u}\\) and a pressure-like constraint parameter \\(\\mathbf{p}\\)\nThe viscosity tensor, \\(\\boldsymbol{\\eta}\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(\\mathbf f\\) is a volumetric source term (i.e. body forces) and is set by providing the bodyforce property.\nAn Augmented Lagrangian approach to application of the incompressibility constraint is to penalise incompressibility in the Stokes equation by adding $ $ when the weak form of the equations is constructed. (this is in addition to the constraint equation, unlike in the classical penalty method). This is activated by setting the penalty property to a non-zero floating point value which adds the term in the sympy expression.\nA preconditioner is usually required for the saddle point system and this is provided through the saddle_preconditioner property. The default choice is \\(1/\\eta\\) for a scalar viscosity function.\n\n\n\nNotes\n\nFor problems with viscoelastic behaviour, the flux term contains the stress history as well as the stress and this term is a Lagrangian quantity that has to be tracked on a particle swarm.\nThe interpolation order of the pressureField variable is used to determine the integration order of the mixed finite element method and is usually lower than the order of the velocityField variable.\nIt is possible to set discontinuous pressure variables by setting the p_continous option to False\n# The class instance has details of how the general class has been\n# constructed for the particular case (boundary conditions, constitutive models etc)\n# If class_documentation=True is used, then the description above is printed first.\n\nstokes.view(class_documentation=False)\n\nClass: &lt;class ‘underworld3.systems.solvers.SNES_Stokes’&gt;\n\n\nUnderworld / PETSc General Saddle Point Equation Solver\n\n\nPrimary problem:\n\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n$ = 0 $\n\n\nConstraint:\n\n\n$ = 0 $\n\n\nWhere:\n\n\n\\(\\quad\\)\\(\\displaystyle \\uplambda\\)\\(=\\)\\(\\displaystyle 0\\)\n\n\n\\(\\quad\\)\\(\\displaystyle \\eta\\)\\(=\\)\\(\\displaystyle 1\\)\n\n\nBoundary Conditions\n\n\n\n\n\nType\nBoundary\nExpression\n\n\n\n\n\n\n\nThis solver is formulated as a 2 dimensional problem with a 2 dimensional mesh",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Notebook 5: Stokes Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/5-Solvers-ii-Stokes.html#properties",
    "href": "Notebooks/5-Solvers-ii-Stokes.html#properties",
    "title": "Notebook 5: Stokes Equation",
    "section": "Properties",
    "text": "Properties\n\nThe unknowns are velocities \\(\\mathbf{u}\\) and a pressure-like constraint parameter \\(\\mathbf{p}\\)\nThe viscosity tensor, \\(\\boldsymbol{\\eta}\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\n\\(\\mathbf f\\) is a volumetric source term (i.e. body forces) and is set by providing the bodyforce property.\nAn Augmented Lagrangian approach to application of the incompressibility constraint is to penalise incompressibility in the Stokes equation by adding $ $ when the weak form of the equations is constructed. (this is in addition to the constraint equation, unlike in the classical penalty method). This is activated by setting the penalty property to a non-zero floating point value which adds the term in the sympy expression.\nA preconditioner is usually required for the saddle point system and this is provided through the saddle_preconditioner property. The default choice is \\(1/\\eta\\) for a scalar viscosity function.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Notebook 5: Stokes Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/5-Solvers-ii-Stokes.html#notes",
    "href": "Notebooks/5-Solvers-ii-Stokes.html#notes",
    "title": "Notebook 5: Stokes Equation",
    "section": "Notes",
    "text": "Notes\n\nFor problems with viscoelastic behaviour, the flux term contains the stress history as well as the stress and this term is a Lagrangian quantity that has to be tracked on a particle swarm.\nThe interpolation order of the pressureField variable is used to determine the integration order of the mixed finite element method and is usually lower than the order of the velocityField variable.\nIt is possible to set discontinuous pressure variables by setting the p_continous option to False",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Notebook 5: Stokes Equation</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html",
    "href": "Notebooks/6-Timestepping.html",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "",
    "text": "Create linked solvers\nWe’ll look at a convection problem which couples Stokes Flow with time-dependent advection/diffusion to give simple Rayleigh-Bénard convection model.\n\\[\n-\\nabla \\cdot\n    \\left[\n            \\frac{\\eta}{2}\\left( \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right) -  p \\mathbf{I} \\right] =\n     -\\rho_0 \\alpha T \\mathbf{g}\n\\] \\[\n\\nabla \\cdot \\mathbf{u} = 0\n\\]\n\\(\\eta\\) is viscosity, \\(p\\) is pressure, \\(\\rho_0\\) is a reference density, \\(\\alpha\\) is thermal expansivity, and \\(T\\) is the temperature. Here we explicitly express density variations in terms of temperature variations.\nThermal evolution is given by \\[\n\\frac{\\partial T}{\\partial t} - \\mathbf{u}\\cdot\\nabla T = \\kappa \\nabla^2 T\n\\] where the velocity, \\(\\mathbf{u}\\) is the result of the Stokes flow calculation. \\(\\kappa\\) is the thermal diffusivity (compare this with Notebook 4).\nThe starting point is our previous notebook where we solved for Stokes flow in a cylindrical annulus geometry. We then add an advection-diffusion solver to evolve temperature. The Stokes buoyancy force is proportional to the temperature anomaly, and the velocity solution is fed back into the temperature advection term. The timestepping loop is written by hand because usually you will want to do some analysis or output some checkpoints.\nTo read more about the applications of simple mantle convection models like this one, see (for example) Schubert et al, 2001.\nWe create the Stokes solver as we did in the previous notebook. The buoyancy force is proportional to the temperature anomaly (t_soln). Solvers can either be provided with unknowns as pre-defined meshVariables, or they will define their own. When solvers are coupled, explicitly defining unknowns makes everything clearer.\nThe advection-diffusion solver evolved t_soln using the Stokes velocity v_soln in the fluid-transport term.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#properties",
    "href": "Notebooks/6-Timestepping.html#properties",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\).\nThe velocity field is \\(\\mathbf{v}\\) and is provided as a sympy function to allow operations such as time-averaging to be calculated in situ (e.g. V_Field = v_solution.sym) NOTE: no it’s not. Currently it is a MeshVariable this is the desired behaviour though.\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\nVolumetric sources of \\(u\\) are specified using the \\(f\\) property and can be any valid combination of sympy functions of position and meshVariable or swarmVariable types.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#references",
    "href": "Notebooks/6-Timestepping.html#references",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "References",
    "text": "References\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution of advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#properties-1",
    "href": "Notebooks/6-Timestepping.html#properties-1",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\).\nThe velocity field is \\(\\mathbf{v}\\) and is provided as a sympy function to allow operations such as time-averaging to be calculated in situ (e.g. V_Field = v_solution.sym) NOTE: no it’s not. Currently it is a MeshVariable this is the desired behaviour though.\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\nVolumetric sources of \\(u\\) are specified using the \\(f\\) property and can be any valid combination of sympy functions of position and meshVariable or swarmVariable types.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#references-1",
    "href": "Notebooks/6-Timestepping.html#references-1",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "References",
    "text": "References\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution of advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---null-space",
    "href": "Notebooks/6-Timestepping.html#exercise---null-space",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "Exercise - Null space",
    "text": "Exercise - Null space\nBased on our previous notebook, can you see how to calculate and (if necessary) remove rigid-body the rotation null-space from the solution ?\nThe use of a coarse-level singular-value decomposition for the velocity solver should help, in this case, but sometimes you can see that there is a rigid body rotation (look at the streamlines). It’s wise to check and quantify the presence of the null space.\n    stokes.petsc_options[\"fieldsplit_velocity_mg_coarse_pc_type\"] = \"svd\"",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "href": "Notebooks/6-Timestepping.html#exercise---heat-flux",
    "title": "Notebook 6: Rayleigh-Bénard Convection (time-stepping example)",
    "section": "Exercise - Heat flux",
    "text": "Exercise - Heat flux\nCould you calculate the radial heat flux field ? Its surface average value plotted against time tells you if you have reached a steady state.\nHint:\n\\[\n    Q_\\textrm{surf} = \\nabla T \\cdot \\hat{r} + T (\\mathbf{v} \\cdot \\hat{r} )\n\\]\n    Q_surf = -meshball.vector.gradient(t_soln.sym).dot(unit_rvec) +\\\n                    t_soln.sym[0] * v_soln.sym.dot(unit_rvec)\n\nReferences\nSchubert, G., Turcotte, D. L., & Olson, P. (2001). Mantle Convection in the Earth and Planets (1st ed.). Cambridge University Press. https://doi.org/10.1017/CBO9780511612879",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Notebook 6: Rayleigh-Bénard Convection (time-stepping example)</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html",
    "href": "Notebooks/7-Unsteady_Flow.html",
    "title": "Notebook 7: Unsteady Flow",
    "section": "",
    "text": "The Navier-Stokes Solver\nWe’ll look at tracking an unsteady flow using a swarm of particle flow-tracers. In this case, the flow is unsteady because we solve the Navier-Stokes equation (that is, the flow has inertia) and we impose an impulsive, initial boundary velocity.\nTo begin with, the set up follows the same path as all previous notebooks: - Create a mesh - Add some variables - Create the solver we need (NavierStokes this time) - Add boundary conditions and constitutive properties.\nWe also add a projection solver to compute the vorticity of the flow as we did in Notebook 4 when we needed to compute a heat-flux (thermal gradient) term.\nTo track the time evolution of the flow, we introduce a “passive” particle swarm. Passive, here, refers to the fact that the flow is not changed by the presence of the marker particles.\nIn the time-loop we have to update the particle locations and we keep this as an explicity operation, in general, because it provide the opportunity for you to make changes or perform analyses. In this case, we are adding new particles near the inflow to track the flow.\nTo learn more about flow goverened by the Navier-Stokes equation, it may be he helpful to read an elementary fluid dynamics textbook and reproduce some of the simple “toy” examples. For example, Acheson, 1990.\nThe Navier-Stokes solver is a combination of a Stokes solver with time-dependent terms for both the Flux history and velocity history. These are orchestrated behind the scenes but some user-accessible options can be set, and full introspection is available using the view methods.\nThe velocity history terms are implemented using uw.systems.ddt objects (Eulerian, Semi-Lagrangian (default), or Lagrangian). Use navier_stokes.DFDt.view(class_documentation=True) and navier_stokes.DuDt.view(class_documentation=True) for more information.\nThe ddt objects implement the Adams-Moulton schemes for flux-terms (order=1 implemented the well-known Crank-Nicholson scheme). For the velocity history term, backward differentiation formulae are used. Introspection for the NS solver shows how the various terms combine to form the full set of equations.\nuw.systems.NavierStokes.view()\n\nNavier-Stokes Equation Solver\nThis class provides a solver for the Navier-Stokes (vector Advection-Diffusion) equation which is similar to that used in the Semi-Lagrange Crank-Nicholson method (Spiegelman & Katz, 2006) but using a distributed sampling of upstream values taken from an arbitrary swarm variable.\n\\[\n\\color{Green}{\\underbrace{ \\Bigl[ \\frac{\\partial \\mathbf{u} }{\\partial t} +\n                                  \\left( \\mathbf{u} \\cdot \\nabla \\right) \\mathbf{u} \\ \\Bigr]}_{\\dot{\\mathbf{u}}}} -\n    \\nabla \\cdot\n        \\color{Blue}{\\underbrace{\\Bigl[ \\frac{\\boldsymbol{\\eta}}{2} \\left(\n                \\nabla \\mathbf{u} + \\nabla \\mathbf{u}^T \\right) - p \\mathbf{I} \\Bigr]}_{\\mathbf{F}}} =\n        \\color{Maroon}{\\underbrace{\\Bigl[ \\mathbf{f} \\Bigl] }_{\\mathbf{h}}}\n\\]\nThe term \\(\\mathbf{F}\\) relates diffusive fluxes to gradients in the unknown \\(u\\). The advective flux that results from having gradients along the direction of transport (given by the velocity vector field \\(\\mathbf{v}\\) ) are included in the \\(\\dot{\\mathbf{u}}\\) term.\nThe term \\(\\dot{\\mathbf{u}}\\) involves upstream sampling to find the value \\(u^{ * }\\) which represents the value of \\(u\\) at the beginning of the timestep. This is achieved using a swarmVariable that carries history information along the flow path. A dense sampling is required to achieve similar accuracy to the original SLCN approach but it allows the use of a single swarm for history tracking of variables with different interpolation order and for material tracking. The user is required to supply and update the swarmVariable representing \\(u^{ * }\\)\n\nProperties\n\nThe unknown is \\(u\\).\nThe history variable is \\(u^*\\) and is provided in the form of a sympy function. It is the user’s responsibility to keep this variable updated.\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\nVolumetric sources of \\(u\\) are specified using the \\(f\\) property and can be any valid combination of sympy functions of position and meshVariable or swarmVariable types.\n\n\n\nNotes\n\nThe solver requires relatively high order shape functions to accurately interpolate the history terms. Spiegelman & Katz recommend cubic or higher degree for \\(u\\) but this is not checked.\n\n\n\nReferences\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution of advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073\nnavier_stokes.DuDt.view(class_documentation=True)\n\nNodal-Swarm Semi-Lagrangian History Manager:\nThis manages the semi-Lagrangian update of a Mesh Variable, \\(\\psi\\), on the mesh across timesteps. \\[\\quad \\psi_p^{t-n\\Delta t} \\leftarrow \\psi_p^{t-(n-1)\\Delta t}\\quad\\] \\[\\quad \\psi_p^{t-(n-1)\\Delta t} \\leftarrow \\psi_p^{t-(n-2)\\Delta t} \\cdots\\quad\\] \\[\\quad \\psi_p^{t-\\Delta t} \\leftarrow \\psi_p^{t}\\]\n\n\n\n\n\nClass: &lt;class ‘underworld3.systems.ddt.SemiLagrangian’&gt;\n\n\nDetails\n\n\n&lt;IPython.core.display.Latex object&gt;\nvorticity_from_v = uw.systems.Projection(mesh, vorticity)\nvorticity_from_v.uw_function = mesh.vector.curl(v_soln.sym)\nvorticity_from_v.smoothing = 1.0e-3\n# nodal_vorticity_from_v.petsc_options.delValue(\"ksp_monitor\")\npassive_swarm = uw.swarm.Swarm(mesh=mesh)\npassive_swarm.populate(\n    fill_param=0,\n)\n\n# add new points at the inflow\nnew_points = 100\nnew_coords = np.array([0.0, 0.25] + 0.5 * np.random.random((new_points, 2)))\npassive_swarm.add_particles_with_coordinates(new_coords)\n\n100\nnavier_stokes.solve(timestep=0.01)\nvorticity_from_v.solve()\n# Keep the initialisation separate\n# so we can run the loop below again without resetting\n# the timer.\n\nmax_steps = 50\ntimestep = 0\nelapsed_time = 0.0\ndelta_t = 0.05\nfor step in range(0, max_steps):\n\n    # Keep previous guess for solve\n    navier_stokes.solve(zero_init_guess=False, timestep=delta_t)\n    passive_swarm.advection(v_soln.sym, delta_t, order=2, corrector=False)\n\n    # Add new tracer particles near the inlet\n    new_points = 100\n    new_coords = np.array([0.0, 0.25] + 0.5 * np.random.random((new_points, 2)))\n    passive_swarm.add_particles_with_coordinates(new_coords)\n\n    # Save the data at every 10th step\n\n    if timestep % 10 == 0:\n        vorticity_from_v.solve()\n\n        mesh.write_timestep(\n            \"Example_7\",\n            meshUpdates=True,\n            meshVars=[p_soln, v_soln, vorticity],\n            outputPath=\"Example_output\",\n            index=timestep,\n        )\n\n        passive_swarm.write_timestep(\n            \"Example_7\",\n            \"passive_swarm\",\n            swarmVars=None,\n            outputPath=\"Example_output\",\n            index=timestep,\n            force_sequential=True,\n        )\n\n    timestep += 1\n    elapsed_time += delta_t\n\n    print(f\"Timestep: {timestep}, time {elapsed_time:.4f}\")\n\nTimestep: 1, time 0.0500\nTimestep: 2, time 0.1000\nTimestep: 3, time 0.1500\nTimestep: 4, time 0.2000\nTimestep: 5, time 0.2500\nTimestep: 6, time 0.3000\n\n\n\nKeyboardInterrupt\n# visualise it\n\nif uw.mpi.size == 1:\n    import pyvista as pv\n    import underworld3.visualisation as vis\n\n    pvmesh = vis.mesh_to_pv_mesh(mesh)\n    pvmesh.point_data[\"P\"] = vis.scalar_fn_to_pv_points(pvmesh, p_soln.sym)\n    pvmesh.point_data[\"Omega\"] = vis.scalar_fn_to_pv_points(pvmesh, vorticity.sym)\n    pvmesh.point_data[\"V\"] = vis.vector_fn_to_pv_points(pvmesh, v_soln.sym)\n\n    pvmesh_v = vis.meshVariable_to_pv_mesh_object(v_soln, alpha=None)\n    pvmesh_v.point_data[\"V\"] = vis.vector_fn_to_pv_points(pvmesh_v, v_soln.sym)\n\n    skip = 1\n    points = np.zeros((mesh._centroids[::skip].shape[0], 3))\n    points[:, 0] = mesh._centroids[::skip, 0]\n    points[:, 1] = mesh._centroids[::skip, 1]\n    point_cloud = pv.PolyData(points)\n\n    pvstream = pvmesh.streamlines_from_source(\n        point_cloud,\n        vectors=\"V\",\n        integration_direction=\"both\",\n        integrator_type=45,\n        surface_streamlines=True,\n        initial_step_length=0.01,\n        max_time=1.0,\n        max_steps=500,\n    )\n\n    passive_swarm_points = uw.visualisation.swarm_to_pv_cloud(passive_swarm)\n\n    pl = pv.Plotter(window_size=(750, 750))\n\n    pl.add_mesh(\n        pvmesh,\n        cmap=\"RdBu_r\",\n        edge_color=\"Grey\",\n        edge_opacity=0.33,\n        scalars=\"Omega\",\n        show_edges=True,\n        use_transparency=False,\n        opacity=0.75,\n        show_scalar_bar=False,\n    )\n\n    # Optional: plot streamlines\n    # pl.add_mesh(pvstream, opacity=0.3, show_scalar_bar=False, cmap=\"Greys_r\", render_lines_as_tubes=False)\n\n    pl.add_points(\n        passive_swarm_points,\n        color=\"Black\",\n        render_points_as_spheres=False,\n        point_size=4,\n        opacity=0.33,\n    )\n\n    # pl.add_arrows(pvmesh_v.points, pvmesh_v.point_data[\"V\"], mag=0.1)\n\n    # pl.camera_position = 'xy'\n    pl.camera.position = (2.0, 0.5, 4)\n\n    pl.export_html(f\"html5/ns_flow_plot_{timestep}.html\")\n\n    pl.screenshot(\n        f\"ns_flow_at_{timestep}.png\", window_size=(4000, 1000), return_img=False\n    )\nfrom IPython.display import IFrame\n\nIFrame(src=f\"html5/ns_flow_plot_50.html\", width=1000, height=400)\n\n\n        \n        \nInteractive Image: Time-dependent model output",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html#properties",
    "href": "Notebooks/7-Unsteady_Flow.html#properties",
    "title": "Notebook 7: Unsteady Flow",
    "section": "Properties",
    "text": "Properties\n\nThe unknown is \\(u\\).\nThe history variable is \\(u^*\\) and is provided in the form of a sympy function. It is the user’s responsibility to keep this variable updated.\nThe diffusivity tensor, \\(\\kappa\\) is provided by setting the constitutive_model property to one of the scalar uw.constitutive_models classes and populating the parameters. It is usually a constant or a function of position / time and may also be non-linear or anisotropic.\nVolumetric sources of \\(u\\) are specified using the \\(f\\) property and can be any valid combination of sympy functions of position and meshVariable or swarmVariable types.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html#notes",
    "href": "Notebooks/7-Unsteady_Flow.html#notes",
    "title": "Notebook 7: Unsteady Flow",
    "section": "Notes",
    "text": "Notes\n\nThe solver requires relatively high order shape functions to accurately interpolate the history terms. Spiegelman & Katz recommend cubic or higher degree for \\(u\\) but this is not checked.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html#references",
    "href": "Notebooks/7-Unsteady_Flow.html#references",
    "title": "Notebook 7: Unsteady Flow",
    "section": "References",
    "text": "References\nSpiegelman, M., & Katz, R. F. (2006). A semi-Lagrangian Crank-Nicolson algorithm for the numerical solution of advection-diffusion problems. Geochemistry, Geophysics, Geosystems, 7(4). https://doi.org/10.1029/2005GC001073",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/7-Unsteady_Flow.html#exercise---7.1",
    "href": "Notebooks/7-Unsteady_Flow.html#exercise---7.1",
    "title": "Notebook 7: Unsteady Flow",
    "section": "Exercise - 7.1",
    "text": "Exercise - 7.1\nNow that you have seen the structure of the flow in this example, can you adjust the addition of particles to capture the structure more clearly ?\nThis is a very low-resolution example. You can try increasing the resolution but you will see that this would benefit from running in parallel. In parallel we should remove all the visualisation and visualise the h5 output files when we are done. The rest of the code is parallel-safe.\n\nReferences\nAcheson, D. J. (1990). Elementary Fluid Dynamics. Oxford University PressOxford. https://doi.org/10.1093/oso/9780198596608.001.0001",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Notebook 7: Unsteady Flow</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html",
    "href": "Notebooks/8-Particle_Swarms.html",
    "title": "Notebook 8: Particle Swarms",
    "section": "",
    "text": "Deform the mesh\nWe used a particle swarm to track the flow in Example 7. We called this a “passive” swarm because the points did not influence the flow in any way but were simply carried along with the fluid.\nParticle swarms are unstructured data objects that live within the computational domain. Their points can be moved arbitrarily through the domain and points may migrate from one process to another when the coordinates are changed. By default they carry only the particle location, but we can add scalar, vector and tensor variables to the swarm and they will be transported with the particles.\nParticle transport is usually through a velocity or displacement field that incrementally changes the locations. This is a common use, but particles can be used to represent any unstructured field. For example, during mesh adaptation, the nodal points from the previous mesh are equivalent to a disconnected swarm from the point of view of the new mesh. The same is true when reading data save from one mesh to the MeshVariables on another.\nMove all nodes down to meet an undulating lower surface. The displacement field is smooth and continuous, so there is no particular need to remesh in this case. However, it is generally better to consider either deforming the mesh with gmsh before triangulation, or remeshing (both are possible with underworld3, but not as simple to demonstrate).\nnew_coords = mesh.data\ndy = (1 - y) * (sympy.sin(sympy.pi * x) / 10)\nnew_coords[:, 1] = uw.function.evaluate(y - dy, mesh.data)\n\ndisplay(dy)\n\nmesh.deform_mesh(new_coords)\n\n\\(\\displaystyle \\frac{\\left(1 - \\mathrm{y}\\right) \\sin{\\left(\\mathrm{x} \\pi \\right)}}{10}\\)\n# y coordinate after 1st deformation\ny1 = uw.discretisation.MeshVariable(\n    \"Y1\", mesh, vtype=uw.VarType.SCALAR, varsymbol=r\"y_1\"\n)\n\nwith mesh.access(y1):\n    y1.data[:, 0] = uw.function.evaluate(y, y1.coords)\n\nVariable with name Y1 already exists on the mesh - Skipping.",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  },
  {
    "objectID": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "href": "Notebooks/8-Particle_Swarms.html#exercise---8.1",
    "title": "Notebook 8: Particle Swarms",
    "section": "Exercise - 8.1",
    "text": "Exercise - 8.1\nLook at the Stokes example and try with a free slip base and low / high viscosity for the trapped material. You could also see what mixing the boundary condition looks like: free slip in the troughs, fixed in the highs. This is possible with a single boundary condition if you use sympy.Piecewise to switch between different penalty conditions.\n\n    ## Free slip base (conditional)\n\n    Gamma = mesh.Gamma\n    GammaNorm = uw.function.expression(r\"|\\Gamma|\", sympy.sqrt(Gamma.dot(Gamma)), \"Scaling for surface normals\")\n    GammaN = Gamma / GammaNorm\n    \n    bc_mask = sympy.Piecewise((1.0, y1.sym[0] &lt; -0.05), (0.0, True))\n    nbc = 10000 * bc_mask * GammaN.dot(v_soln.sym) *  GammaN + (1-bc_mask) * v_soln.sym            \n    stokes.add_natural_bc(nbc, \"Lower\")\nGive that a try !",
    "crumbs": [
      "Notebooks",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Notebook 8: Particle Swarms</span>"
    ]
  }
]