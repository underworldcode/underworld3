#!/bin/bash
#
# Underworld3 environment wrapper
#
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/.pixi-env"
PETSC_CUSTOM="$SCRIPT_DIR/petsc-custom/petsc"

# Colors (if terminal supports it)
if [ -t 1 ]; then
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BOLD='\033[1m'
    NC='\033[0m'
else
    GREEN='' YELLOW='' BOLD='' NC=''
fi

# Find pixi - check PATH first, then ~/.pixi/bin/ (where installer puts it)
find_pixi() {
    if command -v pixi &> /dev/null; then
        echo "pixi"
    elif [ -x "$HOME/.pixi/bin/pixi" ]; then
        echo "$HOME/.pixi/bin/pixi"
    else
        echo ""
    fi
}

PIXI=$(find_pixi)

get_env() {
    if [ -f "$CONFIG_FILE" ]; then
        cat "$CONFIG_FILE" | tr -d '[:space:]'
    else
        echo "runtime"
    fi
}

petsc_built() {
    # Check for actual PETSc library, not just the lib directory
    # The lib directory can exist if the build failed partway through
    [ -f "$PETSC_CUSTOM/petsc-4-uw/lib/libpetsc.dylib" ] || \
    [ -f "$PETSC_CUSTOM/petsc-4-uw/lib/libpetsc.so" ] || \
    [ -f "$PETSC_CUSTOM/petsc-4-uw/lib/libpetsc.a" ]
}

petsc4py_installed() {
    local env="$1"
    $PIXI run -e "$env" python -c "import petsc4py" 2>/dev/null
}

uw3_importable() {
    local env="$1"
    $PIXI run -e "$env" python -c "import underworld3" 2>/dev/null
}

is_amr_env() {
    local env="$1"
    [[ "$env" == amr* ]]
}

# Smart build with dependency chain handling
run_build() {
    local env=$(get_env)

    echo -e "${BOLD}Building underworld3${NC} (environment: $env)"
    echo ""

    # AMR environments need custom PETSc + petsc4py first
    if is_amr_env "$env"; then
        # Step 1: Check/build custom PETSc
        if ! petsc_built; then
            echo -e "${YELLOW}AMR environment requires custom PETSc (not yet built)${NC}"
            echo ""
            echo "Custom PETSc includes adaptive mesh tools (pragmatic, mmg, parmmg)"
            echo "Build time: ~1 hour on Apple Silicon"
            echo ""
            read -p "Build custom PETSc now? [Y/n]: " build_petsc
            build_petsc=${build_petsc:-y}
            if [ "$build_petsc" = "y" ] || [ "$build_petsc" = "Y" ]; then
                echo ""
                $PIXI run -e "$env" ./petsc-custom/build-petsc.sh
                if [ $? -ne 0 ]; then
                    echo -e "${YELLOW}PETSc build failed. Check errors above.${NC}"
                    exit 1
                fi
            else
                echo ""
                echo "Cannot build underworld3 without PETSc."
                echo "Run './uw petsc-local-build' when ready, then './uw build'"
                exit 1
            fi
        else
            echo -e "  ${GREEN}✓${NC} Custom PETSc already built"
        fi

        # Step 2: Check/build petsc4py
        if ! petsc4py_installed "$env"; then
            echo "  Installing petsc4py for $env..."
            (cd "$PETSC_CUSTOM/src/binding/petsc4py" && \
             $PIXI run -e "$env" pip install . --no-build-isolation) || {
                echo -e "${YELLOW}petsc4py build failed${NC}"
                exit 1
            }
            echo -e "  ${GREEN}✓${NC} petsc4py installed"
        else
            echo -e "  ${GREEN}✓${NC} petsc4py already installed"
        fi
    else
        # Non-AMR: conda-forge petsc4py should be there from pixi install
        if ! petsc4py_installed "$env"; then
            echo -e "${YELLOW}petsc4py not found. Running pixi install...${NC}"
            $PIXI install -e "$env"
        fi
    fi

    # Step 3: Build underworld3
    echo "  Building underworld3..."
    $PIXI run -e "$env" pip install . --no-build-isolation || {
        echo -e "${YELLOW}underworld3 build failed${NC}"
        exit 1
    }

    echo ""
    echo -e "${GREEN}${BOLD}Build complete!${NC}"
    echo ""
    echo "Next: ./uw test    (run tests)"
    echo "      ./uw doctor  (check configuration)"
}

# Standalone diagnostics (works even if underworld3 not built)
run_doctor() {
    local env=$(get_env)
    local errors=0
    local warnings=0

    echo ""
    echo "============================================================"
    echo "  Underworld3 Diagnostics"
    echo "============================================================"
    echo ""
    echo "Environment: $env"
    echo ""

    # Check 1: Pixi environment installed?
    echo -n "  Checking pixi environment... "
    if env_installed "$env"; then
        echo -e "${GREEN}[OK]${NC} $env installed"
    else
        echo -e "${YELLOW}[ERROR]${NC} $env not installed"
        echo "      Fix: pixi install -e $env"
        ((errors++))
    fi

    # Check 2: For AMR, is custom PETSc built?
    if is_amr_env "$env"; then
        echo -n "  Checking custom PETSc... "
        if petsc_built; then
            echo -e "${GREEN}[OK]${NC} Custom PETSc built"
        else
            echo -e "${YELLOW}[ERROR]${NC} Custom PETSc not built"
            echo "      Fix: ./uw petsc-local-build  (takes ~1 hour)"
            ((errors++))
        fi

        # Check 3: petsc4py installed?
        echo -n "  Checking petsc4py... "
        if petsc4py_installed "$env"; then
            echo -e "${GREEN}[OK]${NC} petsc4py available"
        else
            echo -e "${YELLOW}[ERROR]${NC} petsc4py not installed"
            if petsc_built; then
                echo "      Fix: ./uw build  (will install petsc4py)"
            else
                echo "      Fix: Build PETSc first, then ./uw build"
            fi
            ((errors++))
        fi
    else
        # Non-AMR: check conda-forge petsc4py
        echo -n "  Checking petsc4py... "
        if petsc4py_installed "$env"; then
            echo -e "${GREEN}[OK]${NC} petsc4py available"
        else
            echo -e "${YELLOW}[ERROR]${NC} petsc4py not found"
            echo "      Fix: pixi install -e $env"
            ((errors++))
        fi
    fi

    # Check 4: underworld3 importable?
    echo -n "  Checking underworld3... "
    local import_error=""
    import_error=$($PIXI run -e "$env" python -c "import underworld3" 2>&1)
    local import_status=$?

    if [ $import_status -eq 0 ]; then
        echo -e "${GREEN}[OK]${NC} underworld3 importable"

        # If importable, run Python diagnostics for deeper checks
        echo ""
        echo "  Running detailed diagnostics..."
        $PIXI run -e "$env" python -c "import underworld3 as uw; uw.doctor()" 2>&1 | sed 's/^/  /'
    else
        echo -e "${YELLOW}[ERROR]${NC} underworld3 not importable"

        # Check for specific PETSc library mismatch error
        if echo "$import_error" | grep -q "libpetsc"; then
            echo ""
            echo -e "      ${YELLOW}PETSc library version mismatch detected!${NC}"
            echo ""
            # Extract the library name from error
            local lib_name=$(echo "$import_error" | grep -o "libpetsc[^']*" | head -1)
            if [ -n "$lib_name" ]; then
                echo "      Extension was built against: $lib_name"
            fi
            # Get current PETSc version
            local petsc_ver=$($PIXI run -e "$env" python -c "from petsc4py import PETSc; v=PETSc.Sys.getVersion(); print(f'{v[0]}.{v[1]}.{v[2]}')" 2>/dev/null)
            if [ -n "$petsc_ver" ]; then
                echo "      Current petsc4py version:    $petsc_ver"
            fi
            echo ""
            echo "      This happens when PETSc is updated but underworld3"
            echo "      wasn't rebuilt. The extension is linked to the old library."
            echo ""
            echo -e "      ${BOLD}Fix:${NC}"
            echo "        pip uninstall underworld3"
            echo "        rm -rf build/"
            echo "        ./uw build"
            echo ""
        else
            echo "      Fix: ./uw build"
            # Show first few lines of error for debugging
            echo ""
            echo "      Import error:"
            echo "$import_error" | head -5 | sed 's/^/        /'
        fi
        ((errors++))
    fi

    echo ""
    echo "------------------------------------------------------------"
    if [ $errors -gt 0 ]; then
        echo -e "  ${YELLOW}[FAIL]${NC} $errors error(s) found - see fixes above"
        echo ""
        echo "  Quick fix: ./uw build  (handles dependency chain)"
    else
        echo -e "  ${GREEN}[OK]${NC} All checks passed"
    fi
    echo "------------------------------------------------------------"
}

# Check and install pixi if needed
check_pixi() {
    if [ -n "$PIXI" ]; then
        return 0
    fi

    echo -e "${YELLOW}Pixi package manager not found.${NC}"
    echo ""
    echo "Pixi is required to manage Underworld3 dependencies."
    echo "Install from: https://pixi.sh"
    echo ""
    read -p "Install pixi now? [Y/n]: " install_pixi
    install_pixi=${install_pixi:-y}

    if [ "$install_pixi" = "y" ] || [ "$install_pixi" = "Y" ]; then
        echo ""
        echo "Installing pixi..."
        curl -fsSL https://pixi.sh/install.sh | bash

        # Update PIXI variable to find newly installed pixi
        PIXI=$(find_pixi)

        if [ -n "$PIXI" ]; then
            echo -e "${GREEN}✓ Pixi installed successfully${NC}"
            echo ""
            return 0
        else
            echo ""
            echo -e "${YELLOW}Pixi installation failed.${NC}"
            echo "Please install manually from https://pixi.sh"
            exit 1
        fi
    else
        echo ""
        echo "Install pixi manually from https://pixi.sh then run './uw setup'"
        exit 1
    fi
}

# Interactive setup wizard
run_setup() {
    # Ensure pixi is available
    check_pixi

    echo -e "${BOLD}Underworld3 Setup${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""

    # Question 1: AMR tools?
    echo -e "${BOLD}Do you need adaptive mesh refinement (AMR) tools?${NC}"
    echo "  (pragmatic, mmg, parmmg for anisotropic mesh adaptation)"
    echo ""
    echo "  [1] No  - conda-forge PETSc (5-minute install)"
    echo "  [2] Yes - custom PETSc build (~1 hour)"
    echo ""
    read -p "Choice [1]: " amr_choice
    amr_choice=${amr_choice:-1}

    local use_amr=false
    [ "$amr_choice" = "2" ] && use_amr=true

    echo ""

    # Question 2: Features?
    echo -e "${BOLD}What features do you need?${NC}"
    echo ""
    echo "  [1] Minimal   - build and run only"
    echo "  [2] Runtime   - add visualization + Jupyter"
    echo "  [3] Developer - add Claude, linting, docs"
    echo ""
    read -p "Choice [2]: " feature_choice
    feature_choice=${feature_choice:-2}

    # Determine environment
    local new_env
    if [ "$use_amr" = true ]; then
        case "$feature_choice" in
            1) new_env="amr" ;;
            3) new_env="amr-dev" ;;
            *) new_env="amr-runtime" ;;
        esac
    else
        case "$feature_choice" in
            1) new_env="default" ;;
            3) new_env="dev" ;;
            *) new_env="runtime" ;;
        esac
    fi

    echo ""
    echo -e "Environment: ${GREEN}$new_env${NC}"
    echo "$new_env" > "$CONFIG_FILE"
    echo ""

    # Install
    echo "Installing dependencies..."
    $PIXI install -e "$new_env"
    echo ""

    # AMR-specific
    if [ "$use_amr" = true ]; then
        if petsc_built; then
            echo -e "${GREEN}✓ Custom PETSc already built${NC}"
            echo "Installing petsc4py..."
            (cd "$PETSC_CUSTOM/src/binding/petsc4py" && $PIXI run -e "$new_env" python setup.py install) 2>/dev/null
        else
            echo -e "${YELLOW}Custom PETSc needs to be built (~1 hour)${NC}"
            read -p "Build now? [y/N]: " build_now
            if [ "$build_now" = "y" ] || [ "$build_now" = "Y" ]; then
                $PIXI run -e "$new_env" ./petsc-custom/build-petsc.sh
            else
                echo ""
                echo "Build later with: ./uw petsc-local-build"
                echo ""
            fi
        fi
    fi

    # Build underworld3
    echo ""
    read -p "Build underworld3? [Y/n]: " build_uw
    build_uw=${build_uw:-y}
    if [ "$build_uw" = "y" ] || [ "$build_uw" = "Y" ]; then
        $PIXI run -e "$new_env" pip install . --no-build-isolation
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Setup complete!${NC}"
    echo ""
    echo "Usage:"
    echo "  ./uw build          Build underworld3"
    echo "  ./uw test           Run tests"

    # Show Jupyter info
    case "$new_env" in
        default|amr)
            echo ""
            echo "Note: Minimal environment - no JupyterLab/visualization."
            echo "Notebooks work via IDE kernels (VS Code, etc)."
            echo "Run './uw setup' again to add JupyterLab."
            ;;
        *)
            echo "  ./uw jupyter lab    Start JupyterLab"
            ;;
    esac
    echo ""
    echo "For VS Code / IDE Jupyter kernels, set pixi environment to: $new_env"
}

# Show comprehensive help
show_help() {
    cat << 'EOF'
UNDERWORLD3 ENVIRONMENT WRAPPER
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

QUICK START

  ./uw setup              Configure environment (interactive)
  ./uw build              Build underworld3
  ./uw test               Run tests (level 1, ~2 min)
  ./uw jupyter lab        Start JupyterLab
  ./uw status             Check for updates on GitHub
  ./uw update             Pull latest and rebuild

ENVIRONMENTS

  ┌─────────────┬──────────────────┬─────────────────────────────────┐
  │ Environment │ PETSc            │ Features                        │
  ├─────────────┼──────────────────┼─────────────────────────────────┤
  │ default     │ conda-forge      │ minimal                         │
  │ runtime     │ conda-forge      │ + pyvista, jupyter              │
  │ dev         │ conda-forge      │ + claude, black, mypy           │
  ├─────────────┼──────────────────┼─────────────────────────────────┤
  │ amr         │ custom (~1hr)    │ minimal + AMR tools             │
  │ amr-runtime │ custom (~1hr)    │ + pyvista, jupyter              │
  │ amr-dev     │ custom (~1hr)    │ + claude, black, mypy           │
  └─────────────┴──────────────────┴─────────────────────────────────┘

COMMANDS

  Setup:
    setup               Interactive configuration wizard
    set-env NAME        Change environment directly

  Building:
    build               Build underworld3
    clean               Clean build artifacts
    petsc-local-build   Build custom PETSc + petsc4py (AMR, ~1 hour)
    petsc-local-clean   Remove custom PETSc build

  Testing:
    test [opts]         Level 1 tests (~2 min, fast mode)
    test-all [opts]     All test levels (~20 min)

    Options pass through to test script:
      --isolation       Run each file in subprocess (thorough)
      --parallel        Include MPI tests (2 ranks)
      --parallel-ranks N  MPI tests with N ranks
      1,2,3             Override test levels

    Examples:
      ./uw test                     Quick level 1, fast mode
      ./uw test --isolation         Level 1 with process isolation
      ./uw test --parallel 2        Level 2 with MPI tests
      ./uw test-all --isolation     All levels, isolated (CI mode)
      ./uw test --help              Show all test options

  Development:
    shell               Interactive pixi shell
    jupyter [args]      Run jupyter
    format              Run black
    type-check          Run mypy

  Diagnostics:
    doctor              Check for configuration issues (PETSc mismatch, etc.)
    status              Check for updates on GitHub (without pulling)
    update              Pull latest changes and rebuild

  Any command not listed is passed to: pixi run -e $ENV <command>

FILES

  .pixi-env             Your environment choice (git-ignored)
  pixi.toml             Environment definitions (versioned)
  petsc-custom/petsc/   Custom PETSc build (git-ignored)

EOF
}

# Check for updates on remote (without pulling)
check_for_updates() {
    local quiet="${1:-false}"

    # Check if this is a git repo
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        [ "$quiet" = "false" ] && echo "Not a git repository"
        return 1
    fi

    cd "$SCRIPT_DIR"

    # Get current branch
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ -z "$branch" ]; then
        [ "$quiet" = "false" ] && echo "Could not determine current branch"
        return 1
    fi

    # Fetch updates from remote (just metadata, no merge)
    if [ "$quiet" = "false" ]; then
        echo "Checking for updates on branch: $branch"
        echo ""
    fi

    git fetch origin "$branch" --quiet 2>/dev/null

    # Count commits behind/ahead
    local behind=$(git rev-list --count HEAD..origin/"$branch" 2>/dev/null || echo "0")
    local ahead=$(git rev-list --count origin/"$branch"..HEAD 2>/dev/null || echo "0")

    if [ "$quiet" = "true" ]; then
        # Return status for quiet mode
        [ "$behind" -gt 0 ] && return 0 || return 1
    fi

    # Show status
    if [ "$behind" -eq 0 ] && [ "$ahead" -eq 0 ]; then
        echo -e "  ${GREEN}✓${NC} Up to date with origin/$branch"
    else
        if [ "$behind" -gt 0 ]; then
            echo -e "  ${YELLOW}↓${NC} $behind commit(s) behind origin/$branch"
            echo ""
            echo "  Recent changes on remote:"
            git log --oneline HEAD..origin/"$branch" | head -5 | sed 's/^/    /'
            local total_behind=$(git rev-list --count HEAD..origin/"$branch")
            [ "$total_behind" -gt 5 ] && echo "    ... and $((total_behind - 5)) more"
        fi
        if [ "$ahead" -gt 0 ]; then
            echo -e "  ${GREEN}↑${NC} $ahead commit(s) ahead of origin/$branch"
        fi
        echo ""
        if [ "$behind" -gt 0 ]; then
            echo "  Run './uw update' to pull changes and rebuild"
        fi
    fi

    # Check for local modifications
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
        echo ""
        echo -e "  ${YELLOW}!${NC} You have uncommitted local changes"
    fi

    return 0
}

# Pull updates and rebuild
run_update() {
    cd "$SCRIPT_DIR"

    # Check if this is a git repo
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        echo "Not a git repository"
        exit 1
    fi

    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    echo -e "${BOLD}Updating Underworld3${NC} (branch: $branch)"
    echo ""

    # Check for local changes
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
        echo -e "${YELLOW}You have uncommitted local changes:${NC}"
        git status --short
        echo ""
        read -p "Stash changes and continue? [y/N]: " stash_choice
        if [ "$stash_choice" = "y" ] || [ "$stash_choice" = "Y" ]; then
            git stash push -m "uw update: auto-stash $(date +%Y-%m-%d_%H:%M)"
            echo ""
        else
            echo "Commit or stash your changes first, then run './uw update'"
            exit 1
        fi
    fi

    # Pull updates
    echo "Pulling from origin/$branch..."
    if git pull origin "$branch"; then
        echo ""
        echo -e "${GREEN}✓${NC} Pull successful"
        echo ""

        # Rebuild
        read -p "Rebuild underworld3? [Y/n]: " rebuild_choice
        rebuild_choice=${rebuild_choice:-y}
        if [ "$rebuild_choice" = "y" ] || [ "$rebuild_choice" = "Y" ]; then
            echo ""
            run_build
        else
            echo ""
            echo "Run './uw build' when ready to rebuild"
        fi
    else
        echo ""
        echo -e "${YELLOW}Pull failed - check errors above${NC}"
        exit 1
    fi
}

# Check if an environment is installed
env_installed() {
    [ -d "$SCRIPT_DIR/.pixi/envs/$1" ]
}

# Check if underworld3 is built in an environment
uw3_built() {
    [ -d "$SCRIPT_DIR/.pixi/envs/$1/lib/python3.12/site-packages/underworld3" ]
}

# Show environment status table
show_env_status() {
    local current_env=$(get_env)
    local has_petsc=$(petsc_built && echo "yes" || echo "no")

    echo "Environments:  (* = selected,  [✓] = uw3 built,  [ ] = needs ./uw build)"
    echo ""

    for env in default runtime dev amr amr-runtime amr-dev; do
        # Selected marker
        local marker="  "
        [ "$env" = "$current_env" ] && marker="* "

        # Build status
        local build_status="[ ]"
        if ! env_installed "$env"; then
            build_status="───"  # Not installed
        elif uw3_built "$env"; then
            build_status="[✓]"
        fi

        # Description
        local desc=""
        case "$env" in
            default)     desc="minimal" ;;
            runtime)     desc="+ viz, jupyter" ;;
            dev)         desc="+ claude, linting" ;;
            amr)         desc="custom PETSc" ;;
            amr-runtime) desc="custom PETSc + viz" ;;
            amr-dev)     desc="custom PETSc + dev" ;;
        esac

        # AMR note if PETSc not built
        if [[ "$env" == amr* ]] && [ "$has_petsc" = "no" ]; then
            desc="$desc (petsc not built)"
        fi

        printf "  %s%-11s  %s  %s\n" "$marker" "$env" "$build_status" "$desc"
    done
}

# Brief welcome + offer setup
show_welcome() {
    echo -e "${BOLD}Underworld3${NC}"
    echo ""

    # Check for pixi first
    if [ -z "$PIXI" ]; then
        echo "Environment: (pixi not installed)"
        echo ""
        read -p "Run setup to install pixi? [Y/n]: " do_setup
        do_setup=${do_setup:-y}
        if [ "$do_setup" = "y" ] || [ "$do_setup" = "Y" ]; then
            echo ""
            run_setup
        else
            echo ""
            echo "Install pixi from https://pixi.sh then run './uw setup'"
        fi
        return
    fi

    if [ -f "$CONFIG_FILE" ]; then
        show_env_status
        echo ""
        echo "Commands:  ./uw setup   ./uw build   ./uw test   ./uw doctor   ./uw --help"
    else
        echo "Environment: (not configured)"
        echo ""
        read -p "Run setup? [Y/n]: " do_setup
        do_setup=${do_setup:-y}
        if [ "$do_setup" = "y" ] || [ "$do_setup" = "Y" ]; then
            echo ""
            run_setup
        else
            echo ""
            echo "Run './uw setup' when ready, or './uw --help' for options."
        fi
    fi
}

# Main
case "${1:-}" in
    "")
        show_welcome
        ;;
    setup)
        run_setup
        ;;
    set-env)
        if [ -z "$2" ]; then
            echo "Usage: ./uw set-env <environment>"
            echo "Options: default, runtime, dev, amr, amr-runtime, amr-dev"
            exit 1
        fi
        echo "$2" > "$CONFIG_FILE"
        echo "Environment: $2"
        echo "Run './uw build' to rebuild underworld3"
        ;;
    shell)
        shift
        exec $PIXI shell -e "$(get_env)" "$@"
        ;;
    jupyter)
        shift
        exec $PIXI run -e "$(get_env)" jupyter "$@"
        ;;
    build)
        run_build
        ;;
    doctor)
        run_doctor
        ;;
    status)
        check_for_updates
        ;;
    update)
        run_update
        ;;
    --help|-h|help)
        show_help
        ;;
    *)
        exec $PIXI run -e "$(get_env)" "$@"
        ;;
esac
